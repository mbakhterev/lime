(
	.FEnv (("A"; .T ('02.0."")); .F
	(
		.Nth name (.FIn (); (1));
		.S sym (name; .T ("I"; 4));

		// Теперь нужен символ для дальнейшего развития событий:

		.FOut (0; (
			("symbol"; sym)));

		// Дальше может быть два варианта развития событий. Этот вывод
		// может закончится в lvalue или rvalue. На каждый из вариантов
		// публикуем по форме

		.FPut (0; ("symbol"; "rvalue"); .F
		(
			// Слева мы или справа. Эта информация вместе с rvalue
			// должна прийти

			.Nth position (.FIn (); (1; 1));
			.Nth sym (.FIn (); (1; 0));

			.rd val (.T ("I"; 4); .addr (.T ("P"; 4); sym));

			// Регистрируем выход, для будущего связывания, когда
			// эту форму этого контекста заберут выше. Список из пар
			// должен быть

			.FOut (1; (
				(("rvalue"; position); val)));

			// Сообщаем вверх, что всё готово и завершаем вывод
			// здесь. Это просто сигнал, само значение не важно

			.FOut (.R (("UP")); (
				(("done"; position); 1)));

			.Done ()
		));

		.FPut (0; ("symbol"; "lvalue"); .F
		(
			// На самом деле, всегда должно быть слева, но для
			// общности

			.Nth position (.FIn (); (1; 1));
			.Nth sym (.FIn (); (1; 0));

			.addr addr (.T ("P"; 4); sym);

			.FOut (1; (
				(("lvalue"; position); addr)));

			.FOut (.R (("UP")); (
				(("done"; position); 1)));

			.Done ()
		));

		// Ещё один вариант на случай «;» просто продолжаем

		.FPut (0; ("symbol"; "sequence"); .F
		(
			.Nth position (.FIn (); (1; 1));

			.FOut (.R (("UP")); (
				(("done"; position); 1)));

			.Done ()
		));

		// Можем продолжать

		.Go (.E (("this")))
	))
)
