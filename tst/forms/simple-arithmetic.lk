(
	.FEnv (("A"; .T ('02.0."")); .F
	(
		.Nth name (.FIn (); (1));
		.S sym (name; .T ("I"; 4));

		// Теперь нужен символ для дальнейшего развития событий:

		.FOut (0; (
			("symbol"; sym)));

		// Дальше может быть два варианта развития событий. Этот вывод
		// может закончится в lvalue или rvalue. На каждый из вариантов
		// публикуем по форме

		.FPut (0; ("symbol"; "rvalue"); .F
		(
			// Слева мы или справа. Эта информация вместе с rvalue
			// должна прийти

			.Nth position (.FIn (); (1; 1));
			.Nth sym (.FIn (); (1; 0));

			.rd val (.T ("I"; 4); .addr (.T ("P"; 4); sym));

			// Регистрируем выход, для будущего связывания, когда
			// эту форму этого контекста заберут выше. Список из пар
			// должен быть

			.FOut (1; (
				(("rvalue"; position); val)));

			// Сообщаем вверх, что всё готово и завершаем вывод
			// здесь. Это просто сигнал, само значение не важно

			.FOut (.R (("UP")); (
				(("done"; position); 1)));

			.Done ()
		));

		.FPut (0; ("symbol"; "lvalue"); .F
		(
			// На самом деле, всегда должно быть слева, но для
			// общности

			.Nth position (.FIn (); (1; 1));
			.Nth sym (.FIn (); (1; 0));

			.addr addr (.T ("P"; 4); sym);

			.FOut (1; (
				(("lvalue"; position); addr)));

			.FOut (.R (("UP")); (
				(("done"; position); 1)));

			.Done ()
		));

		// Можем продолжать

		.Go (.E ("ENV"; ("this")))
	));

	.FEnv (("binop"; '14.1."+"); .F
	(
		.Nth l (.FIn (); (1; 0));
		.Nth r (.FIn (); (1; 1));
		
		.add result (.T ("I"; 4); l; r);
		.FOut (0; (
			("result"; result)))
	));

	.FEnv (("binop"; '14.1."*"); .F
	(
		.Nth l (.FIn (); (1; 0));
		.Nth r (.FIn (); (1; 1));
		
		.mul result (.T ("I"; 4); l; r);
		.FOut (0; (
			("result"; result)))
	));

	.FEnv (("L"; .T ('14.0."")); .F
	(
		// Работаем с арифметической операцией. Сначала опубликуем
		// формы, описывающие окончательный результат

		.Nth op (.FIn (); (1));
		.FPut (0;
			(("rvalue"; "left"); ("rvalue"; "right"));
			.FEnv (("binop"; op)));

		// Далее формы, которые представят в результат работы этого
		// контекста в контекст выше. Нужен только rvalue вариант
		
		.FPut (0; ("result"; "rvalue"); .F
		(
			.Nth position (.FIn (); (1; 1));
			.Nth result (.FIn (); (1; 0));

			.FOut (1; (
				(("rvalue"; position); result)));

			// Сообщаем вверх, что всё готово и завершаем вывод
			// здесь. Это просто сигнал, само значение не важно

			.FOut (.R (("UP")); (
				(("done"; position); 1)));

			.Done ()
		));

		// Далее штука, которая упорядочит граф и обеспечит левую
		// ассоциативность исполнения операции

		.FPut (0; (("done"; "left")); .F
		(
			// Забираем то, что накопилось слева
			.FPut(0; (); .R (("LEFT")));
			
			// Синхронизатор

			.FPut(0; (("done"; "right"); ("rvalue"; "left")); .F
			(
				// Забираем то, что накопилось справа
				.FPut(0; (); .R (("RIGHT")))
			))
		));

		// Левый контекст тут уже известен, и можно было бы с ним уже
		// работать в рамках этого небольшого примера. Но для Си нам
		// нужно знать типы и справа, и слева, чтобы продолжать, поэтому
		// идём дальше

		.Go (.E ("ENV"; ("this")))	
	));

	.FEnv (("E"; .T('14.0."")); .F
	(
		// Устраиваем обмен информацией. В случае примера - примитивный.
		// В случае Си тут надо согласовать типы:

		.FOut (.R (("LEFT")); (
			("rvalue"; "left")));

		.FOut (.R (("RIGHT")); (
			("rvalue"; "right")));

		.Go (.E ("ENV"; ("this")))
	))
)
