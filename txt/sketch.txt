Так. Проблема в следующем. Если написано

	ffmpeg -f v4l2 -i "/dev/video0"

То парсер не увидит то, что ffmpeg является атомом слева до тех пор, пока не
увидит -f, и не воспримет уже всю конструкцию, как

	(- ffmpeg (sp f v4l2))

И это, в общем-то определённый уровень задницы. Есть ещё вариант: не мудрить. И
ничего не делать с приоритетами. Однако, это исключит всякие разные радости:

	var R matrix float = (1 2 3 4 5; 6 7 8 9 10);

	var R matrix float =
		((1; 2; 3; 4; 5); (6; 7; 8; 9; 10))

Мда уж. Но, может, в самом деле keep it simple?

	ffmpeg f:v4l2 i:"/dev/video0"

	ffmpeg f:v4l2 i:'/dev/video0'
		vf:(scale(640;480) | colorspace(grayscale(8))) o:'file.avi';

	ffmpeg -f v4l2 -i '/dev/video0'
		-vf scale(640:480).colorspace(grayscale(8)) -o 'file.avi'

Мда. Векторы, как оказывается, продуманы плохо. И что? Борьба будет за двоеточие
с высоким приоритетом? Это не очень хорошо. И это ещё полбеды. Настоящая беда в
том, что не существует никакого левого поддерева. Потому что оно может быть
только в случае, когда у первого apply меньший приоритет. А его нельзя потопить.
Получается, только один вариант:

	ffmpeg f.v4l2 i.dev.video.0
		vf(scale(640;480) | colorspace grayscale.8) fs.dev.video.0

Ладно, когда оно всё вместе написано, то не так уж и плохо выглядит.

	ffmpeg f.v4l2 i.'/dev/video0'
		vf(scale(640;480) -> x; x -> colorspace grayscale(8)) o.'file.avi'

Ладно.

	swtich
	(
	x && y -> dosomething(1);
	x -> dosomething(x + 2);

	y ^^ z ->
	(
		var f = something.1();
		var x = something.2();
		var y = something.3();

		for(x != y)
		(
			x += 1;
		);

		pin = f
	);

	default -> dodefault()
	);

Альтернатива

	swtich (
	x && y -> dosomething(1);
	x -> dosomething(x + 2);

	y ^^ z -> (
		var f = something.1();
		var x = something.2();
		var y = something.3();

		for(x != y)
		(
			x += 1;
		);

		pin = f);

	default -> dodefault())

Ладно. Будем тогда в этой модели дальше думать.

								 К ВОПРОСУ О «:»

Вообще, переменные можно было бы вводить и при помощи двоеточки. Потому что
область видимости может быть привязана к области видимости оператора. Это не
страшно. Но вопрос в том... В чём? В том, что нужен какой-нибудь вменяемый
приоритет для этой двоеточки.

	x : list int = (20; 30; 40);

	for((x;y) := range2d(1:20; 30:40))
	(
		print '%d.%d\n'.fmt(x;y))
	)

Вполне возможно, что вменяемая позиция - это где-нибудь между «=» и прочими
операциями. И что дальше? А ничего...

Крупица полезного смысла здесь в том, что операторы сами могут быть привязаны к
области видимости. Ну ладно...

	x: list int = (20; 30; 40);

	for((y; z) := range(1:20; 30:40))
	(
		print "%d.%d\n".fmt(x + y; z);
	)

И чего с этим делать? А пусть будет так:

	(x > 10 && Ex y Nat : x * y == 20) -> x == 2;

	x Nat : (Ex y Nat : x = y * 2) -> Ex z Nat : x = z << 1;

Сойдёт. Значит, система приоритетов получается примерно такая (^^ - это то же
самое, что и !=):

	0: ;
	1: = *= /= %= >>= <<= &= += -= |= ^= ||= &&=
	2: ->
	3: ||
	4: &&
	5: == != < <= > >=
	6: + - | ^
	7: * / % << >> &
	9: .

Было бы неплохо, видимо, иметь приоритет двоеточия где-то чуть выше стрелки.
Замечательно. Тогда можно писать

	fun max(a Num; b Num) = a > b -> a : b;

Ну и всё. Это однозначно говорит о том, что приоритет выше «=». Ладно, ок. А
Haskell стиль?

	fun max(a Num) = (fun(b Num) Num = a > b -> a : b)

	var x = max(2)(3);

	fun max(a num; b num) num = a > b -> a : b;
	stdin.bytes.filter(x byte) max(12345, int = x);


						   Mon Nov 19 13:40:29 YEKT 2012

Ок. Примеры из истории надо рассмотреть. Потому что сейчас очередной когнитивный
диссонанс пришёл, который вызван тремя возможными способами управлять
приоритетами:

	1. Очень просто. Однонаправленные связи, фиксированный приоритет.
		s-apply с высоким приоритетом.

	2. Обратная связь от движка, который говорит: а подними-ка ты временно
		вот эти приоритеты в правом поддереве. Правое поддерево хорошо
		определяется, как и левое в стандартном парсере.

	3. Сделать низкоприоритетный s-apply.


Посмотрим на примеры из истории.

	DISPLAY=:0.0 evince mcp.pdf &>/dev/null </dev/null &

	DISPLAY=0.0 evince 'mcp.pdf' (all)>dev.null <dev.null

Да. Это возможно, если уметь сказать, что неким магическим образом приоритет
пробела упал. Ок. Если этого сказать нельзя, как это может быть выражено?

	(DISPLAY=0.0; (1:2)=dev.null; evince) 'mcp.pdf'

Мечта идиота (моя), склонного к LISP? Ладно. Допустим. Что дальше? Что-нибудь
такое:

	(HOME=/tmp/flc/mike/ nice -n 20 linuxdcpp) &

	(HOME=tmp.flc.mike; n=20; nice) linuxdcpp

Ок. А что насчёт эпического?

	screen -S mp mplayer ~/Downloads/87* -vf crop=280:210,scale=320:240 -ao null -osdlevel 0 -display :32.1 -fixed-vo -loop 0

	screen S.mp mplayer vf(crop(280:210):scale(320:240)) ao.null osdlevel.0 display.32.1 vo.fixed loop.0 '~/Downloads.87*'

Ладно. Допустим. Хотя не очень красиво.

	{ [ -f /tmp/agent ] || ssh-agent > /tmp/agent; } && . /tmp/agent && ssh-add ~/.ssh/0xfb.mb

	var a='/tmp/agent'; (test f.(a) || ssh.agent 1.(a)) && (ENV += a) && ssh.add '~/.ssh/0xfb.mb'

	a=/tmp/agent; { [ -f "$a" ] || ssh-agent > "$a"; } && . "$a" && ssh-add ~/.ssh/0xfb.mb

Ну. Определённый уровень корявости есть.

	DISPLAY=:0.0 evince mcp.pdf &>/dev/null </dev/null &

	(DISPLAY=0.0; (1:2)=dev.null; evince) 'mcp.pdf'

	(DISPLAY=0.0; evince (1;2).w('/dev/null')) 'mcp.pdf'

Ладно. А так?

	a = '/tmp/agent'; (test f.(a) || (1=(a); ssh.agent) && (ENV += a) && ssh.add '~/.ssh/0xfb.mb'

Ещё

	mkdir /tmp/0x01 -p && sshfs mike@0x01.imm.uran.ru:/tmp/flc /tmp/0x01

	mkdir p '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/fls' '/tmp/0x01'

	mkdir p '/tmp/0x01' &&  sshfs 0x01.imm.uran.ru(mike).tmp.flc '/tmp/0x01'

	'/tmp/0x01' mkdir.p && 0x01.imm.uran.ru(mike).'/tmp/fls' '/tmp/0x01' sshfs

MoarrrrR

	gcc payload.c -fPIC -o pl.so -static-libgcc -shared -Wl,-static -lc -Wl,--strip-all -Wl,--gc-sections

	gcc f.pic shared Wl(static stripall sections) lc lstatic.libgcc o.'pl.so' 'payload.c'

---

	su -c 'cat /root/sys.d/nv-sync'

	su c.(cat '/root/sys.d/nv-sync') // уже распарсено

---
	#!/bin/dash

	set -e

	alias ctl='/usr/bin/systemctl'
	alias stat='/usr/bin/stat'
	alias su='/bin/su'
	alias chmod='/usr/bin/chmod'
	alias chown='/usr/bin/chown'
	alias mktemp='/usr/bin/mktemp'
	alias touch='/usr/bin/touch'
	alias mv='/usr/bin/mv'

	sync() {
		local backup target usr lock temp

		backup="$1"
		target="$2"
		user=$(stat -c %U "$backup")
		lock="$target/.nv-sync.lock"

		echo "$backup($user:$mode) -> $target"

		if [ -d "$target" ]
		then
			{ flock -xn 7 \
				&& su -c "/usr/bin/rsync -a --del --exclude .nv-sync.lock '$target/' '$backup/'" $user \
				|| { echo "will not sync. can't obtain lock: $lock"; exit 2; }; } 7<"$lock"

			return
		fi

		echo "no target: $target"
		if [ "$3" != 'up' ]
		then
			echo "no special parameter. not going up"
			exit 3
		fi

		temp=$(su -c "/usr/bin/mktemp -d '$target-XXXX'" $user)
		chmod --reference="$backup" "$temp"
		echo "going up: $temp"

		su -c "/usr/bin/rsync -a '$backup/' '$temp/'" $user
		touch "$temp/.nv-sync.lock"
		mv -n "$temp" "$target"
	}

	case "$1" in
	up)
		sync "/nvram/mb" "/home/mb" up
		;;

	down)
		sync "/nvram/mb" "/home/mb"
		;;

	sync)
		if ctl is-active nv-sync
		then
			sync "/nvram/mb" "/home/mb"
		else
			echo "not active"
			exit 1
		fi
		;;

	*)
		echo "unknown task"
		exit 4
	esac


LiME:
	exp mames = (ctl; stat; chmod; chown; mktem; touch; mv; rsync);
	val names = usr.bin.names;
	val su = bin.su;
	cmd sync (backup string) (target string) (up bool = 0) =
	(
		val user = (stat c.'%U' backup).out(0);
		val lock = target + '/.nv-sync.lock';

		echo '%s(%s:%s) -> %s'.fmt(backup; user; ''; target);

		if(test d.target)
		(
			run(7 = lock
				&& (flock xn.7 || (echo 'won\'t sync. can\'t obtain lock: ' lock; exit 2))
				&& su user c.(rsync a del exclude('.nv-sync.lock') target backup));

			return
		);

		echo 'no target: ' target;

		if(!up)
		(
			echo 'no special parameter. not going up';
			exit 3
		);

		val temp = (su user c.(mktemp d.(target + '-XXXX'))).out(0);
		chmod reference.backup temp;
		echo 'going up: ' temp;

		su user c.(rsync a target backup);
		touch '%s/.nv-sync.lock'.fmt(temp);
		mv n temp target
	)

	val sync.cmd = sync '/nvram/mb' '/home/mb';

	switch(CMD.1)
	(
		'up'	-> sync.cmd 1;
		'down'	-> sync.cmd;
		'sync'	-> if(ctl isactive 'nv-sync') sync.cmd or (echo 'not active'; exit 1);
		default -> (echo 'unknown task'; exit 4)
	)

Так. Вопрос ещё есть, возможно так:

	mkdir p "/tmp/0x01" && sshfs "mike@0x01.imm.uran.ru:/tmp/flc" "/tmp/0x01"

	mkdir p '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' '/tmp/0x01'

	var mp = '/tmp/0x01'; mkdir p mp && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' mp

	mkdir(p) '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' '/tmp/0x01'

	tar xv f.'some.tar.gz'

	(0='some.tar.gz'; gzip cd) | tar mx;

	gzip -cd some.tar.gz | tar mx;

	gzip 'some.tar.gz' cd | tar mx;

Эх. Идеала не существует

	val temp = (su (user) c.(mktemp d.(target + '-XXXX'))).out(0);
	chmod reference.(backup) temp;
	echo 'going up: ' (temp);

	su user c.(rsync a (target:backup));
	touch '%s/.nv-sync.lock'.fmt(temp);
	mv n (target:backup)

	mv(target:backup) n;
	run(rsync(target:backup) a) u.(user)

	git.filter branch fcmd.(rm rf 'src/password')

	tar c './' | (out='some.tar.gz'; gzip)

В этом, может быть, что-нибудь да есть. Потому что

	mv n (source.1 source.2 source.3 : target)

Структура может помочь избежать ошибок. Unix Haters Handbook

	mkdir -p /tmp/http-root/{tm,dl} && { mount -R /tmp/flc/mike/Downloads/ /tmp/http-root/dl; mount -R /tmp/0x01 /tmp/http-root/tm; }

	fun hr = '/tmp/http-root/%s'.fmt; mkdir p (map(hr) tm dl) && mount R hr(dl).'/tmp/flc/mike/Downloads'  hr(tm)).'/tmp/0x01'

						   Fri Nov 23 18:11:03 YEKT 2012

Немного воспоминаний об указателях (это вопрос о том нужна ли унарная «.»).
Может и не нужна но опять возникает вопрос о переписывании какого-нибудь кода.
Эмс... Возьмём AVL, только куда я его засунул?

static unsigned avl_tree_add_internal(avl_iface(t) * tree, avl_iface(pivot_t) * pivot, avl_iface(pivot_t) ** pivot_ptr) {
	avl_iface(pivot_t) * p;
	avl_iface(pivot_t) * q;
	avl_iface(pivot_t) * r;
	avl_iface(pivot_t) * s;
	avl_iface(pivot_t) * t;
	unsigned ok, found, la, lna;
	unsigned rv;
	int a;
	int rcmp;
	avl_iface(key_t) * key = pivot->key;

	p = tree->root;
	r = q = s = NULL;

	*pivot_ptr = NULL;

	rv = code_avl_ok;

	if (p) {
		s = p;
		t = NULL;
		found = 0;
		while (!found) {
			rcmp = avl_iface(key_compare)(key, p->key);

			if (rcmp == 0) { // (key == p->value.key) {
				found = FOUND_MATCH;
			}
			else {
				if (rcmp < 0) { // (key < p->value.key) {
				 	q = p->links[LEFT];
				 	if (!q) {
						found = FOUND_LEFT;
					}
				}
				else {
					q = p->links[RIGHT];
					if (!q) {
						found = FOUND_RIGHT;
					}
				}
			}

			if (!found) {
				if (q->ballance) {
					t = p;
					s = q;
				}
				p = q;
			}
		}

Это начало. И можно записать так (без обобщённых типов).

fun addinternal(tree avltree.ptr; pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) =
(
	var (p; q; r; s; t) pivot ptr;
	var (ok; found; la; lna; rv) unsigned;
	var (a; rcmp) int;
	var key avlkey.ptr = .pivot.key;
)

Точка нужна префиксная, потому что это очень частый use-case. Если представить
себе ядро, то там указазатель на указателе. Так же нужен специальный синтаксис
для указания на указатель, чтобы сложные конструкции читались однозначно:

	array(20) hash(string) int ptr

	array(20) hash(string) (int ptr)

	(array(20) hash(string) int).ptr

	array(20) hash(string) int.ptr

Ладно, к вопросу о штуках.

fun addinternal(tree avltree ptr; pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) =
(
	var (p; q; r; s; t) avlpivot.ptr;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(val) = .pivot.key;

	.p = .tree.root;
	.p = .q = .s = NULL;
	pivotptr = NULL;
)

Вот тебе и косяк. Почему в var и не-var различная семантика? Тогда уж должно
быть так

fun addinternal(.tree avltree; .pivot avlpivot; ..pivotptr avlpivot)

Или тогда уж прямым текстом:

fun addinternal(ptr tree avltree; ptr pivot avlpivot; ptr pivotptr avlpivot ptr)
= (
	ptr (p; q; r; s; t) avlpivot;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	ptr key avlkey = ptr pivot.key;
)

fun addinternal(.tree avltree; .pivot avlpivot; .pivotptr avlpivot.ptr) uint =
(
	var (.p; .q; .r; .s; .t) avlpivot;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	val .key avlkey.val = .pivot.key;

	.p = .tree.root;
	.r = .q = .s = NULL;

	.pivotptr = NULL;

	rv = codeavlok;

	if(p)
	(
		.s = .p;
		.t = NULL;
		found = 0;

		for(!found)
		(
			rcmp = keycompare(key; .p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH
			)
			else
			(
				if(rcmp < 0)
				(
					.q = .p.links(LEFT);
		)
	)
)

Эх. В этом можно и запутаться за 5 секунд, что и произошло. Ок. И чего дальше?

fun addinternal(
	tree avltree.ptr;
	pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) uint rv =
(
	var (p; q; r; s; t) pivot.ptr;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(l) = pivot(l).key;

	val key avlkey.ptr(l) = pivot(1).key;

	p = tree(l).root;
	r = q = s = NULL;

	pivotptr(r) = NULL;

	if(p)
	(
		s = p;
		t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(key; p(l).key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				q = p(l).links(LEFT);
				if(!q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			q = p(0).links(RIGHT);
			q = p(l).links(RIGHT);
			if(!q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q(l).ballance)
			(
				t = p;
				s = q
			);
			p = q
		)
	)
)

У штуки может быть и другой смысл. Типа, указатель - это адрес, относительно
которого можно вычислять всякое. Почему бы не повычислять p(0)?

 	mm = get_task_mm(task);
	if (mm && mm != current->mm && !ptrace_may_access(task, mode)) {
			mmput(mm);
			mm = ERR_PTR(-EACCES);
	}
	mutex_unlock(&task->signal->cred_guard_mutex);

	mm = gettaskmm(task);
	if(mm && mm != current(0).mm && !ptracemayaccess(task; mode))
	(
		mmput(mm);
		mm = ERRPTR(-EACCES)
	);
	mutex.unlock(ref task(0).signal(0).credguardmutex);

	(ptr task(0).signal(0).credguardmutex).unlock();

Это могло бы и так выглядеть:

	(ptr task@.signal@.credGuardMutex).unlock();

	task:.signal:.credGuardMutex

Ладно. Ещё один вариант.

	(ptr task(0).signal(0).credGuardMutex).unlock();

Тут хитрые штуки, последняя проверка на сегодня.

	bool flush_delayed_work(struct delayed_work *dwork)
	{
		local_irq_disable();
		if (del_timer_sync(&dwork->timer))
			__queue_work(dwork->cpu,
					get_work_cwq(&dwork->work)->wq, &dwork->work);
		local_irq_enable();
		return flush_work(&dwork->work);
	}


	fun flushDelayedWork(dwork ptr delayedWork) bool =
	(
		localirq.disable();
		if(delTimerSync(ptr dwork(0).timer))
		(
			sys.queueWork(dwork(0).cpu; getworkcwq(ptr dwork(0).work)(0).wq; ptr dwork(0).work)
		);
		localirq.enable();
		return flushwork(ptr dwork(0).work);
	)

	fun flushdelayedwork(dwork ptr delayedwork) bool =
	(
		localirq.disable();
		if(deltimersync(ptr (dwork timer)))
		(
			sys.queuework(dwork cpu; getworkcwd(dwork work) wq; ptr (dwork work))
		);
		localirq.enable();
	)

Так. Нужно ещё проверить комбинации с точками.

if (mod->symtab[i].st_value <= addr
		&& mod->symtab[i].st_value > mod->symtab[best].st_value
		&& *(mod->strtab + mod->symtab[i].st_name) != '\0'
		&& !is_arm_mapping_symbol(mod->strtab + mod->symtab[i].st_name))
	best = i;

if(mod(0).symtab(i).stvalue <= addr
	&& mod(0).symtab[i].stvalue > mod(0).symtab[best].stvalue
	&& (mod(0).strtab + mod(0).symtab(i).stname)(0) != '\0'
	&& !isarmmappingsymbol(mod(0).strtab + mod->symtab[i].stname))
(
	best = i
)

if(val m mod.ref; val t (ptr symtab(i)).ref; pin =
	t.stvalue <= addr
	&& t.stvalue > m.symtab(best).stvalue
	&& (m.strtab + t.stname)(0) != '\0'
	&& !isarmmappingsymbol(m.strtab + t.stname))

if(val m mod.ref; pin
	 = m.symtab(i).stvalue <= addr
	&& m.symtab(i).stvalue > m.symtab(best).stvalue
	&& m.strtab(m.symtab(i).stname) != '\0'
	&& isARMMappingSymbol(m.strtab + m.symtab(i).stname))
(
	best = i
)

Какая-то не особо сахарная вата.

if(mod@.symtab(i).stvalue
	&& mod@.symtab(i).stvalue > mod@.symtab(best).stvalue
	&& (mod@.strtab + mod@.symtab(i).stname)@ = '\0'
	&& (mod@.strtab + mod@.symtab(i).stname).is(armmappingsymbol))


	x = --py@ + 1

	x = --py(0) + 1

	object@.firstMethodCall(a; @b; c)@.secondCall(1)@.nextCall(10);

	object.firstMethodCall(a; .b; c).secondCall(1).nextCall(10);

if(mod.symtab(i).stvalue
	&& mod.symtab(i).stvalue > mod.symtab(best).stvalue
	&& (.mod.strtab + mod.symtab(i).stname) = '\0'
	&& isARMMappingSymbol(.(.mod.strtab + mod.symtab(i).stname))

Ладно. Может, точка и не самый дурацкий вариант. Попробуем последить.


fun addinternal(
	tree avltree.ptr;
	pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) uint rv =
(
	var (p; q; r; s; t) pivot.ptr;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(l) = .pivot.key;

	.p = .tree.root;
	.r = .q = .s = NULL;

	pivotptr = NULL;

	if(.p)
	(
		.s = .p;
		.t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(.key; .p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				.q = .p.links(LEFT);
				if(!.q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			.q = .p.links(RIGHT);
			if(!.q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q.ballance)
			(
				.t = .p;
				.s = .q
			);
			.p = .q
		)
	)
)


Логика может быть такой, что всё является указателем. Это стиль JavaScript и это
не плохо. Плохо то... Или не плохо. Есть же концепция коробки. Будем называть её
клеткой, дабы было тематично

fun addinternal(tree avltree; pivot avlpivot; pivotptr cell(avlpivot)) uint rv =
(
	var (p; q; r; s; t) avlpivot;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey = pivot.key;

	p = tree.root;
	r = q = s = NULL;

	pivotptr.val = NULL;

	if(p)
	(
		s = p;
		t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(key; p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				q = p.links(LEFT);
				if(!q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			q = p.links(RIGHT);
			if(!q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q.ballance)
			(
				t = p;
				s = q
			);
			p = q
		)
	)
)

						   Tue Nov 27 14:11:54 YEKT 2012

Так. Коллеги дали добро на такую трактовку указателей. Да будет так

						   Thu Nov 29 11:32:44 YEKT 2012

Очередная проблема для обдумывания такого свойства. Во-первых, слишком сложный
формат токенов, если на пути lex -> sntx ещё терпимо, то когда они записаны в
sntx -> engine, почти не читаются. Во-вторых, результат синтаксического разбора
надо бы уметь записывать для последующего использования. Это может потребоваться
и для специализации, и для шаблонов. Это всё должно записываться примерно в
таком виде:

	x + y * z

	.atom	a1 = x
	.atom	a2 = y
	.atom	a3 = z
	.add	e1 = a1		// всегда известно, что бинарные операторы 
	.mul	e2 = a2		// задаются через левый вектор
	.join	e3 = e2 a3
	.join	e4 = e1 e3

Но чтобы можно было отлаживать (показывать тот исходный текст, где это было
написано) или чтобы выдавать сообщения об ошибках, здесь должна быть информация
о позиции в тексте.

Сам файл с текстом может быть объявлен в каких-нибудь заголовках модуля или в
специальных записях библиотеки или ещё как-то, это пока не важно. Здесь же
должны быть указания на позицию в коде. Видимо, в виде пары: l.c (да, я
испытываю странную тягу к точке, и тут может быть любой другой символ):

	.atom(1.0)	a1 = 1.1.x // подсказки о длине символа и его типе
	.atom(0.4)	a2 = 1.1.y

l.c - это +l к предыдущей строке и +с к текущей позиции в строке. Так получится
немного сэкономить.

Ок. Исходя из этого надо упростить лексемы 

	l.c N.1 1 =
	l.c E.1
	l.c N.2 37 8.11.hello world

Для операторов достаточно указать один номер, а приоритет уже потом восстановить
из таблицы. Дополнительно, для проверки корректности и читаемости можно указать
строковое представление символа.

Ещё один вопрос о двоичном кодировании этих всех структур. Видимо, длина каждого
кода должна быть 16 байтов из такого расчёта:

	2 байта	- основная инструкция
	2 байта	- уточнение типа (векторные форматы тоже надо учитывать)
	2 байта	- +l (бывают длинные комментарии)
	2 байта - +c (длинные лексемы)
	4 байта	- ссылка на первый операнд (могут быть длинные зависимости)
	4 байта	- ссылка на второй

Это всё очень длинно. На первое время сойдёт, но потом надо что-то вроде utf-8
будет применять.

Ок. Time to refine the spec

						    Tue Jan 1 21:00:03 YEKT 2013

Так. Нужна возможность писать примерно так:

	operator (a int + b int) int = core "add.4i t = a b; pin t"

Нужно определится, что такое a и b. По идее, в c-выражении это свободные
переменные и их надо к чему-то привязать. Как мы знаем, это интерпретация в виде
суммы произведений доменов (sum-of-products interpertation). То есть, как бы,
функция сопоставления (match) должна выбрать соответствующий синтаксический
домен, привязать переменные и оценить значения.

Ok, это может работать. Но возникает вопрос: как определить выражения для
переменных? Там же надо иметь какую-нибудь цепочку вроде:

	addr	p = a;
	rd.4i	v = p;
	cnst.4i	c = -1;
	add.4i	t = v c;
	pin	t

						   Wed Jan 23 22:50:13 YEKT 2013

Так. Есть определённая философская проблема. Что такое метка? Метка - это нечто,
что связывает два участка кода в одно целое. Это некая точка в геометрии кода
(есть у меня такое необоснованное ощущение). Ок. Допустим.

Ладно. 1. Хватает всего двух видов ветвлений: условное ветвление и ветвление с
link-ом. В принципе, это может быть одна операция, но с разным количеством
полей. Типа:

	br C : target : link;

И это достаточно сложно парсить. Ничто не мешает при этом, однако иметь
возможность составлять списки:

	label	lx = l.1;
	label	ly = l.2;
	join	labels = lx : ly;

						   Sun Jan 27 12:34:57 YEKT 2013

Ладно. Нужны списки - это определённо. Но надо что-то делать с метками. Путь,
который просматривается примерно такой:

	- метка в текущем выражении уникальна;

	- но сами выражения являются λ-выражениями, поэтому они могут
	  применяться одно к другому; это позволит вставлять в нужные места
	  новые подвыражения;

	- некоторые метки нужно запоминать для goto (или, возможно, для switch
	  case или возвратов из функций) и это надо делать явно.

Примерно так. Ещё имеет смысл всё же разделить элементы выражений на ядерные, и
обычные.

	k.pin
	k.mark
	k.link
	k.br
	k.brl

	и т.д. по мере надобности

Имеет смысл иметь два режима подстановки выражений в другие выражения:
постановка готового выражения или подстановка с компиляцией. Тогда поток
синтаксических конструкций для каких-нибудь for-ов или if-ов не записывать.
Синтаксис записывать всё-равно придётся для шаблонных функций или чего-нибудь
такого.

Но размышлять надо в сторону того, чтобы отказаться от такой записи. Но,
наверное, это невозможно.

						   Wed Feb 27 08:34:18 YEKT 2013

Итак. Оно, конечно, идеологически понятно, что хорошо бы иметь обобщённые
функции (или аналог). То есть, когда речь заходит о какой-нибудь арифметической
операции, то это некий ArtithOp, который выражается как:

	link	t = P.0;
	link	a = P.1;
	link	b = P.2;
	op.t	r = a : b;
	pin	r

Этот самый arithop вполне можно за-lookup-ить по какому-нибудь атому, а потом
применить.

Но для lookup-а по общей логике нужен специальный атом. Следовательно, можно всё
ещё существенней упростить.

						    Wed Mar 6 18:09:23 YEKT 2013

Так. Хьюстон, у нас проблема. Не понятен основной механизм основного цикла.
Понятно, что это должна быть некоторая рекурсия (что ж ещё?), но не понятно,
какая именно.

На вход мы получаем несколько видов выражений:

	A	atom
	B
	L	atom
	E b
	E l

Так. Ну. Хорошо. Чего look-up-им-то? По, идее. У нас есть текущее выражение на
вершине стека (условно, оно может быть просто текущим). И мы получаем нечто
вроде:

	LiME Current -> "L" -> atom -> 

Так. ПОхоже, можно сделать некий динамический вариант match. Примерно по
технологиям RiDE. Попробую уточнить.

						    Sat Mar 9 23:29:54 YEKT 2013

Так. Сколько у нас всего link-ов, чтобы заработали типы? И в какой они форме
должны быть? Хых. Похоже,

	link x = A.N

Это не самый удобный формат. Потому что смысл A становится понятным только после
чтения «.». Как-то это не правильно. Поэтому лучше всю типизацию link-узлов
вынести в suffix.

	link.suffix

Таким образом у нас выходит:

	link.AN	x = N
	link.TN x = N
	link.A	x = hint.size."bytes"
	link.T	x = exp;
	link.B	x = exp;
	link	x = y : z;
	link.N	x = N

	L.AN	x = N;
	L.TN	x = N;
	L.A	x = hint.size."bytes"
	L.T	x = exp
	L.B	x = exp;
	L	x = y : z;
	L.I

Так. Ещё нужны обязательно Pin, Symbol, Const. Ладно. Но ещё нужна и Soma. Можно
ли назвать Symbol Var-ом? Soma. Как-то глупо. Назовём это rule. Назовём это
глупо - soma.

						   Sun Mar 10 21:34:19 YEKT 2013

Ладно. Можно называть нормально - это всё похоже на форму, поэтому Form. Пока не
очень понятно, как представлять списки. Почитаем классику... Классика - это:

	cons
	head
	tail
	empty

Значит, надо:
	l.na	x = N;
	l.nt	x = N;
	l.la	x = hint.size."bytes";
	l.lt	x = exp;
	l	z = x : y;
	l.h	x = y;
	l.t	z = y;

Ещё нужно как-то обозначать пустой список. С которого надо начинать
конструирование. И как его обозначить? Пусть будет

	l	x;

Ладно. Сойдёт. Но есть ещё одна проблема. Как представлять списки внутри движка?
Кольцевой список подойдёт? Подойдёт, чего бы и нет? append тоже сработает.
Вместо NULL пишем то, что нужно, получается append.

						   Mon Mar 11 01:08:51 YEKT 2013

Нет. Это слишком уж громоздкий подход. При этом, refal существует. Посмотрим ещё
раз. Ок. Refal подойдёт. Только у него pattern-matching совсем уж странный. Но
нам пока до такого далеко.

						   Fri Mar 15 13:04:30 YEKT 2013

Так. Небольшая проблема всё-таки с логикой. Форма это что? Можно ли считать, что
это вызов функции в контексте? НууУу... В принципе, наверное. Только мы не тащим
контекст с собой, в качестве аргумента. А ещё... Ещё же нет возврата. То есть,
не происходит нечто вроде:

	fn F0(c Context; l1 Leg1; l2 Leg2; ...) = (
		F1 = (l1; l2; l3; ...); // ну, типа, зависят.
		F2 = (l1; l2; l3; ...);

		c.append(F1; F2);
		evaluate(c);
	)

явного evaluate у нас нету. По идее, вроде как. Эквивалент, скорее всего, был бы
такой:

	fn form(c Context; l Legs; f Continue) = (
		fn f1 (c Context; l Legs; f Continue) = ( ... );
		fn f2 (c Context; l Legs; f Continue) = ( ... );

		...

		c.append(legs1 = f1; legs2 = f2);
		eval(c; f)
	)

Примерно нечто такое. Ну, да. И что? А ничего. Можно просто сказать потом: вот
вам библиотека для Си. По-прежнему вопрос: не усложняем ли чрезмерно? Но тут всё
ещё остаётся программируемый match-ing. То есть, идея всё-равно в том, что вызов
функций идёт не напрямую, а через eval. Это может быть ценно.

						   Sun Mar 17 15:03:06 YEKT 2013

Похоже, Y-узел не особо нужен. Вопрос об узле, выбирающем вариант. В принципе,
возможно это сделать через несколько форм:

	A.l	T = 00.4."True";
	A.l	F = 00.5."False"ш;
	A.l	A = 10.0."";		// Атом для поиска типа
	T.l	A = 10.0.""

	F.b	fe = T : A;		// форма на случай того, что символ
					// найден
	...
	F.e

	F.b	fn = F : A;		// символ не найден

	L.s	x = someatom;		// поиск символа. Возвращает True или
					// False
	
	F.p	fn;
	F.p	fe;
	P	x : (A : someatom);

Примерно так.
