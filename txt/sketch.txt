Так. Проблема в следующем. Если написано

	ffmpeg -f v4l2 -i "/dev/video0"

То парсер не увидит то, что ffmpeg является атомом слева до тех пор, пока не
увидит -f, и не воспримет уже всю конструкцию, как

	(- ffmpeg (sp f v4l2))

И это, в общем-то определённый уровень задницы. Есть ещё вариант: не мудрить. И
ничего не делать с приоритетами. Однако, это исключит всякие разные радости:

	var R matrix float = (1 2 3 4 5; 6 7 8 9 10);

	var R matrix float =
		((1; 2; 3; 4; 5); (6; 7; 8; 9; 10))

Мда уж. Но, может, в самом деле keep it simple?

	ffmpeg f:v4l2 i:"/dev/video0"

	ffmpeg f:v4l2 i:'/dev/video0'
		vf:(scale(640;480) | colorspace(grayscale(8))) o:'file.avi';

	ffmpeg -f v4l2 -i '/dev/video0'
		-vf scale(640:480).colorspace(grayscale(8)) -o 'file.avi'

Мда. Векторы, как оказывается, продуманы плохо. И что? Борьба будет за двоеточие
с высоким приоритетом? Это не очень хорошо. И это ещё полбеды. Настоящая беда в
том, что не существует никакого левого поддерева. Потому что оно может быть
только в случае, когда у первого apply меньший приоритет. А его нельзя потопить.
Получается, только один вариант:

	ffmpeg f.v4l2 i.dev.video.0
		vf(scale(640;480) | colorspace grayscale.8) fs.dev.video.0

Ладно, когда оно всё вместе написано, то не так уж и плохо выглядит.

	ffmpeg f.v4l2 i.'/dev/video0'
		vf(scale(640;480) -> x; x -> colorspace grayscale(8)) o.'file.avi'

Ладно.

	swtich
	(
	x && y -> dosomething(1);
	x -> dosomething(x + 2);

	y ^^ z ->
	(
		var f = something.1();
		var x = something.2();
		var y = something.3();

		for(x != y)
		(
			x += 1;
		);

		pin = f
	);

	default -> dodefault()
	);

Альтернатива

	swtich (
	x && y -> dosomething(1);
	x -> dosomething(x + 2);

	y ^^ z -> (
		var f = something.1();
		var x = something.2();
		var y = something.3();

		for(x != y)
		(
			x += 1;
		);

		pin = f);

	default -> dodefault())

Ладно. Будем тогда в этой модели дальше думать.

								 К ВОПРОСУ О «:»

Вообще, переменные можно было бы вводить и при помощи двоеточки. Потому что
область видимости может быть привязана к области видимости оператора. Это не
страшно. Но вопрос в том... В чём? В том, что нужен какой-нибудь вменяемый
приоритет для этой двоеточки.

	x : list int = (20; 30; 40);

	for((x;y) := range2d(1:20; 30:40))
	(
		print '%d.%d\n'.fmt(x;y))
	)

Вполне возможно, что вменяемая позиция - это где-нибудь между «=» и прочими
операциями. И что дальше? А ничего...

Крупица полезного смысла здесь в том, что операторы сами могут быть привязаны к
области видимости. Ну ладно...

	x: list int = (20; 30; 40);

	for((y; z) := range(1:20; 30:40))
	(
		print "%d.%d\n".fmt(x + y; z);
	)

И чего с этим делать? А пусть будет так:

	(x > 10 && Ex y Nat : x * y == 20) -> x == 2;

	x Nat : (Ex y Nat : x = y * 2) -> Ex z Nat : x = z << 1;

Сойдёт. Значит, система приоритетов получается примерно такая (^^ - это то же
самое, что и !=):

	0: ;
	1: = *= /= %= >>= <<= &= += -= |= ^= ||= &&=
	2: ->
	3: ||
	4: &&
	5: == != < <= > >=
	6: + - | ^
	7: * / % << >> &
	9: .

Было бы неплохо, видимо, иметь приоритет двоеточия где-то чуть выше стрелки.
Замечательно. Тогда можно писать

	fun max(a Num; b Num) = a > b -> a : b;

Ну и всё. Это однозначно говорит о том, что приоритет выше «=». Ладно, ок. А
Haskell стиль?

	fun max(a Num) = (fun(b Num) Num = a > b -> a : b)

	var x = max(2)(3);

	fun max(a num; b num) num = a > b -> a : b;
	stdin.bytes.filter(x byte) max(12345, int = x);


						   Mon Nov 19 13:40:29 YEKT 2012

Ок. Примеры из истории надо рассмотреть. Потому что сейчас очередной когнитивный
диссонанс пришёл, который вызван тремя возможными способами управлять
приоритетами:

	1. Очень просто. Однонаправленные связи, фиксированный приоритет.
		s-apply с высоким приоритетом.

	2. Обратная связь от движка, который говорит: а подними-ка ты временно
		вот эти приоритеты в правом поддереве. Правое поддерево хорошо
		определяется, как и левое в стандартном парсере.

	3. Сделать низкоприоритетный s-apply.


Посмотрим на примеры из истории.

	DISPLAY=:0.0 evince mcp.pdf &>/dev/null </dev/null &

	DISPLAY=0.0 evince 'mcp.pdf' (all)>dev.null <dev.null

Да. Это возможно, если уметь сказать, что неким магическим образом приоритет
пробела упал. Ок. Если этого сказать нельзя, как это может быть выражено?

	(DISPLAY=0.0; (1:2)=dev.null; evince) 'mcp.pdf'

Мечта идиота (моя), склонного к LISP? Ладно. Допустим. Что дальше? Что-нибудь
такое:

	(HOME=/tmp/flc/mike/ nice -n 20 linuxdcpp) &

	(HOME=tmp.flc.mike; n=20; nice) linuxdcpp

Ок. А что насчёт эпического?

	screen -S mp mplayer ~/Downloads/87* -vf crop=280:210,scale=320:240 -ao null -osdlevel 0 -display :32.1 -fixed-vo -loop 0

	screen S.mp mplayer vf(crop(280:210):scale(320:240)) ao.null osdlevel.0 display.32.1 vo.fixed loop.0 '~/Downloads.87*'

Ладно. Допустим. Хотя не очень красиво.

	{ [ -f /tmp/agent ] || ssh-agent > /tmp/agent; } && . /tmp/agent && ssh-add ~/.ssh/0xfb.mb

	var a='/tmp/agent'; (test f.(a) || ssh.agent 1.(a)) && (ENV += a) && ssh.add '~/.ssh/0xfb.mb'

	a=/tmp/agent; { [ -f "$a" ] || ssh-agent > "$a"; } && . "$a" && ssh-add ~/.ssh/0xfb.mb

Ну. Определённый уровень корявости есть.

	DISPLAY=:0.0 evince mcp.pdf &>/dev/null </dev/null &

	(DISPLAY=0.0; (1:2)=dev.null; evince) 'mcp.pdf'

	(DISPLAY=0.0; evince (1;2).w('/dev/null')) 'mcp.pdf'

Ладно. А так?

	a = '/tmp/agent'; (test f.(a) || (1=(a); ssh.agent) && (ENV += a) && ssh.add '~/.ssh/0xfb.mb'

Ещё

	mkdir /tmp/0x01 -p && sshfs mike@0x01.imm.uran.ru:/tmp/flc /tmp/0x01

	mkdir p '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/fls' '/tmp/0x01'

	mkdir p '/tmp/0x01' &&  sshfs 0x01.imm.uran.ru(mike).tmp.flc '/tmp/0x01'

	'/tmp/0x01' mkdir.p && 0x01.imm.uran.ru(mike).'/tmp/fls' '/tmp/0x01' sshfs

MoarrrrR

	gcc payload.c -fPIC -o pl.so -static-libgcc -shared -Wl,-static -lc -Wl,--strip-all -Wl,--gc-sections

	gcc f.pic shared Wl(static stripall sections) lc lstatic.libgcc o.'pl.so' 'payload.c'

---

	su -c 'cat /root/sys.d/nv-sync'

	su c.(cat '/root/sys.d/nv-sync') // уже распарсено

---
	#!/bin/dash

	set -e

	alias ctl='/usr/bin/systemctl'
	alias stat='/usr/bin/stat'
	alias su='/bin/su'
	alias chmod='/usr/bin/chmod'
	alias chown='/usr/bin/chown'
	alias mktemp='/usr/bin/mktemp'
	alias touch='/usr/bin/touch'
	alias mv='/usr/bin/mv'

	sync() {
		local backup target usr lock temp

		backup="$1"
		target="$2"
		user=$(stat -c %U "$backup")
		lock="$target/.nv-sync.lock"

		echo "$backup($user:$mode) -> $target"

		if [ -d "$target" ]
		then
			{ flock -xn 7 \
				&& su -c "/usr/bin/rsync -a --del --exclude .nv-sync.lock '$target/' '$backup/'" $user \
				|| { echo "will not sync. can't obtain lock: $lock"; exit 2; }; } 7<"$lock"

			return
		fi

		echo "no target: $target"
		if [ "$3" != 'up' ]
		then
			echo "no special parameter. not going up"
			exit 3
		fi

		temp=$(su -c "/usr/bin/mktemp -d '$target-XXXX'" $user)
		chmod --reference="$backup" "$temp"
		echo "going up: $temp"

		su -c "/usr/bin/rsync -a '$backup/' '$temp/'" $user
		touch "$temp/.nv-sync.lock"
		mv -n "$temp" "$target"
	}

	case "$1" in
	up)
		sync "/nvram/mb" "/home/mb" up
		;;

	down)
		sync "/nvram/mb" "/home/mb"
		;;

	sync)
		if ctl is-active nv-sync
		then
			sync "/nvram/mb" "/home/mb"
		else
			echo "not active"
			exit 1
		fi
		;;

	*)
		echo "unknown task"
		exit 4
	esac


LiME:
	exp mames = (ctl; stat; chmod; chown; mktem; touch; mv; rsync);
	val names = usr.bin.names;
	val su = bin.su;
	cmd sync (backup string) (target string) (up bool = 0) =
	(
		val user = (stat c.'%U' backup).out(0);
		val lock = target + '/.nv-sync.lock';

		echo '%s(%s:%s) -> %s'.fmt(backup; user; ''; target);

		if(test d.target)
		(
			run(7 = lock
				&& (flock xn.7 || (echo 'won\'t sync. can\'t obtain lock: ' lock; exit 2))
				&& su user c.(rsync a del exclude('.nv-sync.lock') target backup));

			return
		);

		echo 'no target: ' target;

		if(!up)
		(
			echo 'no special parameter. not going up';
			exit 3
		);

		val temp = (su user c.(mktemp d.(target + '-XXXX'))).out(0);
		chmod reference.backup temp;
		echo 'going up: ' temp;

		su user c.(rsync a target backup);
		touch '%s/.nv-sync.lock'.fmt(temp);
		mv n temp target
	)

	val sync.cmd = sync '/nvram/mb' '/home/mb';

	switch(CMD.1)
	(
		'up'	-> sync.cmd 1;
		'down'	-> sync.cmd;
		'sync'	-> if(ctl isactive 'nv-sync') sync.cmd or (echo 'not active'; exit 1);
		default -> (echo 'unknown task'; exit 4)
	)

Так. Вопрос ещё есть, возможно так:

	mkdir p "/tmp/0x01" && sshfs "mike@0x01.imm.uran.ru:/tmp/flc" "/tmp/0x01"

	mkdir p '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' '/tmp/0x01'

	var mp = '/tmp/0x01'; mkdir p mp && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' mp

	mkdir(p) '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' '/tmp/0x01'

	tar xv f.'some.tar.gz'

	(0='some.tar.gz'; gzip cd) | tar mx;

	gzip -cd some.tar.gz | tar mx;

	gzip 'some.tar.gz' cd | tar mx;

Эх. Идеала не существует

	val temp = (su (user) c.(mktemp d.(target + '-XXXX'))).out(0);
	chmod reference.(backup) temp;
	echo 'going up: ' (temp);

	su user c.(rsync a (target:backup));
	touch '%s/.nv-sync.lock'.fmt(temp);
	mv n (target:backup)

	mv(target:backup) n;
	run(rsync(target:backup) a) u.(user)

	git.filter branch fcmd.(rm rf 'src/password')

	tar c './' | (out='some.tar.gz'; gzip)

В этом, может быть, что-нибудь да есть. Потому что

	mv n (source.1 source.2 source.3 : target)

Структура может помочь избежать ошибок. Unix Haters Handbook

	mkdir -p /tmp/http-root/{tm,dl} && { mount -R /tmp/flc/mike/Downloads/ /tmp/http-root/dl; mount -R /tmp/0x01 /tmp/http-root/tm; }

	fun hr = '/tmp/http-root/%s'.fmt; mkdir p (map(hr) tm dl) && mount R hr(dl).'/tmp/flc/mike/Downloads'  hr(tm)).'/tmp/0x01'

						   Fri Nov 23 18:11:03 YEKT 2012

Немного воспоминаний об указателях (это вопрос о том нужна ли унарная «.»).
Может и не нужна но опять возникает вопрос о переписывании какого-нибудь кода.
Эмс... Возьмём AVL, только куда я его засунул?

static unsigned avl_tree_add_internal(avl_iface(t) * tree, avl_iface(pivot_t) * pivot, avl_iface(pivot_t) ** pivot_ptr) {
	avl_iface(pivot_t) * p;
	avl_iface(pivot_t) * q;
	avl_iface(pivot_t) * r;
	avl_iface(pivot_t) * s;
	avl_iface(pivot_t) * t;
	unsigned ok, found, la, lna;
	unsigned rv;
	int a;
	int rcmp;
	avl_iface(key_t) * key = pivot->key;

	p = tree->root;
	r = q = s = NULL;

	*pivot_ptr = NULL;

	rv = code_avl_ok;

	if (p) {
		s = p;
		t = NULL;
		found = 0;
		while (!found) {
			rcmp = avl_iface(key_compare)(key, p->key);

			if (rcmp == 0) { // (key == p->value.key) {
				found = FOUND_MATCH;
			}
			else {
				if (rcmp < 0) { // (key < p->value.key) {
				 	q = p->links[LEFT];
				 	if (!q) {
						found = FOUND_LEFT;
					}
				}
				else {
					q = p->links[RIGHT];
					if (!q) {
						found = FOUND_RIGHT;
					}
				}
			}

			if (!found) {
				if (q->ballance) {
					t = p;
					s = q;
				}
				p = q;
			}
		}

Это начало. И можно записать так (без обобщённых типов).

fun addinternal(tree avltree.ptr; pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) =
(
	var (p; q; r; s; t) pivot ptr;
	var (ok; found; la; lna; rv) unsigned;
	var (a; rcmp) int;
	var key avlkey.ptr = .pivot.key;
)

Точка нужна префиксная, потому что это очень частый use-case. Если представить
себе ядро, то там указазатель на указателе. Так же нужен специальный синтаксис
для указания на указатель, чтобы сложные конструкции читались однозначно:

	array(20) hash(string) int ptr

	array(20) hash(string) (int ptr)

	(array(20) hash(string) int).ptr

	array(20) hash(string) int.ptr

Ладно, к вопросу о штуках.

fun addinternal(tree avltree ptr; pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) =
(
	var (p; q; r; s; t) avlpivot.ptr;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(val) = .pivot.key;

	.p = .tree.root;
	.p = .q = .s = NULL;
	pivotptr = NULL;
)

Вот тебе и косяк. Почему в var и не-var различная семантика? Тогда уж должно
быть так

fun addinternal(.tree avltree; .pivot avlpivot; ..pivotptr avlpivot)

Или тогда уж прямым текстом:

fun addinternal(ptr tree avltree; ptr pivot avlpivot; ptr pivotptr avlpivot ptr)
= (
	ptr (p; q; r; s; t) avlpivot;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	ptr key avlkey = ptr pivot.key;
)

fun addinternal(.tree avltree; .pivot avlpivot; .pivotptr avlpivot.ptr) uint =
(
	var (.p; .q; .r; .s; .t) avlpivot;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	val .key avlkey.val = .pivot.key;

	.p = .tree.root;
	.r = .q = .s = NULL;

	.pivotptr = NULL;

	rv = codeavlok;

	if(p)
	(
		.s = .p;
		.t = NULL;
		found = 0;

		for(!found)
		(
			rcmp = keycompare(key; .p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH
			)
			else
			(
				if(rcmp < 0)
				(
					.q = .p.links(LEFT);
		)
	)
)

Эх. В этом можно и запутаться за 5 секунд, что и произошло. Ок. И чего дальше?

fun addinternal(
	tree avltree.ptr;
	pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) uint rv =
(
	var (p; q; r; s; t) pivot.ptr;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(l) = pivot(l).key;

	val key avlkey.ptr(l) = pivot(1).key;

	p = tree(l).root;
	r = q = s = NULL;

	pivotptr(r) = NULL;

	if(p)
	(
		s = p;
		t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(key; p(l).key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				q = p(l).links(LEFT);
				if(!q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			q = p(0).links(RIGHT);
			q = p(l).links(RIGHT);
			if(!q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q(l).ballance)
			(
				t = p;
				s = q
			);
			p = q
		)
	)
)

У штуки может быть и другой смысл. Типа, указатель - это адрес, относительно
которого можно вычислять всякое. Почему бы не повычислять p(0)?

 	mm = get_task_mm(task);
	if (mm && mm != current->mm && !ptrace_may_access(task, mode)) {
			mmput(mm);
			mm = ERR_PTR(-EACCES);
	}
	mutex_unlock(&task->signal->cred_guard_mutex);

	mm = gettaskmm(task);
	if(mm && mm != current(0).mm && !ptracemayaccess(task; mode))
	(
		mmput(mm);
		mm = ERRPTR(-EACCES)
	);
	mutex.unlock(ref task(0).signal(0).credguardmutex);

	(ptr task(0).signal(0).credguardmutex).unlock();

Это могло бы и так выглядеть:

	(ptr task@.signal@.credGuardMutex).unlock();

	task:.signal:.credGuardMutex

Ладно. Ещё один вариант.

	(ptr task(0).signal(0).credGuardMutex).unlock();

Тут хитрые штуки, последняя проверка на сегодня.

	bool flush_delayed_work(struct delayed_work *dwork)
	{
		local_irq_disable();
		if (del_timer_sync(&dwork->timer))
			__queue_work(dwork->cpu,
					get_work_cwq(&dwork->work)->wq, &dwork->work);
		local_irq_enable();
		return flush_work(&dwork->work);
	}


	fun flushDelayedWork(dwork ptr delayedWork) bool =
	(
		localirq.disable();
		if(delTimerSync(ptr dwork(0).timer))
		(
			sys.queueWork(dwork(0).cpu; getworkcwq(ptr dwork(0).work)(0).wq; ptr dwork(0).work)
		);
		localirq.enable();
		return flushwork(ptr dwork(0).work);
	)

	fun flushdelayedwork(dwork ptr delayedwork) bool =
	(
		localirq.disable();
		if(deltimersync(ptr (dwork timer)))
		(
			sys.queuework(dwork cpu; getworkcwd(dwork work) wq; ptr (dwork work))
		);
		localirq.enable();
	)

Так. Нужно ещё проверить комбинации с точками.

if (mod->symtab[i].st_value <= addr
		&& mod->symtab[i].st_value > mod->symtab[best].st_value
		&& *(mod->strtab + mod->symtab[i].st_name) != '\0'
		&& !is_arm_mapping_symbol(mod->strtab + mod->symtab[i].st_name))
	best = i;

if(mod(0).symtab(i).stvalue <= addr
	&& mod(0).symtab[i].stvalue > mod(0).symtab[best].stvalue
	&& (mod(0).strtab + mod(0).symtab(i).stname)(0) != '\0'
	&& !isarmmappingsymbol(mod(0).strtab + mod->symtab[i].stname))
(
	best = i
)

if(val m mod.ref; val t (ptr symtab(i)).ref; pin =
	t.stvalue <= addr
	&& t.stvalue > m.symtab(best).stvalue
	&& (m.strtab + t.stname)(0) != '\0'
	&& !isarmmappingsymbol(m.strtab + t.stname))

if(val m mod.ref; pin
	 = m.symtab(i).stvalue <= addr
	&& m.symtab(i).stvalue > m.symtab(best).stvalue
	&& m.strtab(m.symtab(i).stname) != '\0'
	&& isARMMappingSymbol(m.strtab + m.symtab(i).stname))
(
	best = i
)

Какая-то не особо сахарная вата.

if(mod@.symtab(i).stvalue
	&& mod@.symtab(i).stvalue > mod@.symtab(best).stvalue
	&& (mod@.strtab + mod@.symtab(i).stname)@ = '\0'
	&& (mod@.strtab + mod@.symtab(i).stname).is(armmappingsymbol))


	x = --py@ + 1

	x = --py(0) + 1

	object@.firstMethodCall(a; @b; c)@.secondCall(1)@.nextCall(10);

	object.firstMethodCall(a; .b; c).secondCall(1).nextCall(10);

if(mod.symtab(i).stvalue
	&& mod.symtab(i).stvalue > mod.symtab(best).stvalue
	&& (.mod.strtab + mod.symtab(i).stname) = '\0'
	&& isARMMappingSymbol(.(.mod.strtab + mod.symtab(i).stname))

Ладно. Может, точка и не самый дурацкий вариант. Попробуем последить.


fun addinternal(
	tree avltree.ptr;
	pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) uint rv =
(
	var (p; q; r; s; t) pivot.ptr;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(l) = .pivot.key;

	.p = .tree.root;
	.r = .q = .s = NULL;

	pivotptr = NULL;

	if(.p)
	(
		.s = .p;
		.t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(.key; .p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				.q = .p.links(LEFT);
				if(!.q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			.q = .p.links(RIGHT);
			if(!.q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q.ballance)
			(
				.t = .p;
				.s = .q
			);
			.p = .q
		)
	)
)


Логика может быть такой, что всё является указателем. Это стиль JavaScript и это
не плохо. Плохо то... Или не плохо. Есть же концепция коробки. Будем называть её
клеткой, дабы было тематично

fun addinternal(tree avltree; pivot avlpivot; pivotptr cell(avlpivot)) uint rv =
(
	var (p; q; r; s; t) avlpivot;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey = pivot.key;

	p = tree.root;
	r = q = s = NULL;

	pivotptr.val = NULL;

	if(p)
	(
		s = p;
		t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(key; p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				q = p.links(LEFT);
				if(!q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			q = p.links(RIGHT);
			if(!q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q.ballance)
			(
				t = p;
				s = q
			);
			p = q
		)
	)
)

						   Tue Nov 27 14:11:54 YEKT 2012

Так. Коллеги дали добро на такую трактовку указателей. Да будет так

						   Thu Nov 29 11:32:44 YEKT 2012

Очередная проблема для обдумывания такого свойства. Во-первых, слишком сложный
формат токенов, если на пути lex -> sntx ещё терпимо, то когда они записаны в
sntx -> engine, почти не читаются. Во-вторых, результат синтаксического разбора
надо бы уметь записывать для последующего использования. Это может потребоваться
и для специализации, и для шаблонов. Это всё должно записываться примерно в
таком виде:

	x + y * z

	.atom	a1 = x
	.atom	a2 = y
	.atom	a3 = z
	.add	e1 = a1		// всегда известно, что бинарные операторы 
	.mul	e2 = a2		// задаются через левый вектор
	.join	e3 = e2 a3
	.join	e4 = e1 e3

Но чтобы можно было отлаживать (показывать тот исходный текст, где это было
написано) или чтобы выдавать сообщения об ошибках, здесь должна быть информация
о позиции в тексте.

Сам файл с текстом может быть объявлен в каких-нибудь заголовках модуля или в
специальных записях библиотеки или ещё как-то, это пока не важно. Здесь же
должны быть указания на позицию в коде. Видимо, в виде пары: l.c (да, я
испытываю странную тягу к точке, и тут может быть любой другой символ):

	.atom(1.0)	a1 = 1.1.x // подсказки о длине символа и его типе
	.atom(0.4)	a2 = 1.1.y

l.c - это +l к предыдущей строке и +с к текущей позиции в строке. Так получится
немного сэкономить.

Ок. Исходя из этого надо упростить лексемы 

	l.c N.1 1 =
	l.c E.1
	l.c N.2 37 8.11.hello world

Для операторов достаточно указать один номер, а приоритет уже потом восстановить
из таблицы. Дополнительно, для проверки корректности и читаемости можно указать
строковое представление символа.

Ещё один вопрос о двоичном кодировании этих всех структур. Видимо, длина каждого
кода должна быть 16 байтов из такого расчёта:

	2 байта	- основная инструкция
	2 байта	- уточнение типа (векторные форматы тоже надо учитывать)
	2 байта	- +l (бывают длинные комментарии)
	2 байта - +c (длинные лексемы)
	4 байта	- ссылка на первый операнд (могут быть длинные зависимости)
	4 байта	- ссылка на второй

Это всё очень длинно. На первое время сойдёт, но потом надо что-то вроде utf-8
будет применять.

Ок. Time to refine the spec

						    Tue Jan 1 21:00:03 YEKT 2013

Так. Нужна возможность писать примерно так:

	operator (a int + b int) int = core "add.4i t = a b; pin t"

Нужно определится, что такое a и b. По идее, в c-выражении это свободные
переменные и их надо к чему-то привязать. Как мы знаем, это интерпретация в виде
суммы произведений доменов (sum-of-products interpertation). То есть, как бы,
функция сопоставления (match) должна выбрать соответствующий синтаксический
домен, привязать переменные и оценить значения.

Ok, это может работать. Но возникает вопрос: как определить выражения для
переменных? Там же надо иметь какую-нибудь цепочку вроде:

	addr	p = a;
	rd.4i	v = p;
	cnst.4i	c = -1;
	add.4i	t = v c;
	pin	t

						   Wed Jan 23 22:50:13 YEKT 2013

Так. Есть определённая философская проблема. Что такое метка? Метка - это нечто,
что связывает два участка кода в одно целое. Это некая точка в геометрии кода
(есть у меня такое необоснованное ощущение). Ок. Допустим.

Ладно. 1. Хватает всего двух видов ветвлений: условное ветвление и ветвление с
link-ом. В принципе, это может быть одна операция, но с разным количеством
полей. Типа:

	br C : target : link;

И это достаточно сложно парсить. Ничто не мешает при этом, однако иметь
возможность составлять списки:

	label	lx = l.1;
	label	ly = l.2;
	join	labels = lx : ly;

						   Sun Jan 27 12:34:57 YEKT 2013

Ладно. Нужны списки - это определённо. Но надо что-то делать с метками. Путь,
который просматривается примерно такой:

	- метка в текущем выражении уникальна;

	- но сами выражения являются λ-выражениями, поэтому они могут
	  применяться одно к другому; это позволит вставлять в нужные места
	  новые подвыражения;

	- некоторые метки нужно запоминать для goto (или, возможно, для switch
	  case или возвратов из функций) и это надо делать явно.

Примерно так. Ещё имеет смысл всё же разделить элементы выражений на ядерные, и
обычные.

	k.pin
	k.mark
	k.link
	k.br
	k.brl

	и т.д. по мере надобности

Имеет смысл иметь два режима подстановки выражений в другие выражения:
постановка готового выражения или подстановка с компиляцией. Тогда поток
синтаксических конструкций для каких-нибудь for-ов или if-ов не записывать.
Синтаксис записывать всё-равно придётся для шаблонных функций или чего-нибудь
такого.

Но размышлять надо в сторону того, чтобы отказаться от такой записи. Но,
наверное, это невозможно.

						   Wed Feb 27 08:34:18 YEKT 2013

Итак. Оно, конечно, идеологически понятно, что хорошо бы иметь обобщённые
функции (или аналог). То есть, когда речь заходит о какой-нибудь арифметической
операции, то это некий ArtithOp, который выражается как:

	link	t = P.0;
	link	a = P.1;
	link	b = P.2;
	op.t	r = a : b;
	pin	r

Этот самый arithop вполне можно за-lookup-ить по какому-нибудь атому, а потом
применить.

Но для lookup-а по общей логике нужен специальный атом. Следовательно, можно всё
ещё существенней упростить.

						    Wed Mar 6 18:09:23 YEKT 2013

Так. Хьюстон, у нас проблема. Не понятен основной механизм основного цикла.
Понятно, что это должна быть некоторая рекурсия (что ж ещё?), но не понятно,
какая именно.

На вход мы получаем несколько видов выражений:

	A	atom
	B
	L	atom
	E b
	E l

Так. Ну. Хорошо. Чего look-up-им-то? По, идее. У нас есть текущее выражение на
вершине стека (условно, оно может быть просто текущим). И мы получаем нечто
вроде:

	LiME Current -> "L" -> atom -> 

Так. ПОхоже, можно сделать некий динамический вариант match. Примерно по
технологиям RiDE. Попробую уточнить.

						    Sat Mar 9 23:29:54 YEKT 2013

Так. Сколько у нас всего link-ов, чтобы заработали типы? И в какой они форме
должны быть? Хых. Похоже,

	link x = A.N

Это не самый удобный формат. Потому что смысл A становится понятным только после
чтения «.». Как-то это не правильно. Поэтому лучше всю типизацию link-узлов
вынести в suffix.

	link.suffix

Таким образом у нас выходит:

	link.AN	x = N
	link.TN x = N
	link.A	x = hint.size."bytes"
	link.T	x = exp;
	link.B	x = exp;
	link	x = y : z;
	link.N	x = N

	L.AN	x = N;
	L.TN	x = N;
	L.A	x = hint.size."bytes"
	L.T	x = exp
	L.B	x = exp;
	L	x = y : z;
	L.I

Так. Ещё нужны обязательно Pin, Symbol, Const. Ладно. Но ещё нужна и Soma. Можно
ли назвать Symbol Var-ом? Soma. Как-то глупо. Назовём это rule. Назовём это
глупо - soma.

						   Sun Mar 10 21:34:19 YEKT 2013

Ладно. Можно называть нормально - это всё похоже на форму, поэтому Form. Пока не
очень понятно, как представлять списки. Почитаем классику... Классика - это:

	cons
	head
	tail
	empty

Значит, надо:
	l.na	x = N;
	l.nt	x = N;
	l.la	x = hint.size."bytes";
	l.lt	x = exp;
	l	z = x : y;
	l.h	x = y;
	l.t	z = y;

Ещё нужно как-то обозначать пустой список. С которого надо начинать
конструирование. И как его обозначить? Пусть будет

	l	x;

Ладно. Сойдёт. Но есть ещё одна проблема. Как представлять списки внутри движка?
Кольцевой список подойдёт? Подойдёт, чего бы и нет? append тоже сработает.
Вместо NULL пишем то, что нужно, получается append.

						   Mon Mar 11 01:08:51 YEKT 2013

Нет. Это слишком уж громоздкий подход. При этом, refal существует. Посмотрим ещё
раз. Ок. Refal подойдёт. Только у него pattern-matching совсем уж странный. Но
нам пока до такого далеко.

						   Fri Mar 15 13:04:30 YEKT 2013

Так. Небольшая проблема всё-таки с логикой. Форма это что? Можно ли считать, что
это вызов функции в контексте? НууУу... В принципе, наверное. Только мы не тащим
контекст с собой, в качестве аргумента. А ещё... Ещё же нет возврата. То есть,
не происходит нечто вроде:

	fn F0(c Context; l1 Leg1; l2 Leg2; ...) = (
		F1 = (l1; l2; l3; ...); // ну, типа, зависят.
		F2 = (l1; l2; l3; ...);

		c.append(F1; F2);
		evaluate(c);
	)

явного evaluate у нас нету. По идее, вроде как. Эквивалент, скорее всего, был бы
такой:

	fn form(c Context; l Legs; f Continue) = (
		fn f1 (c Context; l Legs; f Continue) = ( ... );
		fn f2 (c Context; l Legs; f Continue) = ( ... );

		...

		c.append(legs1 = f1; legs2 = f2);
		eval(c; f)
	)

Примерно нечто такое. Ну, да. И что? А ничего. Можно просто сказать потом: вот
вам библиотека для Си. По-прежнему вопрос: не усложняем ли чрезмерно? Но тут всё
ещё остаётся программируемый match-ing. То есть, идея всё-равно в том, что вызов
функций идёт не напрямую, а через eval. Это может быть ценно.

						   Sun Mar 17 15:03:06 YEKT 2013

Похоже, Y-узел не особо нужен. Вопрос об узле, выбирающем вариант. В принципе,
возможно это сделать через несколько форм:

	A.l	T = 00.4."True";
	A.l	F = 00.5."False"ш;
	A.l	A = 10.0."";		// Атом для поиска типа
	T.l	A = 10.0.""

	F.b	fe = T : A;		// форма на случай того, что символ
					// найден
	...
	F.e

	F.b	fn = F : A;		// символ не найден

	L.s	x = someatom;		// поиск символа. Возвращает True или
					// False
	
	F.p	fn;
	F.p	fe;
	P	x : (A : someatom);

Примерно так.

Скорее всего, Y-ки всегда будут использоваться в первой форме, которая
подставляется по синтаксису. Но это можно делать и не явно, и не пудрить мозг
пользователю. Ведь, фактически, разветвление на формы нужно, когда возникает
неопределённость в дальнейшем выводе. Пока неопределённости нет, можно обходится
и одной формой. А то, что надо читать Y - вполне определено. Не определено то, в
каком окружении это надо читать. А это окружение вполне может определённо
построить первая синтаксическая форма.

Алгоритм может быть такой:

	- встретили синтаксис X ..., значит надо найти форму и применить
	  её (X - это A, B, L, U);

	- встретили синтаксис E X ..., значит надо найти форму,
	  применить, а потом сливать с предыдущим контекстом вывода (X -
	  это l, u, b) и выводить цель.

Должно сработать.

						   Thu Mar 21 12:32:05 YEKT 2013

Ладно. Новый вариант выражений будет выглядеть примерно так:

	F f = (
		// Первый элемент в списке - список из входов
		((A.l 00.1."V"; T (A.l 00.10."Expression")));

		// F.i - это список, и это первый элемент в L.n
		L.n a = (F.i; 1; 1);
		L.n t = (F.i; 0; 1);

		F.o (A.l 00.1."V"; (a; t))
	);


						   Fri Mar 22 18:01:22 YEKT 2013

Ладно, теперь есть вопрос о том, что такое списки. Списки у нас - это нечто из
узлов, на самом деле. Когда мы грузим линейный участок, то это DAG из структур
вида:

	typedef struct ListStruct {
		union {
			unsigned atom;
			unsigned number;
//			unsigned special;
			struct ListStruct * list;
			struct {
				unsigned name;
				unsigned suffix;
				struct ListStruct * references;
			} node;
		} u;
		unsigned code;
		unsigned atline;
		struct ListStruct * next;
	} List;

Некоторые узлы могут быть числами, специальными узлами (например, T, при разборе
L.n) или атомами.

Хотя, вроде, нет. special не нужен. Потому что это просто атом, обрабатываемый
особо. Значит, остаётся только atom или number. По идее, это одно и то же, но
для выразительности пока оставим.

Ок. Вроде, ок.

Ещё нужно поле list, потому что в списке могут быть подсписки. Всё такое.

						   Sat Mar 23 10:54:59 YEKT 2013

Ошибка вот в чём. Списки - это отдельно, узлы - это отдельно. Списки должны
состоять из (это или, в каждом узле нечто одно из):

	- атомов;
	- типов;
	- чисел;
	- ссылок на узлы;
	- подсписков.

Атомы и типы должны быть даны своими номерами. Узлы должны иметь вид:

	- код;
	- суффикс;
	- список ссылок;
	- счётчик ссылок.

Загрузка должна проходить в две стадии (скорее всего, возможно их можно
объединить, но пока мы не оптимизируем).

1.	Обход записи списка в глубину с упорядочиванием таким образом узлов. При
	этом, атомы и типы имеет смысл обработать на общих основаниях и сделать
	из них узлы.

2.	Подстройка списка, чтобы вместо различных lookup операций по таблицам
	стояли определённые конкретные номера элементов. Нам критично это прежде
	всего для атомов и типов, потому что мы по этим объектам будем
	производить всякие разные поиски. Поэтому они должны быть в «нормальной»
	форме, в которой это всё сводится к списку из номеров атомов и номеров
	типов.

Ок. Переигрываем. Менее эффективное, но более удобное в конструировании решение.

Элемент списка - это одно из:

	- ссылка на узел;
	- ссылка на подсписок (начто в скобках);

Узел - это

	- код;
	- суффикс;
	- одно из:
		- номер (это может быть номер атома, типа, или просто число;
		  определяется кодом и суффиксом);
		- список источников (ссылок на другие узлы; список
		  структурированный);
	- число ссылок на данный узел (для сборки мусора после некоторых
	  трансформаций).

Будем в угоду однообразности поступать так. Сами узлы не будут содержать ссылок
друг на дружку, как список. Просто сделаем внешний список из узлов.

Свободные узлы запишем в список свободных узлов, в виде такого же списка, то
есть, из элементов списка, ссылающихся на узлы.

Вот такая, блин, радость. Преимущество в том, что код станет более однообразным.
Потери в производительности из-за дополнительного уровня косвенных ссылок. Но
это они дают дополнительную гибкость. Ок... Поехали.

Так. Переигрываем немного обратно. Потому что хочется в ходе оценки графа узлов
иметь такие же списки, которые задают атомы или типы. А там просто номера.
Можно, конечно, сделать таблицы атомов или типов, состоящими из узлов, но это
усложнение в двух местах.

Так как у нас списки всё-равно в два этапа загружаются: сырая загрузка и оценка
по атомам-типам-числам, то лучше эту трансформацию оставить здесь.


						   Sun Mar 24 01:31:52 YEKT 2013

Что-то у меня сегодня прямо праздник тупости какой-то. Итак. Кольцевые списки -
это списки, в которых есть один указатель. Если этот указатель на начало, то,
вставлять сложно новый элемент, ибо, это же надо проматывать весь список до
конца. Так? Так. И в примерах в интернете так.

Поэтому, это должен быть указатель на конец. Указатель на начало тогда
получается как ptr->link.

						   Sun Mar 24 09:53:34 YEKT 2013

Так. Надо менять интерфейс. Чтобы можно было вызывать в каком-то контексте
чтение списка. Контекст - это какой-то набор связанных с узлами указателей.
Поэтому делаем так:

	loadrawlist(FILE *, AtomTable *, const List *const names)

Имена - это список из таблицы атомов и массива ссылок на узлы, которые
обозначены этими атомами (атомами, стоящими после =).

names имеет смысл явно вынести в интерфейс, потому что: ну а вдруг? Append
должен уметь работать с NULL-евым списком вначале.

Так. Ещё одно замечание. В List мы добавим ссылки на окружения. Окружения будут
универсальными с поиском по спискам из типов и атомов. Поиск по атому - это то
же самое, что и поиск по списку из одного атома. Так? Так. Next.

В окружениях может быть разное, поэтому кроме, собственно массива из списков и
индекса у нас должен быть массив из item-ом. Где каждый item - это структура с
объединением разных указателей.

Возможно, имеет смысл это назвать Binding.

Ещё надо сделать push для массивов, потому что это частая операция. И постоянно
exporesize-ить вручную смысла нет.

						   Tue Mar 26 16:16:19 YEKT 2013

Так. Надо подкорректировать несколько опять формат списка. Суффиксы - это плохая
идея, потому что если их использовать и для ссылок на типы, и для каких-то
уточнений в инструкциях, получиться слишком много if-ов при анализе.

Поэтому, новый формат примерно такой:

	F f = ((AL 00.1."A"; TL (AL 10.0.""); (
		AL	T = (00.4."True");
		AL	F = (00.5."False");
		LN	a = (FI; 1; 0);

		F ft = ((T; a); (
			LN	a = (F.i; 1; 1);
			SL	s = a;
			FO	(s; TL (AL (00.7."Symbol")))
		));

		F ff = ((F : a); (
			LN	(FI; 1; 1);
			TL	f4 = (AL (00.1."F"); AL (00.1."4"));
			S	s = (f4; a);
			FO	(s; TL (AL (00.7."Symbol)))
		));

		FP	(ff);
		FP	(ft);

		FO	((SE (a)); a);

		TL	ts = (AL (00.6."Symbol"));

		F fs = ((ts); (
			LN	s = (FI; 1; 0);
			ST	t = s;

			TL	p4 = (AL ((0.0."P")));

			addr	x = (p4; s);
			rd	x = (t; s);
		))
	));

					     FIXME Tue Mar 26 23:51:02 YEKT 2013

Текущий heapsort не универсально организован. index должен быть именно индексом,
то есть, не ссылаться на ключи, а хранить номера записей в массиве. Потому что
иначе достаточно универсально не выйдет сделать.

Сейчас индекс - это массив указателей с предположением о том, что в самом ключе
записана позиция элемента в некотором массиве (atom содержит id). Но для списков
это не так. И глупо делать это так, потому что в каждый элемент списка id
добавлять что ли?

Поэтому index должен быть номерами записей в массиве. Значит, интерфейс к
сортировке и функции сравнения поменяется:

	heapsort(unsigned *const index, const void *const data, L, M);
	cmp(const void *const data, const unsigned i, const unsigned j)

В такой постановке можно в атом тогда не записывать его идентификатор.

					     FIXME Wed Mar 27 08:21:02 YEKT 2013

Так. Можно воспользоваться пока тем, что есть. В Binding можно добавть id, но
это не лучший вариант.

С типами можно порешить так: а пусть программист сам устраивает преобразование к
более общему типу (который является суммой). Тогда все типы будут конкретными.
Это плюс.

Минус в том, что надо будет как-то извлечь информацию обратно. Ну. Конкретный
тип может быть передан параметром. Или может быть передана цепочка трансформаций
типа. В общем, есть варианты. С цепочкой - это хорошо, кстати. Получиться, что
будет задана некая цепь в частичном порядке типов, и это дополнительная
информация. Хм... // Тут надо задуматься о более общей постановке. Но потом.


						   Wed Mar 27 23:58:10 YEKT 2013

Да нет же, блин! Не выйдет так. realloc опять будет портить все ссылки. Надо
переписывать heapsort и менять структуру атомов немного.

						    Sat Apr 6 10:40:59 YEKT 2013

Так. Надо понять ещё раз, какой формат списков должен быть.

	fs = F((ts) (
		s = LN(FI 1 0)
		t = ST(s)
	)

Ладно.

	fs = F((ts); (
		s	= LN(FI; 1; 0);
		t	= ST(s);
		p4	= TL(AL(0.0."P));
	)

Неа. Лучше сразу видеть, что за узел. Ок. Утверждаем пока это:

	F fs = ((ts); (
		LN	s = (FI; 1; 0);
		ST	t = (s);
		TL	p4 = (AL 0.1."P");

		addr	x = (p4; s);
		rd	x = (t; s)
	)

Кстати, действительно, совсем не понятно, что такое ST. Нужны вменяемые имена.
