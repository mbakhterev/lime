Так. Проблема в следующем. Если написано

	ffmpeg -f v4l2 -i "/dev/video0"

То парсер не увидит то, что ffmpeg является атомом слева до тех пор, пока не
увидит -f, и не воспримет уже всю конструкцию, как

	(- ffmpeg (sp f v4l2))

И это, в общем-то определённый уровень задницы. Есть ещё вариант: не мудрить. И
ничего не делать с приоритетами. Однако, это исключит всякие разные радости:

	var R matrix float = (1 2 3 4 5; 6 7 8 9 10);

	var R matrix float =
		((1; 2; 3; 4; 5); (6; 7; 8; 9; 10))

Мда уж. Но, может, в самом деле keep it simple?

	ffmpeg f:v4l2 i:"/dev/video0"

	ffmpeg f:v4l2 i:'/dev/video0'
		vf:(scale(640;480) | colorspace(grayscale(8))) o:'file.avi';

	ffmpeg -f v4l2 -i '/dev/video0'
		-vf scale(640:480).colorspace(grayscale(8)) -o 'file.avi'

Мда. Векторы, как оказывается, продуманы плохо. И что? Борьба будет за двоеточие
с высоким приоритетом? Это не очень хорошо. И это ещё полбеды. Настоящая беда в
том, что не существует никакого левого поддерева. Потому что оно может быть
только в случае, когда у первого apply меньший приоритет. А его нельзя потопить.
Получается, только один вариант:

	ffmpeg f.v4l2 i.dev.video.0
		vf(scale(640;480) | colorspace grayscale.8) fs.dev.video.0

Ладно, когда оно всё вместе написано, то не так уж и плохо выглядит.

	ffmpeg f.v4l2 i.'/dev/video0'
		vf(scale(640;480) -> x; x -> colorspace grayscale(8)) o.'file.avi'

Ладно.

	swtich
	(
	x && y -> dosomething(1);
	x -> dosomething(x + 2);

	y ^^ z ->
	(
		var f = something.1();
		var x = something.2();
		var y = something.3();

		for(x != y)
		(
			x += 1;
		);

		pin = f
	);

	default -> dodefault()
	);

Альтернатива

	swtich (
	x && y -> dosomething(1);
	x -> dosomething(x + 2);

	y ^^ z -> (
		var f = something.1();
		var x = something.2();
		var y = something.3();

		for(x != y)
		(
			x += 1;
		);

		pin = f);

	default -> dodefault())

Ладно. Будем тогда в этой модели дальше думать.

								 К ВОПРОСУ О «:»

Вообще, переменные можно было бы вводить и при помощи двоеточки. Потому что
область видимости может быть привязана к области видимости оператора. Это не
страшно. Но вопрос в том... В чём? В том, что нужен какой-нибудь вменяемый
приоритет для этой двоеточки.

	x : list int = (20; 30; 40);

	for((x;y) := range2d(1:20; 30:40))
	(
		print '%d.%d\n'.fmt(x;y))
	)

Вполне возможно, что вменяемая позиция - это где-нибудь между «=» и прочими
операциями. И что дальше? А ничего...

Крупица полезного смысла здесь в том, что операторы сами могут быть привязаны к
области видимости. Ну ладно...

	x: list int = (20; 30; 40);

	for((y; z) := range(1:20; 30:40))
	(
		print "%d.%d\n".fmt(x + y; z);
	)

И чего с этим делать? А пусть будет так:

	(x > 10 && Ex y Nat : x * y == 20) -> x == 2;

	x Nat : (Ex y Nat : x = y * 2) -> Ex z Nat : x = z << 1;

Сойдёт. Значит, система приоритетов получается примерно такая (^^ - это то же
самое, что и !=):

	0: ;
	1: = *= /= %= >>= <<= &= += -= |= ^= ||= &&=
	2: ->
	3: ||
	4: &&
	5: == != < <= > >=
	6: + - | ^
	7: * / % << >> &
	9: .

Было бы неплохо, видимо, иметь приоритет двоеточия где-то чуть выше стрелки.
Замечательно. Тогда можно писать

	fun max(a Num; b Num) = a > b -> a : b;

Ну и всё. Это однозначно говорит о том, что приоритет выше «=». Ладно, ок. А
Haskell стиль?

	fun max(a Num) = (fun(b Num) Num = a > b -> a : b)

	var x = max(2)(3);

	fun max(a num; b num) num = a > b -> a : b;
	stdin.bytes.filter(x byte) max(12345, int = x);


						   Mon Nov 19 13:40:29 YEKT 2012

Ок. Примеры из истории надо рассмотреть. Потому что сейчас очередной когнитивный
диссонанс пришёл, который вызван тремя возможными способами управлять
приоритетами:

	1. Очень просто. Однонаправленные связи, фиксированный приоритет.
		s-apply с высоким приоритетом.

	2. Обратная связь от движка, который говорит: а подними-ка ты временно
		вот эти приоритеты в правом поддереве. Правое поддерево хорошо
		определяется, как и левое в стандартном парсере.

	3. Сделать низкоприоритетный s-apply.


Посмотрим на примеры из истории.

	DISPLAY=:0.0 evince mcp.pdf &>/dev/null </dev/null &

	DISPLAY=0.0 evince 'mcp.pdf' (all)>dev.null <dev.null

Да. Это возможно, если уметь сказать, что неким магическим образом приоритет
пробела упал. Ок. Если этого сказать нельзя, как это может быть выражено?

	(DISPLAY=0.0; (1:2)=dev.null; evince) 'mcp.pdf'

Мечта идиота (моя), склонного к LISP? Ладно. Допустим. Что дальше? Что-нибудь
такое:

	(HOME=/tmp/flc/mike/ nice -n 20 linuxdcpp) &

	(HOME=tmp.flc.mike; n=20; nice) linuxdcpp

Ок. А что насчёт эпического?

	screen -S mp mplayer ~/Downloads/87* -vf crop=280:210,scale=320:240 -ao null -osdlevel 0 -display :32.1 -fixed-vo -loop 0

	screen S.mp mplayer vf(crop(280:210):scale(320:240)) ao.null osdlevel.0 display.32.1 vo.fixed loop.0 '~/Downloads.87*'

Ладно. Допустим. Хотя не очень красиво.

	{ [ -f /tmp/agent ] || ssh-agent > /tmp/agent; } && . /tmp/agent && ssh-add ~/.ssh/0xfb.mb

	var a='/tmp/agent'; (test f.(a) || ssh.agent 1.(a)) && (ENV += a) && ssh.add '~/.ssh/0xfb.mb'

	a=/tmp/agent; { [ -f "$a" ] || ssh-agent > "$a"; } && . "$a" && ssh-add ~/.ssh/0xfb.mb

Ну. Определённый уровень корявости есть.

	DISPLAY=:0.0 evince mcp.pdf &>/dev/null </dev/null &

	(DISPLAY=0.0; (1:2)=dev.null; evince) 'mcp.pdf'

	(DISPLAY=0.0; evince (1;2).w('/dev/null')) 'mcp.pdf'

Ладно. А так?

	a = '/tmp/agent'; (test f.(a) || (1=(a); ssh.agent) && (ENV += a) && ssh.add '~/.ssh/0xfb.mb'

Ещё

	mkdir /tmp/0x01 -p && sshfs mike@0x01.imm.uran.ru:/tmp/flc /tmp/0x01

	mkdir p '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/fls' '/tmp/0x01'

	mkdir p '/tmp/0x01' &&  sshfs 0x01.imm.uran.ru(mike).tmp.flc '/tmp/0x01'

	'/tmp/0x01' mkdir.p && 0x01.imm.uran.ru(mike).'/tmp/fls' '/tmp/0x01' sshfs

MoarrrrR

	gcc payload.c -fPIC -o pl.so -static-libgcc -shared -Wl,-static -lc -Wl,--strip-all -Wl,--gc-sections

	gcc f.pic shared Wl(static stripall sections) lc lstatic.libgcc o.'pl.so' 'payload.c'

---

	su -c 'cat /root/sys.d/nv-sync'

	su c.(cat '/root/sys.d/nv-sync') // уже распарсено

---
	#!/bin/dash

	set -e

	alias ctl='/usr/bin/systemctl'
	alias stat='/usr/bin/stat'
	alias su='/bin/su'
	alias chmod='/usr/bin/chmod'
	alias chown='/usr/bin/chown'
	alias mktemp='/usr/bin/mktemp'
	alias touch='/usr/bin/touch'
	alias mv='/usr/bin/mv'

	sync() {
		local backup target usr lock temp

		backup="$1"
		target="$2"
		user=$(stat -c %U "$backup")
		lock="$target/.nv-sync.lock"

		echo "$backup($user:$mode) -> $target"

		if [ -d "$target" ]
		then
			{ flock -xn 7 \
				&& su -c "/usr/bin/rsync -a --del --exclude .nv-sync.lock '$target/' '$backup/'" $user \
				|| { echo "will not sync. can't obtain lock: $lock"; exit 2; }; } 7<"$lock"

			return
		fi

		echo "no target: $target"
		if [ "$3" != 'up' ]
		then
			echo "no special parameter. not going up"
			exit 3
		fi

		temp=$(su -c "/usr/bin/mktemp -d '$target-XXXX'" $user)
		chmod --reference="$backup" "$temp"
		echo "going up: $temp"

		su -c "/usr/bin/rsync -a '$backup/' '$temp/'" $user
		touch "$temp/.nv-sync.lock"
		mv -n "$temp" "$target"
	}

	case "$1" in
	up)
		sync "/nvram/mb" "/home/mb" up
		;;

	down)
		sync "/nvram/mb" "/home/mb"
		;;

	sync)
		if ctl is-active nv-sync
		then
			sync "/nvram/mb" "/home/mb"
		else
			echo "not active"
			exit 1
		fi
		;;

	*)
		echo "unknown task"
		exit 4
	esac


LiME:
	exp mames = (ctl; stat; chmod; chown; mktem; touch; mv; rsync);
	val names = usr.bin.names;
	val su = bin.su;
	cmd sync (backup string) (target string) (up bool = 0) =
	(
		val user = (stat c.'%U' backup).out(0);
		val lock = target + '/.nv-sync.lock';

		echo '%s(%s:%s) -> %s'.fmt(backup; user; ''; target);

		if(test d.target)
		(
			run(7 = lock
				&& (flock xn.7 || (echo 'won\'t sync. can\'t obtain lock: ' lock; exit 2))
				&& su user c.(rsync a del exclude('.nv-sync.lock') target backup));

			return
		);

		echo 'no target: ' target;

		if(!up)
		(
			echo 'no special parameter. not going up';
			exit 3
		);

		val temp = (su user c.(mktemp d.(target + '-XXXX'))).out(0);
		chmod reference.backup temp;
		echo 'going up: ' temp;

		su user c.(rsync a target backup);
		touch '%s/.nv-sync.lock'.fmt(temp);
		mv n temp target
	)

	val sync.cmd = sync '/nvram/mb' '/home/mb';

	switch(CMD.1)
	(
		'up'	-> sync.cmd 1;
		'down'	-> sync.cmd;
		'sync'	-> if(ctl isactive 'nv-sync') sync.cmd or (echo 'not active'; exit 1);
		default -> (echo 'unknown task'; exit 4)
	)

Так. Вопрос ещё есть, возможно так:

	mkdir p "/tmp/0x01" && sshfs "mike@0x01.imm.uran.ru:/tmp/flc" "/tmp/0x01"

	mkdir p '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' '/tmp/0x01'

	var mp = '/tmp/0x01'; mkdir p mp && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' mp

	mkdir(p) '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' '/tmp/0x01'

	tar xv f.'some.tar.gz'

	(0='some.tar.gz'; gzip cd) | tar mx;

	gzip -cd some.tar.gz | tar mx;

	gzip 'some.tar.gz' cd | tar mx;

Эх. Идеала не существует

	val temp = (su (user) c.(mktemp d.(target + '-XXXX'))).out(0);
	chmod reference.(backup) temp;
	echo 'going up: ' (temp);

	su user c.(rsync a (target:backup));
	touch '%s/.nv-sync.lock'.fmt(temp);
	mv n (target:backup)

	mv(target:backup) n;
	run(rsync(target:backup) a) u.(user)

	git.filter branch fcmd.(rm rf 'src/password')

	tar c './' | (out='some.tar.gz'; gzip)

В этом, может быть, что-нибудь да есть. Потому что

	mv n (source.1 source.2 source.3 : target)

Структура может помочь избежать ошибок. Unix Haters Handbook

	mkdir -p /tmp/http-root/{tm,dl} && { mount -R /tmp/flc/mike/Downloads/ /tmp/http-root/dl; mount -R /tmp/0x01 /tmp/http-root/tm; }

	fun hr = '/tmp/http-root/%s'.fmt; mkdir p (map(hr) tm dl) && mount R hr(dl).'/tmp/flc/mike/Downloads'  hr(tm)).'/tmp/0x01'

						   Fri Nov 23 18:11:03 YEKT 2012

Немного воспоминаний об указателях (это вопрос о том нужна ли унарная «.»).
Может и не нужна но опять возникает вопрос о переписывании какого-нибудь кода.
Эмс... Возьмём AVL, только куда я его засунул?

static unsigned avl_tree_add_internal(avl_iface(t) * tree, avl_iface(pivot_t) * pivot, avl_iface(pivot_t) ** pivot_ptr) {
	avl_iface(pivot_t) * p;
	avl_iface(pivot_t) * q;
	avl_iface(pivot_t) * r;
	avl_iface(pivot_t) * s;
	avl_iface(pivot_t) * t;
	unsigned ok, found, la, lna;
	unsigned rv;
	int a;
	int rcmp;
	avl_iface(key_t) * key = pivot->key;

	p = tree->root;
	r = q = s = NULL;

	*pivot_ptr = NULL;

	rv = code_avl_ok;

	if (p) {
		s = p;
		t = NULL;
		found = 0;
		while (!found) {
			rcmp = avl_iface(key_compare)(key, p->key);

			if (rcmp == 0) { // (key == p->value.key) {
				found = FOUND_MATCH;
			}
			else {
				if (rcmp < 0) { // (key < p->value.key) {
				 	q = p->links[LEFT];
				 	if (!q) {
						found = FOUND_LEFT;
					}
				}
				else {
					q = p->links[RIGHT];
					if (!q) {
						found = FOUND_RIGHT;
					}
				}
			}

			if (!found) {
				if (q->ballance) {
					t = p;
					s = q;
				}
				p = q;
			}
		}

Это начало. И можно записать так (без обобщённых типов).

fun addinternal(tree avltree.ptr; pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) =
(
	var (p; q; r; s; t) pivot ptr;
	var (ok; found; la; lna; rv) unsigned;
	var (a; rcmp) int;
	var key avlkey.ptr = .pivot.key;
)

Точка нужна префиксная, потому что это очень частый use-case. Если представить
себе ядро, то там указазатель на указателе. Так же нужен специальный синтаксис
для указания на указатель, чтобы сложные конструкции читались однозначно:

	array(20) hash(string) int ptr

	array(20) hash(string) (int ptr)

	(array(20) hash(string) int).ptr

	array(20) hash(string) int.ptr

Ладно, к вопросу о штуках.

fun addinternal(tree avltree ptr; pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) =
(
	var (p; q; r; s; t) avlpivot.ptr;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(val) = .pivot.key;

	.p = .tree.root;
	.p = .q = .s = NULL;
	pivotptr = NULL;
)

Вот тебе и косяк. Почему в var и не-var различная семантика? Тогда уж должно
быть так

fun addinternal(.tree avltree; .pivot avlpivot; ..pivotptr avlpivot)

Или тогда уж прямым текстом:

fun addinternal(ptr tree avltree; ptr pivot avlpivot; ptr pivotptr avlpivot ptr)
= (
	ptr (p; q; r; s; t) avlpivot;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	ptr key avlkey = ptr pivot.key;
)

fun addinternal(.tree avltree; .pivot avlpivot; .pivotptr avlpivot.ptr) uint =
(
	var (.p; .q; .r; .s; .t) avlpivot;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	val .key avlkey.val = .pivot.key;

	.p = .tree.root;
	.r = .q = .s = NULL;

	.pivotptr = NULL;

	rv = codeavlok;

	if(p)
	(
		.s = .p;
		.t = NULL;
		found = 0;

		for(!found)
		(
			rcmp = keycompare(key; .p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH
			)
			else
			(
				if(rcmp < 0)
				(
					.q = .p.links(LEFT);
		)
	)
)

Эх. В этом можно и запутаться за 5 секунд, что и произошло. Ок. И чего дальше?

fun addinternal(
	tree avltree.ptr;
	pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) uint rv =
(
	var (p; q; r; s; t) pivot.ptr;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(l) = pivot(l).key;

	val key avlkey.ptr(l) = pivot(1).key;

	p = tree(l).root;
	r = q = s = NULL;

	pivotptr(r) = NULL;

	if(p)
	(
		s = p;
		t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(key; p(l).key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				q = p(l).links(LEFT);
				if(!q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			q = p(0).links(RIGHT);
			q = p(l).links(RIGHT);
			if(!q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q(l).ballance)
			(
				t = p;
				s = q
			);
			p = q
		)
	)
)

У штуки может быть и другой смысл. Типа, указатель - это адрес, относительно
которого можно вычислять всякое. Почему бы не повычислять p(0)?

 	mm = get_task_mm(task);
	if (mm && mm != current->mm && !ptrace_may_access(task, mode)) {
			mmput(mm);
			mm = ERR_PTR(-EACCES);
	}
	mutex_unlock(&task->signal->cred_guard_mutex);

	mm = gettaskmm(task);
	if(mm && mm != current(0).mm && !ptracemayaccess(task; mode))
	(
		mmput(mm);
		mm = ERRPTR(-EACCES)
	);
	mutex.unlock(ref task(0).signal(0).credguardmutex);

	(ptr task(0).signal(0).credguardmutex).unlock();

Это могло бы и так выглядеть:

	(ptr task@.signal@.credGuardMutex).unlock();

	task:.signal:.credGuardMutex

Ладно. Ещё один вариант.

	(ptr task(0).signal(0).credGuardMutex).unlock();

Тут хитрые штуки, последняя проверка на сегодня.

	bool flush_delayed_work(struct delayed_work *dwork)
	{
		local_irq_disable();
		if (del_timer_sync(&dwork->timer))
			__queue_work(dwork->cpu,
					get_work_cwq(&dwork->work)->wq, &dwork->work);
		local_irq_enable();
		return flush_work(&dwork->work);
	}


	fun flushDelayedWork(dwork ptr delayedWork) bool =
	(
		localirq.disable();
		if(delTimerSync(ptr dwork(0).timer))
		(
			sys.queueWork(dwork(0).cpu; getworkcwq(ptr dwork(0).work)(0).wq; ptr dwork(0).work)
		);
		localirq.enable();
		return flushwork(ptr dwork(0).work);
	)

	fun flushdelayedwork(dwork ptr delayedwork) bool =
	(
		localirq.disable();
		if(deltimersync(ptr (dwork timer)))
		(
			sys.queuework(dwork cpu; getworkcwd(dwork work) wq; ptr (dwork work))
		);
		localirq.enable();
	)

Так. Нужно ещё проверить комбинации с точками.

if (mod->symtab[i].st_value <= addr
		&& mod->symtab[i].st_value > mod->symtab[best].st_value
		&& *(mod->strtab + mod->symtab[i].st_name) != '\0'
		&& !is_arm_mapping_symbol(mod->strtab + mod->symtab[i].st_name))
	best = i;

if(mod(0).symtab(i).stvalue <= addr
	&& mod(0).symtab[i].stvalue > mod(0).symtab[best].stvalue
	&& (mod(0).strtab + mod(0).symtab(i).stname)(0) != '\0'
	&& !isarmmappingsymbol(mod(0).strtab + mod->symtab[i].stname))
(
	best = i
)

if(val m mod.ref; val t (ptr symtab(i)).ref; pin =
	t.stvalue <= addr
	&& t.stvalue > m.symtab(best).stvalue
	&& (m.strtab + t.stname)(0) != '\0'
	&& !isarmmappingsymbol(m.strtab + t.stname))

if(val m mod.ref; pin
	 = m.symtab(i).stvalue <= addr
	&& m.symtab(i).stvalue > m.symtab(best).stvalue
	&& m.strtab(m.symtab(i).stname) != '\0'
	&& isARMMappingSymbol(m.strtab + m.symtab(i).stname))
(
	best = i
)

Какая-то не особо сахарная вата.

if(mod@.symtab(i).stvalue
	&& mod@.symtab(i).stvalue > mod@.symtab(best).stvalue
	&& (mod@.strtab + mod@.symtab(i).stname)@ = '\0'
	&& (mod@.strtab + mod@.symtab(i).stname).is(armmappingsymbol))


	x = --py@ + 1

	x = --py(0) + 1

	object@.firstMethodCall(a; @b; c)@.secondCall(1)@.nextCall(10);

	object.firstMethodCall(a; .b; c).secondCall(1).nextCall(10);

if(mod.symtab(i).stvalue
	&& mod.symtab(i).stvalue > mod.symtab(best).stvalue
	&& (.mod.strtab + mod.symtab(i).stname) = '\0'
	&& isARMMappingSymbol(.(.mod.strtab + mod.symtab(i).stname))

Ладно. Может, точка и не самый дурацкий вариант. Попробуем последить.


fun addinternal(
	tree avltree.ptr;
	pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) uint rv =
(
	var (p; q; r; s; t) pivot.ptr;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(l) = .pivot.key;

	.p = .tree.root;
	.r = .q = .s = NULL;

	pivotptr = NULL;

	if(.p)
	(
		.s = .p;
		.t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(.key; .p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				.q = .p.links(LEFT);
				if(!.q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			.q = .p.links(RIGHT);
			if(!.q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q.ballance)
			(
				.t = .p;
				.s = .q
			);
			.p = .q
		)
	)
)


Логика может быть такой, что всё является указателем. Это стиль JavaScript и это
не плохо. Плохо то... Или не плохо. Есть же концепция коробки. Будем называть её
клеткой, дабы было тематично

fun addinternal(tree avltree; pivot avlpivot; pivotptr cell(avlpivot)) uint rv =
(
	var (p; q; r; s; t) avlpivot;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey = pivot.key;

	p = tree.root;
	r = q = s = NULL;

	pivotptr.val = NULL;

	if(p)
	(
		s = p;
		t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(key; p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				q = p.links(LEFT);
				if(!q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			q = p.links(RIGHT);
			if(!q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q.ballance)
			(
				t = p;
				s = q
			);
			p = q
		)
	)
)

						   Tue Nov 27 14:11:54 YEKT 2012

Так. Коллеги дали добро на такую трактовку указателей. Да будет так

						   Thu Nov 29 11:32:44 YEKT 2012

Очередная проблема для обдумывания такого свойства. Во-первых, слишком сложный
формат токенов, если на пути lex -> sntx ещё терпимо, то когда они записаны в
sntx -> engine, почти не читаются. Во-вторых, результат синтаксического разбора
надо бы уметь записывать для последующего использования. Это может потребоваться
и для специализации, и для шаблонов. Это всё должно записываться примерно в
таком виде:

	x + y * z

	.atom	a1 = x
	.atom	a2 = y
	.atom	a3 = z
	.add	e1 = a1		// всегда известно, что бинарные операторы 
	.mul	e2 = a2		// задаются через левый вектор
	.join	e3 = e2 a3
	.join	e4 = e1 e3

Но чтобы можно было отлаживать (показывать тот исходный текст, где это было
написано) или чтобы выдавать сообщения об ошибках, здесь должна быть информация
о позиции в тексте.

Сам файл с текстом может быть объявлен в каких-нибудь заголовках модуля или в
специальных записях библиотеки или ещё как-то, это пока не важно. Здесь же
должны быть указания на позицию в коде. Видимо, в виде пары: l.c (да, я
испытываю странную тягу к точке, и тут может быть любой другой символ):

	.atom(1.0)	a1 = 1.1.x // подсказки о длине символа и его типе
	.atom(0.4)	a2 = 1.1.y

l.c - это +l к предыдущей строке и +с к текущей позиции в строке. Так получится
немного сэкономить.

Ок. Исходя из этого надо упростить лексемы 

	l.c N.1 1 =
	l.c E.1
	l.c N.2 37 8.11.hello world

Для операторов достаточно указать один номер, а приоритет уже потом восстановить
из таблицы. Дополнительно, для проверки корректности и читаемости можно указать
строковое представление символа.

Ещё один вопрос о двоичном кодировании этих всех структур. Видимо, длина каждого
кода должна быть 16 байтов из такого расчёта:

	2 байта	- основная инструкция
	2 байта	- уточнение типа (векторные форматы тоже надо учитывать)
	2 байта	- +l (бывают длинные комментарии)
	2 байта - +c (длинные лексемы)
	4 байта	- ссылка на первый операнд (могут быть длинные зависимости)
	4 байта	- ссылка на второй

Это всё очень длинно. На первое время сойдёт, но потом надо что-то вроде utf-8
будет применять.

Ок. Time to refine the spec

						    Tue Jan 1 21:00:03 YEKT 2013

Так. Нужна возможность писать примерно так:

	operator (a int + b int) int = core "add.4i t = a b; pin t"

Нужно определится, что такое a и b. По идее, в c-выражении это свободные
переменные и их надо к чему-то привязать. Как мы знаем, это интерпретация в виде
суммы произведений доменов (sum-of-products interpertation). То есть, как бы,
функция сопоставления (match) должна выбрать соответствующий синтаксический
домен, привязать переменные и оценить значения.

Ok, это может работать. Но возникает вопрос: как определить выражения для
переменных? Там же надо иметь какую-нибудь цепочку вроде:

	addr	p = a;
	rd.4i	v = p;
	cnst.4i	c = -1;
	add.4i	t = v c;
	pin	t

						   Wed Jan 23 22:50:13 YEKT 2013

Так. Есть определённая философская проблема. Что такое метка? Метка - это нечто,
что связывает два участка кода в одно целое. Это некая точка в геометрии кода
(есть у меня такое необоснованное ощущение). Ок. Допустим.

Ладно. 1. Хватает всего двух видов ветвлений: условное ветвление и ветвление с
link-ом. В принципе, это может быть одна операция, но с разным количеством
полей. Типа:

	br C : target : link;

И это достаточно сложно парсить. Ничто не мешает при этом, однако иметь
возможность составлять списки:

	label	lx = l.1;
	label	ly = l.2;
	join	labels = lx : ly;

						   Sun Jan 27 12:34:57 YEKT 2013

Ладно. Нужны списки - это определённо. Но надо что-то делать с метками. Путь,
который просматривается примерно такой:

	- метка в текущем выражении уникальна;

	- но сами выражения являются λ-выражениями, поэтому они могут
	  применяться одно к другому; это позволит вставлять в нужные места
	  новые подвыражения;

	- некоторые метки нужно запоминать для goto (или, возможно, для switch
	  case или возвратов из функций) и это надо делать явно.

Примерно так. Ещё имеет смысл всё же разделить элементы выражений на ядерные, и
обычные.

	k.pin
	k.mark
	k.link
	k.br
	k.brl

	и т.д. по мере надобности

Имеет смысл иметь два режима подстановки выражений в другие выражения:
постановка готового выражения или подстановка с компиляцией. Тогда поток
синтаксических конструкций для каких-нибудь for-ов или if-ов не записывать.
Синтаксис записывать всё-равно придётся для шаблонных функций или чего-нибудь
такого.

Но размышлять надо в сторону того, чтобы отказаться от такой записи. Но,
наверное, это невозможно.

						   Wed Feb 27 08:34:18 YEKT 2013

Итак. Оно, конечно, идеологически понятно, что хорошо бы иметь обобщённые
функции (или аналог). То есть, когда речь заходит о какой-нибудь арифметической
операции, то это некий ArtithOp, который выражается как:

	link	t = P.0;
	link	a = P.1;
	link	b = P.2;
	op.t	r = a : b;
	pin	r

Этот самый arithop вполне можно за-lookup-ить по какому-нибудь атому, а потом
применить.

Но для lookup-а по общей логике нужен специальный атом. Следовательно, можно всё
ещё существенней упростить.

						    Wed Mar 6 18:09:23 YEKT 2013

Так. Хьюстон, у нас проблема. Не понятен основной механизм основного цикла.
Понятно, что это должна быть некоторая рекурсия (что ж ещё?), но не понятно,
какая именно.

На вход мы получаем несколько видов выражений:

	A	atom
	B
	L	atom
	E b
	E l

Так. Ну. Хорошо. Чего look-up-им-то? По, идее. У нас есть текущее выражение на
вершине стека (условно, оно может быть просто текущим). И мы получаем нечто
вроде:

	LiME Current -> "L" -> atom -> 

Так. ПОхоже, можно сделать некий динамический вариант match. Примерно по
технологиям RiDE. Попробую уточнить.

						    Sat Mar 9 23:29:54 YEKT 2013

Так. Сколько у нас всего link-ов, чтобы заработали типы? И в какой они форме
должны быть? Хых. Похоже,

	link x = A.N

Это не самый удобный формат. Потому что смысл A становится понятным только после
чтения «.». Как-то это не правильно. Поэтому лучше всю типизацию link-узлов
вынести в suffix.

	link.suffix

Таким образом у нас выходит:

	link.AN	x = N
	link.TN x = N
	link.A	x = hint.size."bytes"
	link.T	x = exp;
	link.B	x = exp;
	link	x = y : z;
	link.N	x = N

	L.AN	x = N;
	L.TN	x = N;
	L.A	x = hint.size."bytes"
	L.T	x = exp
	L.B	x = exp;
	L	x = y : z;
	L.I

Так. Ещё нужны обязательно Pin, Symbol, Const. Ладно. Но ещё нужна и Soma. Можно
ли назвать Symbol Var-ом? Soma. Как-то глупо. Назовём это rule. Назовём это
глупо - soma.

						   Sun Mar 10 21:34:19 YEKT 2013

Ладно. Можно называть нормально - это всё похоже на форму, поэтому Form. Пока не
очень понятно, как представлять списки. Почитаем классику... Классика - это:

	cons
	head
	tail
	empty

Значит, надо:
	l.na	x = N;
	l.nt	x = N;
	l.la	x = hint.size."bytes";
	l.lt	x = exp;
	l	z = x : y;
	l.h	x = y;
	l.t	z = y;

Ещё нужно как-то обозначать пустой список. С которого надо начинать
конструирование. И как его обозначить? Пусть будет

	l	x;

Ладно. Сойдёт. Но есть ещё одна проблема. Как представлять списки внутри движка?
Кольцевой список подойдёт? Подойдёт, чего бы и нет? append тоже сработает.
Вместо NULL пишем то, что нужно, получается append.

						   Mon Mar 11 01:08:51 YEKT 2013

Нет. Это слишком уж громоздкий подход. При этом, refal существует. Посмотрим ещё
раз. Ок. Refal подойдёт. Только у него pattern-matching совсем уж странный. Но
нам пока до такого далеко.

						   Fri Mar 15 13:04:30 YEKT 2013

Так. Небольшая проблема всё-таки с логикой. Форма это что? Можно ли считать, что
это вызов функции в контексте? НууУу... В принципе, наверное. Только мы не тащим
контекст с собой, в качестве аргумента. А ещё... Ещё же нет возврата. То есть,
не происходит нечто вроде:

	fn F0(c Context; l1 Leg1; l2 Leg2; ...) = (
		F1 = (l1; l2; l3; ...); // ну, типа, зависят.
		F2 = (l1; l2; l3; ...);

		c.append(F1; F2);
		evaluate(c);
	)

явного evaluate у нас нету. По идее, вроде как. Эквивалент, скорее всего, был бы
такой:

	fn form(c Context; l Legs; f Continue) = (
		fn f1 (c Context; l Legs; f Continue) = ( ... );
		fn f2 (c Context; l Legs; f Continue) = ( ... );

		...

		c.append(legs1 = f1; legs2 = f2);
		eval(c; f)
	)

Примерно нечто такое. Ну, да. И что? А ничего. Можно просто сказать потом: вот
вам библиотека для Си. По-прежнему вопрос: не усложняем ли чрезмерно? Но тут всё
ещё остаётся программируемый match-ing. То есть, идея всё-равно в том, что вызов
функций идёт не напрямую, а через eval. Это может быть ценно.

						   Sun Mar 17 15:03:06 YEKT 2013

Похоже, Y-узел не особо нужен. Вопрос об узле, выбирающем вариант. В принципе,
возможно это сделать через несколько форм:

	A.l	T = 00.4."True";
	A.l	F = 00.5."False"ш;
	A.l	A = 10.0."";		// Атом для поиска типа
	T.l	A = 10.0.""

	F.b	fe = T : A;		// форма на случай того, что символ
					// найден
	...
	F.e

	F.b	fn = F : A;		// символ не найден

	L.s	x = someatom;		// поиск символа. Возвращает True или
					// False
	
	F.p	fn;
	F.p	fe;
	P	x : (A : someatom);

Примерно так.

Скорее всего, Y-ки всегда будут использоваться в первой форме, которая
подставляется по синтаксису. Но это можно делать и не явно, и не пудрить мозг
пользователю. Ведь, фактически, разветвление на формы нужно, когда возникает
неопределённость в дальнейшем выводе. Пока неопределённости нет, можно обходится
и одной формой. А то, что надо читать Y - вполне определено. Не определено то, в
каком окружении это надо читать. А это окружение вполне может определённо
построить первая синтаксическая форма.

Алгоритм может быть такой:

	- встретили синтаксис X ..., значит надо найти форму и применить
	  её (X - это A, B, L, U);

	- встретили синтаксис E X ..., значит надо найти форму,
	  применить, а потом сливать с предыдущим контекстом вывода (X -
	  это l, u, b) и выводить цель.

Должно сработать.

						   Thu Mar 21 12:32:05 YEKT 2013

Ладно. Новый вариант выражений будет выглядеть примерно так:

	F f = (
		// Первый элемент в списке - список из входов
		((A.l 00.1."V"; T (A.l 00.10."Expression")));

		// F.i - это список, и это первый элемент в L.n
		L.n a = (F.i; 1; 1);
		L.n t = (F.i; 0; 1);

		F.o (A.l 00.1."V"; (a; t))
	);


						   Fri Mar 22 18:01:22 YEKT 2013

Ладно, теперь есть вопрос о том, что такое списки. Списки у нас - это нечто из
узлов, на самом деле. Когда мы грузим линейный участок, то это DAG из структур
вида:

	typedef struct ListStruct {
		union {
			unsigned atom;
			unsigned number;
//			unsigned special;
			struct ListStruct * list;
			struct {
				unsigned name;
				unsigned suffix;
				struct ListStruct * references;
			} node;
		} u;
		unsigned code;
		unsigned atline;
		struct ListStruct * next;
	} List;

Некоторые узлы могут быть числами, специальными узлами (например, T, при разборе
L.n) или атомами.

Хотя, вроде, нет. special не нужен. Потому что это просто атом, обрабатываемый
особо. Значит, остаётся только atom или number. По идее, это одно и то же, но
для выразительности пока оставим.

Ок. Вроде, ок.

Ещё нужно поле list, потому что в списке могут быть подсписки. Всё такое.

						   Sat Mar 23 10:54:59 YEKT 2013

Ошибка вот в чём. Списки - это отдельно, узлы - это отдельно. Списки должны
состоять из (это или, в каждом узле нечто одно из):

	- атомов;
	- типов;
	- чисел;
	- ссылок на узлы;
	- подсписков.

Атомы и типы должны быть даны своими номерами. Узлы должны иметь вид:

	- код;
	- суффикс;
	- список ссылок;
	- счётчик ссылок.

Загрузка должна проходить в две стадии (скорее всего, возможно их можно
объединить, но пока мы не оптимизируем).

1.	Обход записи списка в глубину с упорядочиванием таким образом узлов. При
	этом, атомы и типы имеет смысл обработать на общих основаниях и сделать
	из них узлы.

2.	Подстройка списка, чтобы вместо различных lookup операций по таблицам
	стояли определённые конкретные номера элементов. Нам критично это прежде
	всего для атомов и типов, потому что мы по этим объектам будем
	производить всякие разные поиски. Поэтому они должны быть в «нормальной»
	форме, в которой это всё сводится к списку из номеров атомов и номеров
	типов.

Ок. Переигрываем. Менее эффективное, но более удобное в конструировании решение.

Элемент списка - это одно из:

	- ссылка на узел;
	- ссылка на подсписок (начто в скобках);

Узел - это

	- код;
	- суффикс;
	- одно из:
		- номер (это может быть номер атома, типа, или просто число;
		  определяется кодом и суффиксом);
		- список источников (ссылок на другие узлы; список
		  структурированный);
	- число ссылок на данный узел (для сборки мусора после некоторых
	  трансформаций).

Будем в угоду однообразности поступать так. Сами узлы не будут содержать ссылок
друг на дружку, как список. Просто сделаем внешний список из узлов.

Свободные узлы запишем в список свободных узлов, в виде такого же списка, то
есть, из элементов списка, ссылающихся на узлы.

Вот такая, блин, радость. Преимущество в том, что код станет более однообразным.
Потери в производительности из-за дополнительного уровня косвенных ссылок. Но
это они дают дополнительную гибкость. Ок... Поехали.

Так. Переигрываем немного обратно. Потому что хочется в ходе оценки графа узлов
иметь такие же списки, которые задают атомы или типы. А там просто номера.
Можно, конечно, сделать таблицы атомов или типов, состоящими из узлов, но это
усложнение в двух местах.

Так как у нас списки всё-равно в два этапа загружаются: сырая загрузка и оценка
по атомам-типам-числам, то лучше эту трансформацию оставить здесь.


						   Sun Mar 24 01:31:52 YEKT 2013

Что-то у меня сегодня прямо праздник тупости какой-то. Итак. Кольцевые списки -
это списки, в которых есть один указатель. Если этот указатель на начало, то,
вставлять сложно новый элемент, ибо, это же надо проматывать весь список до
конца. Так? Так. И в примерах в интернете так.

Поэтому, это должен быть указатель на конец. Указатель на начало тогда
получается как ptr->link.

						   Sun Mar 24 09:53:34 YEKT 2013

Так. Надо менять интерфейс. Чтобы можно было вызывать в каком-то контексте
чтение списка. Контекст - это какой-то набор связанных с узлами указателей.
Поэтому делаем так:

	loadrawlist(FILE *, AtomTable *, const List *const names)

Имена - это список из таблицы атомов и массива ссылок на узлы, которые
обозначены этими атомами (атомами, стоящими после =).

names имеет смысл явно вынести в интерфейс, потому что: ну а вдруг? Append
должен уметь работать с NULL-евым списком вначале.

Так. Ещё одно замечание. В List мы добавим ссылки на окружения. Окружения будут
универсальными с поиском по спискам из типов и атомов. Поиск по атому - это то
же самое, что и поиск по списку из одного атома. Так? Так. Next.

В окружениях может быть разное, поэтому кроме, собственно массива из списков и
индекса у нас должен быть массив из item-ом. Где каждый item - это структура с
объединением разных указателей.

Возможно, имеет смысл это назвать Binding.

Ещё надо сделать push для массивов, потому что это частая операция. И постоянно
exporesize-ить вручную смысла нет.

						   Tue Mar 26 16:16:19 YEKT 2013

Так. Надо подкорректировать несколько опять формат списка. Суффиксы - это плохая
идея, потому что если их использовать и для ссылок на типы, и для каких-то
уточнений в инструкциях, получиться слишком много if-ов при анализе.

Поэтому, новый формат примерно такой:

	F f = ((AL 00.1."A"; TL (AL 10.0.""); (
		AL	T = (00.4."True");
		AL	F = (00.5."False");
		LN	a = (FI; 1; 0);

		F ft = ((T; a); (
			LN	a = (F.i; 1; 1);
			SL	s = a;
			FO	(s; TL (AL (00.7."Symbol")))
		));

		F ff = ((F : a); (
			LN	(FI; 1; 1);
			TL	f4 = (AL (00.1."F"); AL (00.1."4"));
			S	s = (f4; a);
			FO	(s; TL (AL (00.7."Symbol)))
		));

		FP	(ff);
		FP	(ft);

		FO	((SE (a)); a);

		TL	ts = (AL (00.6."Symbol"));

		F fs = ((ts); (
			LN	s = (FI; 1; 0);
			ST	t = s;

			TL	p4 = (AL ((0.0."P")));

			addr	x = (p4; s);
			rd	x = (t; s);
		))
	));

					     FIXME Tue Mar 26 23:51:02 YEKT 2013

Текущий heapsort не универсально организован. index должен быть именно индексом,
то есть, не ссылаться на ключи, а хранить номера записей в массиве. Потому что
иначе достаточно универсально не выйдет сделать.

Сейчас индекс - это массив указателей с предположением о том, что в самом ключе
записана позиция элемента в некотором массиве (atom содержит id). Но для списков
это не так. И глупо делать это так, потому что в каждый элемент списка id
добавлять что ли?

Поэтому index должен быть номерами записей в массиве. Значит, интерфейс к
сортировке и функции сравнения поменяется:

	heapsort(unsigned *const index, const void *const data, L, M);
	cmp(const void *const data, const unsigned i, const unsigned j)

В такой постановке можно в атом тогда не записывать его идентификатор.

					     FIXME Wed Mar 27 08:21:02 YEKT 2013

Так. Можно воспользоваться пока тем, что есть. В Binding можно добавть id, но
это не лучший вариант.

С типами можно порешить так: а пусть программист сам устраивает преобразование к
более общему типу (который является суммой). Тогда все типы будут конкретными.
Это плюс.

Минус в том, что надо будет как-то извлечь информацию обратно. Ну. Конкретный
тип может быть передан параметром. Или может быть передана цепочка трансформаций
типа. В общем, есть варианты. С цепочкой - это хорошо, кстати. Получиться, что
будет задана некая цепь в частичном порядке типов, и это дополнительная
информация. Хм... // Тут надо задуматься о более общей постановке. Но потом.


						   Wed Mar 27 23:58:10 YEKT 2013

Да нет же, блин! Не выйдет так. realloc опять будет портить все ссылки. Надо
переписывать heapsort и менять структуру атомов немного.

						    Sat Apr 6 10:40:59 YEKT 2013

Так. Надо понять ещё раз, какой формат списков должен быть.

	fs = F((ts) (
		s = LN(FI 1 0)
		t = ST(s)
	)

Ладно.

	fs = F((ts); (
		s	= LN(FI; 1; 0);
		t	= ST(s);
		p4	= TL(AL(0.0."P));
	)

Неа. Лучше сразу видеть, что за узел. Ок. Утверждаем пока это:

	F fs = ((ts); (
		LN	s = (FI; 1; 0);
		ST	t = (s);
		TL	p4 = (AL 0.1."P");

		addr	x = (p4; s);
		rd	x = (t; s)
	)

Кстати, действительно, совсем не понятно, что такое ST. Нужны вменяемые имена.

						    Sat Apr 6 19:55:55 YEKT 2013

Так. Следующий вопрос: как же таки загружать списки более общим методом? По
идее, примерно так:

1.	Надо создать массив с реакциями на чтение определённых узлов. Для
	определения, можно использовать массив recode - из unsigned-ов. Примерно
	с такой логикой:

		a = loadtoken(...);
		n = lookup(recode, a);

		if(n == -1) { ERR(...); }

		n - это некий номер для чего-нибудь

2.	Для этого n должна существовать функция для обработки. В которую нужно
	передать, допустим, FILE * и void * со всякими разными параметрами.

Тогда loadrawdag получается сложной:

	loadrawdag(
		Universe,
		UserAtomsRecode,
		KeywordsRecode,
		KeyFunctions,
		FILE *
	)

Recode вполне можно назвать map. Потому что есть прямое и обратное отображение.
Интерфейс такой:

	Array makemap(unsigned code);
	void freemap(void);

	unsigned map(unsigned val); 
	unsigned direct(unsigned x);
	unsigned reverse(unsigned y);

Возможно. Наш Array - это никакой не Array, а вообще Map и есть. Поэтому, имеет
смысл (для вероятного будущего) обозвать это всё uimap.

						    Sun Apr 7 21:22:10 YEKT 2013

В новой постановке ядерного языка надо как-то различать узлы и метки. Например,
когда написано:

	ANum FIn = 01.2."34";
	FIn

FIn - это что? Ссылка на узел, или указание на входы формы?

						   Wed Apr 24 10:17:41 YEKT 2013

У нас проблема со списками, с fork/free. Вопрос в том, должны ли они уметь
удаляться вместе со своим содержимым и должны ли уметь от-fork-иваться с
копированием содержимого. Проблема в данном случае с узлами. Если их fork-ать
всегда, то получится каша, потому что, ведь, речь идёт о DAG-ах, а не о
несвязанных узлах.

Можно бы было сделать (чтобы вообще со ссылками не связываться в списках)
какие-нибудь массивы узлов, а списки бы тогда содержали только число - номер
узла в этом массиве. И тогда можно было бы свободно оперировать списками, зная,
что все узлы и так висят в массиве.

Но это плохой подход. Потому что, возникнут проблемы со сборкой общего dag-а из
более мелких: как сшивать два таким образом представленных графа? Перенумерация
всякая понадобится. Можно так сделать, но это сложный алгоритм.

Поэтому, видимо, придётся делать так: forklist и freelist - это специальные
функции для списков. Необходимые при сборке мусора или конструирования списков в
'L-узлах. Они не должны трогать узлы.

Для dag-ов же нужны специальные функции:

	forkdag(const List *const dag);
	freedag(List *const dag);

Может понадобится ещё и клонирование узла (тут возникает вопрос, со списком?)

	forknode(const Node *const n);

Но это потом. Пока, вроде, хватает того, что есть. Логику списочную менять не
будем.

						   Wed Apr 24 15:14:02 YEKT 2013

Ещё одна проблема со списками. Вообще, такое ощущение, что конструировать списки
по одному элементу может быть особо не удобно. Более того, просматривать его по
одному элементу тоже не особо удобно. Иногда нам нужно знать, какая конфигурация
элементов в списке: верно ли что второй и третий элемент списка - ссылки на
узлы, а первый - номер типа. И всякое такое.

Если это делать так:

	elat(list, 1)->code == TYPE && elat(list, 2) == NODE 

Ну, в общем, много лишних слов. Если бы была возможность всё сбросить в массив,
то было бы удобнее:

	Ref refs[3];
	if(writerefs(list, refs, 3) != 0) {	// 0 означает, что список был
		ERR("wrong format");		// ровно из 3-ёх элементов
	}
	
	if(refs[1].code == TYPE && refs[1].code == NODE && refs[2] == NODE) {}
	else { ERR("wrong format"); }

Соответственно, readresfs:

	readrefs(MKR(
		refnode(T),
		refnode(newnode()),
		refnode(newnode())
	));

Это проще, чем:

	append(newlist(refnode(T)), append(newlist(refnode(newnode())), ...))


						   Thu Apr 25 09:25:28 YEKT 2013

Так. Разумно сделать newnode в стиле LCC, чтобы сразу и sources инициировать, и
code. Чтобы писать лаконичнее:

	f = newnode(ATOM, RL(refnum(ATOM, 1));
	s4 = newnode(ATOM, RL(refnum(ATOM, 2));
	t = newnode(TYPE, RL(refnode(f), refnode(s4)));

	return RL(refnode(f), refnode(s4), refnode(t));


						   Fri Apr 26 19:29:46 YEKT 2013

Уточнение процесса разбора выражения. Видимо, имеет смысл использовать CSP для
наглядности (символы показаны самими символами или регулярными выражениями,
процессы обозначения большими буквами. ->, :, { }, | - это символы для описания
CSP).

	END	- конец разбора
	LRD	- Load Raw Dag
	CORE	- видимо, основной цикл разбора
	CE	- CORE or END

События
	num	- число
	ref	- ссылка на другой узел

Непонятное в рамках CSP
	ENV(P)	- выполнить P в новом окружении

	LRD: ( -> ENV(CORE)

	CORE: {
		'		-> NODE		-> CE |
		(		-> ENV(CORE)	-> CE |
		[0-9]+		-> num		-> CE |
		[0-9a-zA-Z]+	-> ref		-> CE |
		)		-> END
	}
	
	CE: { ; -> CORE | ) -> END }

	NODE: [0-9A-Za-z]+ -> CODE -> {
		[0-9A-Za-z]+ -> NAME -> = -> LDR	|
		( -> CORE
	}

Так. Надо постараться обойтись хвостовой рекурсией, поэтому loadrawdag должен
принимать пару аргументов. Контекст и список-аккумулятор, к которому будет
дописывать свой список эта самая loadrawdag, Соответственно, все другие процессы
тоже должны аккумулировать.

Так. Очередная тонкость. Интерфейс у всех этих последовательных процессов должен
быть другой.

1.	Контекст разбора - это некоторая константа, и лучше её выделить
	отдельно.

2.	Не константами являются окружения и списки. Их тоже лучше выделить
	отдельно в аргументах.

3.	Сама loadrawdag вполне может вернуть всего лишь список узлов, но
	промежуточные процессы чтения должны вести два списка: список узлов и
	текущий список ссылок. Первый - просто линейный список узлов. Второй -
	структурированный список ссылок.

Кроме интерфейса. Нужно обрабатывать скобки - «(» и «)» - на одном уровне
рекурсии, чтобы контролировать их соответствие. Хотя... Может, это и не
проблема. Фактически, ведь, это всё будет обеспечиваться структурой рекурсии.
Ок. Сначала такой вариант. Если не сработает, надо думать.

Так. Ещё одна запись пропала. Вопрос о том, как накапливать списки. Потому что,
должна быть разница между списком всех узлов dag-а и текущим накапливаемым
списком ссылок.

Видимо, loadrawdag не особо должен возвращать два списка. Раз это загрузка
dag-а, то результатом должен быть просто список узлов. Но внутренние функции
должны протаскивать (thread) эти два списка и дописывать к ним узлы. Поэтому,
интерфейс у них такой примерно:

	LoadCurrent fn(LoadContext *ctx, List *env, List *nodes, List *refs);

nodes - протаскиваемый список узлов. refs - текущий, конструируемый список
ссылок.

							     2013-04-30 08:38:54

Так. Значит, схема выше не особо хороша. Она может допускать цепочки:

	x; )

Которые не имеют смысла. Поэтому, надо выделить ещё один процесс в нашей
CSP-схеме: LIST, который и будет нести ответственность за открытие-закрытие
скобок.

	LDR: «(» -> LIST

	LIST: (
		x: {«(» «[0-9]+» «[A-Za-z][A-Za-z0-9]+» «'»}
			-> rewrind(x); ENV(CORE) |
		«)»	-> END
	)

	CORE: (
		«(»			-> LIST			|
		«[0-9]+»		-> ( num -> CE )	|
		«[A-Za-z][A-Za-z0-9]+»	-> ( ref -> CE )	|
		«'»			-> ( NODE -> CE )
	)

	CE: (
		«;»	-> CORE	|
		«)»	-> END
	)

	NODE: «[A-Za-z][A-Za-z0-9]+» -> CODE -> (
		«[A-Za-z][A-Za-z0-9]+»	-> ( name -> «=» -> «(» -> LIST ) |
		«(»			-> LIST
	)

	NODE: [0-9A-Za-z]+ -> CODE -> {
		[0-9A-Za-z]+ -> NAME -> = -> LDR	|
		( -> CORE
	}

							     2013-05-11 19:54:32

Ладно. Вопрос в том, надо ли биндить метку при встрече. И если биндить, то к
чему? Надо биндить, чтобы косяков избежать. И чтобы косяков избежать, надо
биндить к NULL. А потом уже заполнять эту метку. Ух.

							     2013-05-16 15:45:47

Так. Нам нужно уметь собирать мусор на различных графах. Алгоритм сборки
примерно такой. Ну. Это mark-and-sweep должен быть классический, но чтобы не
возиться с дополнительными полями в узлах и использовать те структуры данных,
которые уже есть, будем делать так:

1.	Бежим по списку узлов. Если встречаем корневой узел, заносим его в
	ptrmap какую-нибудь.

2.	Если встречаем не-корневой узел, ничего не делаем.

Это инициализация корней. Потом надо распространить волну

1.	Снова идём по списку узлов, в каждом узле, который есть в ptrmap
	проходим по списку атрибутов и добавляем каждый узел в ptrmap.

Это стадия разметки

1.	Снова идём по списку узлов. Если узел в ptrmap, складываем эту ссылку в
	новый список. Можно просто откусывать узлы и прилеплять их в новый
	список.

2.	Если нет, то 

							     2013-05-17 14:26:04

Вопрос с под-dag-ами. Вроде, есть подграфы, куда надо заходить и есть те, в
которые не надо. Вопрос в том, как это обрабатывать? По идее, речь здесь идёт о
формах. В формах не нужно раньше времени собирать мусор или, допустим, оценивать
типы. А кое-где и нужно это делать. Например, в блоках. Вопрос: как
регулировать?

Можно ввести два контроля? Типа, subdags, subignore. В пересечение не ходим. Ну,
видимо, так? В формах можно собирать атомы и всё такое прочее. ОК. Пока так.

							     2013-05-17 17:43:42

Хьюстон, у нас опять проблема. Вопрос в отношениях между сборкой мусора и
dag-ами.

Q:	Должны ли мы собирать узлы с dag-ами в атрибутах?

A:	Вроде, причин не собирать нет. Если какой-то узел собирается, значит, на
	него нет ссылок из корней. А раз так, им и не воспользоваться.

	Если граф был выкинут в контекст свёртки, то он уже туда выкинут.
	Скопирован и вообще всё неплохо у этого графа.

В чём тогда процедура удаления dag-а? Это просто: почистить каждый узел. Узел
надо чистить так: удаляем список атрибутов, освобождаем узел. Это процедура
killnode. Наверное, она внутренняя. А снаружи вполне сойдёт удаление dag-а из
одного узла.

Q:	Тогда, наверное, возникает вопрос о том, где принимать решение о том,
	как удалять подграфы. Если удаляемый узел - это узел с графом, то?

A:	Ну. По идее, решение же заключается в том, чтобы удалить узел. Удаление
	с графом, вроде как постулировано. Следовательно... Решение надо
	принимать в процедуре freedag. И ей же нужны метки подузлов.

Ещё один вопрос: упрощение интерфейса к keymap. У нас уже есть ES. Надо
пользоваться.

							     2013-05-20 15:59:25
Так. Интерфейс к gcnode примерно такой:

	gcnode(dag, keymap(ES("F", "R")), keymap(ES("R")), keymap("A"));

Ну и нормально, наверное.

Нет. Похоже, не особо рационально. Вызов keymap сложный. И всё-равно нужны
переменные. Поэтому, можно оставить указатели.

							     2013-05-20 22:34:57

Так. Вопрос ещё в том, а на кой это в сборке мусора? Сборка мусора она на то и
сборка, чтобы собирать всё. Нужно только знать, где подграфы, в которые
спускаться. При этом спускаться надо в процедуре rebuild. В которой будет
freedag. В котором и должна быть рекурсия... Эмс.

Как-то замороченно получается. Хотя. Нет. Ведь, то что удаляется, то удаляется.
А то что оставляется, то собирается. И это надо делать после стадий анализа.
Значит, сейчас freedag

							     2013-05-27 20:58:15

Менее наивный и более универсальный вариант dumpdag:

1.	Собрать узлы.

							     2013-05-30 13:52:11

Так. Мне вот что не нравится. Во всех этих контекстах загрузки/выгрузки. state
задумывалась как состояние для сallback-ов: загрузили специальный узел, вызвали
что-нибудь такое этакое. Но... Вроде как. Наверное...

Это будет относительно плохим решением, потому что управлять из callback-ов
памятью (типа, иначе, зачем они нужны? Чтобы последовательно всё подгружать).
Это редкостное «удовольствие». Тогда что? В общем случае - ничего. Похоже, что
так.

Но это редкостное удовольствие можно, вероятно, как-то оптимизировать. Но,
видимо, в следующих версиях. Пока state не нужно. И не нужно с ним
заморачиваться так сильно. И FILE *, видимо, лучше передавать аргументом. Эх...
Опять нам предстоит небольшой rewrite на пути к доброму, умному, вечном.

Так. Логика, значит, такая. Чтобы не идти по пути «надо, видимо, два
контекста», FILE * придётся вынести в аргументы. Да, придётся его передавать
постоянно. Жаба давит, но смысл в том, чтобы контекст загрузки/выгрузки
создавать один раз. Кроме того, FILE * может и поменяться...

Так. Короче. Жаба задавила окончательно. Будет два контекста.

Но при этом параметр - DumpCurrent в DumpAction всё-равно нужен. В итоге,
FILE * остаётся в структуре.

							     2013-06-14 09:42:15

Ок. Видимо, делать для атомов compatoms и decompatoms особого смысла нет. Атомы
- они же как числа. Проще немного изменить процесс загрузки. Добавить нечто
вроде:

	.TNew x = ('00.1."F"; '00.1."4");

Тогда процесс загрузки будет выглядеть примерно так:

	LDR: «(» -> LIST;

	LIST:
	(
		  x: {«(» «[0-9]+» «[A-Za-z][A-Za-z0-9]+» «'»}
			-> rewrind(x); ENV(CORE)
		| «)»	-> END
	);

	CORE:
	(
		  «(»				-> LIST
		| «[0-9]+»			-> (num -> CE)
		| «[A-Za-z][A-Za-z0-9]+»	-> (ref -> CE)
		| «'»				-> (atom -> CE)
		| «.»				-> (NODE -> CE)
	);

	CE:
	(
		  «;»	-> CORE
		| «)»	-> END
	);

	NODE: «[A-Za-z][A-Za-z0-9]+» -> CODE ->
	(
		  «[A-Za-z][A-Za-z0-9]+»	-> (name -> «=» -> «(» -> LIST)
		| «(»				-> LIST
	)

							     2013-06-18 16:30:10

Так. В общем. Если нам не нужны специальные процедуры загрузки для атомов, то
можно обойтись без этих всех ключевых штук. Возможно, имеет смысл отказаться и
от keyonly-загрузки. Потому что формы же будут добавляться в область видимости
после специального вызова: compforms.

Для загрузки и выгрузки тогда нужны такие параметры.

Загрузка:

	file, universe, dagmap

Выгрузка:

	file, universe, dagmap

Вполне приемлемо без дополнительных аргументов. Разве только надо будет
инициализаторы для dagmap-ов написать. Ок. Работаем

							     2013-06-24 12:38:32

Вроде, графы на каждом шаге процесса должны быть замкнутыми относительно самих
себя. Сцепляться они должны в процессе интерпретации через узлы FOut и FIn. Ну.
Клёва. Что дальше? Значит, forkdag должен быть написан в этих предположениях.
Возможно, они потом поменяются. Но пока пусть будет так.

Примерный алгоритм:

1.	Собрать в ptrmap M все узлы.

2.	Выделить массив N подходящего размера под новые узлы. Можно прямо в
	клон узла n будет находится по адресу N[ptrreverse(ptrmap, n)].

3.	Идём по ptrmap-е. Можем встретить узел с подграфом или обычный узел.

	3.1.	Если узел с подграфом, то всё просто
		
		n = ptrdirect(M, i);
		N[i] = newnode(n->verb, forkdag(n->u.attributes, dagmap));
	
	3.2.	Если узел со списокм атрибутов, то всё сложнее:

		n = ptrdirect(M, i);
		N[i] = newnode(n->verb,transforklist(n->u.attributes, i, M, N));

4.	Собрать массив узлов в список.

Тут вся соль и сложность в transforklist, которая должна идти по списку
аттрибутов, копировать его, сохраняя структуру и менять ссылки местами.

Этот самый transforklist(list, bound, M, N)  должен вести себя примерно так.

1.	Если bound = 0, то это должен быть обычный forklist. Bound должно
	говорить о том, сколько узлов находится в обычном массиве N: от 0 до
	bound.

Эта гадость не сработает для первого узла. Потому что, для N[0] bound будет
равен нулю. А transforklist в этом случае должна ругаться на любые ссылки вне M,
а не просто вести себя как forklist.

Что делать? Флаг придумать? Или какие-нибудь NULL/не-NULL?

	transforklist(attr, bound, M, N);

Наверное, NULL и не-NULL. transforklist(attr, bound, NULL, NULL) =
forklist(attr). Если карты (M) нет, то есть, если она NULL, то это и должно
означать, что делаем просто forklist. Это ветвление должно быть в forkitem в
случае NODE.

							     2013-06-25 15:16:49

Так. Следующее, что понадобится - это evallists, которая должна трансформировать
ссылки на узлы вида

	.L x = (a; b; c);

В списки, указанные справа. Это, значит, такой вот конструктор списков
(возможно, немного странный; и, точно, не шибко эффективный). Но нужна
возможность подстановки для формирования больших списков из маленьких:

	.L x = (a; b);
	.L y = (c);
	.F (x; y)

В последнем узле нужно получить список вида

	.F (a; b; c);

Это получается вроде как передача аргументов по значению.

Другой тип узлов - это деконструкторы. Нужно уметь ссылаться на элементы
списка. Формат должен быть такой примерно (Nth - от слова энный):

	.LNth	 z = (x; 1; 2; 3; (4; '00.1."H"));

Тут важно, чтобы x было ссылкой на списочный узел (на L или на FIn)

							     2013-06-27 15:44:00

Проблемы с gcnodes в графах с под-графами. Суть проблемы не ясна, но есть
очевидные места, которые надо править.

1.	Когда принимается решение делать expand, то раскрывать под-графы явно не
	нужно, потому что ссылки в них только внутренние. Если их раскрывать,
	получится какая-нибудь ерунда.

2.	... видимо, ещё должны быть косяки, но где?


							     2013-07-02 11:41:06

Очередной вопрос такой: в каком порядке проходить узлы в walkdag-е. Вопрос: кто
заходит в под-dag-и и как? В них заходит сам walkdag. Обычные обработчики,
вроде, не должны срабатывать. Поэтому, нужен if.

Вопрос ещё в том, а нужен ли divemap?... Теоретически, да. Это указание тех
узлов, в которые не надо заходить. И туда вообще ходить не надо. Даже
walkone-ом.


							     2013-07-03 17:20:33

Так. Теперь вопрос о том, что делать при evallist. evallist, по задумке, должен
переписывать списки атрибутов у некоторых узлов. Самое простое, при этом, иметь
в его current некоторую штуку

							     2013-07-21 17:11:21

Так. Как делать LNth.

							     2013-07-23 15:39:38

FUCK! Всё сдохло на нотбуке. Так. Надо восстановить. Во-первых, формат узла
такой:

	.LNth (list; (index));

index - это список из номеров или пар из номеров. Номера элементов бывают от 0
до N (просто какое-то число, смотри исходники, чем оно там ограничено) и
'00.1."T" - это указание на последний элемент списка (от Tail). Очевидно, что
первый элемент легко задаётся номером 0. Наверное, можно было бы сделать
операцию определения длины списка. Но у этого логика сложнее, да и внутреннее
представление у нас для такого не приспособлено. Поэтому такая вот фигня пока со
специальным атомом, указывающим на последний элемент в списке. Пример:

	.LNth (list; i1; i2; '00.1."T"; (i3; '00.1."T"))

Так... Это надо интерпретировать так:

	- взять из списка элемент i1;
	- оно должно быть под-списком и из него надо взять элемент i2;
	- который тоже под-список и из него берётся последний элемент;
	- из которого берутся элементы с i3 до последнего.

Так. Каждый номер i из множества {0, ..., N, '00.1."T"} разумно интерпретировать
как отрезок (отрезок, потому что края включаются): (i; i).

Поэтому для реализации всего этого счастья понадобится функция. Какая-нибудь
forklistcut. При этом... Различные косяки в индексах - это не обязательно баг, а
может быть ошибка пользователя. Поэтому, на корявых диапазонах forklistcut не
должна ломаться, а должна возвращать нечто вменяемое.

Например, она должна возвращать NULL, чистить за собой память, если что-то
использовалось, и устанавливать какой-нибудь флажок в true/false. Удобнее такой
интерфейс:

	forklistcut(l, from, to, &correct);

from и to могут быть равными -1, указывая на последний элемент списка. Ок.
Только fork-ов для списков у нас уже много. Поэтому придётся делать некий
megafork. Примерно такой:

	transforklist(l, M, N, bnd)
		= { megafork(l, 0, -1, M, N, bnd, &correct); assert(correct); }

	forklistcut(l, from, to, &correct)
		= megafor(l, from, to, NULL, NULL, 0, correct);
	
	forklist(l) = transforklist(l, NULL, NULL, 0);

Так. Значит, надо писать megafork с адским анализом параметров. В адском
анализе вариантов надо учесть, что бывает from = to = -1

							     2013-07-24 20:35:50

Ладно, ещё одна проблема, Хьюстон. Ссылка на .LNth должна вести себя примерно
так же, как .L, когда на неё ссылаются из другого узла. Там нужна подстановка,
поэтому в rewriteref в switch надо добавить ещё один вариант.

Ок. Это была простая часть.

Дальше должна быть сложная часть. Когда надо атрибуты .LNth переписать в
соответствии с индексом.

							     2013-07-26 09:26:38

ВАЖНО. Я ошибался. По двум пунктам.

1.	В стандартном C99 значения в enum-ах всегда целочисленные (int).
	Обычно считается, что компилятор подбирает наилучший тип для этих чисел,
	но в стандарте они всегда - int. Это надо помнить во избежании косяков с
	типами операций. Компилятор может выбрать более короткое представление
	этих значений (например, битовое поле), но это всегда int по семантике.
	Не unsigned int.

2.	В стандартном Си99 схема приведения типов такая:

		int -> unsigned int -> long int -> unsigned long int
			-> long long int -> unsigned long long int

	То есть, сравнивать наши unsigned-овые индексы, атомы и типы со
	значениями из enum-ов или с -1, то всё будет нормально, потому что эти
	int-ы будут переведены в unsigned-ы и операция будет выполнятся над
	значениями без знака.

Значит, ничего можно не переписывать (а то как-то слишком некрасиво
получается). По-прежнему, -1 кодирует максимальный unsigned и является
спец-значением.

							     2013-07-28 20:48:04

ГадАсть. Надо выносить функцию переработки Ref в индекс для LNth

							     2013-08-05 11:51:24

Так. Новая логика для environment. Ручной контроль затенений. Потому что все эти
явные маркеры для областей видимости не работают, судя по всему. Проблема в том,
что не известно при обращении к имени значения, где именно это имя было
привязано. Поэтому мы не можем опираться на идентификатор области видимости.

Для полноты картины: можно было бы сделать логику поиска по этому маркеру, с
учётом идентификаторов областей видимости: типа, отрезаем последний элемент в
идентификаторе текущей области видимости -- (1; 2; 3; 4) -> (1; 2; 3) -- и
пробуем искать вместе с ним. Но это какое-то безумие по вычислительной
сложности, да и по логике работы. Потому что найдётся всё-равно тот, который
объявлен с учётом затенения.

Поэтому, делаем простую логику. Если кому-то хочется иметь объявление символов
без затенения (а мне хочется), он должен сам и искать их в текущем окружении
через lookbinding.

Но на этом история не заканчивается. Потому что с затенением всё просто в
теории, когда очередное объявление переменной просто затеняет предыдущее. Но в
Си-реальности не так всё просто, потому что есть области видимости, в которых
имена объектов должны быть разными.

Поэтому... Делаем интерфейс к окружениям можно выбрать такой:

	env = pushenvironment(env);	// Новая пустая область видимости
	env = popenvironment(env);	// Область видимости на вершине
					// разрушается


	env == popenvironment(pushenvironment(env));

	// Поиск связки по имени key
	gdi = lookbinding(env, key, &isontop);	

	// Резервирование и инициализация связки под именем key
	gdi = readbinding(env, key, ref, &isontop);

	isontop говорит, нашлась ли уже связка с именем key в области видимости
	на вершине стека (в текущей области видимости).

Так. Ещё одно. Для реализации isontop-а в процедуре lookbinding можно проверять
возвращённый env на равенство env-у на вершине стека. Ок. Искать в пустых (NULL)
окружениях надо бы запретить assert-ом.

							     2013-08-05 13:54:13

Ладно. Так. Ещё раз меняем логику для работы с окружениями. Вместо read и look
делаем одну функцию:

	Ref *ref = keytoref(env, key, depth);

Которая возвращает ссылку на соответствующую ref в стеке окружений env. depth
указывает на глубину поиска. Пока глубина должна быть равна 1 (это искать только
на вершние) или -1 (это искать по всему списку). Другие значение отсеиваем
assert-ом.

Если ячейка найдена, то она и возвращается. Если не найдена, то на вершине
создаётся соответствующая запись и инициируется как

	Ref = (.code = FREE; .u.pointer = NULL)

То есть, bindingat(env, key, 1)->code == FREE должно означать, что необходимой
записи не существует.

Нужна и ещё одна вспомогательная функция, которая возвращает массив binding-ов
из вершины стека окружений. Это для будущей реализации 

	Binding *bnd = topbindings(env, &length);

Поехали снова.

							LOG: 2013-08-19 16:54:41

Надо снова разбить DagMap на части. Потому что, если map - это относительно
стабильный параметр (хотя тоже не особо понятно), то go меняется от функции к
функции часто.

							     2013-08-20 20:57:53

Так. О разборке DagMap и о том, где хранить карты, описывающие графы. Вообще,
видимо, их хранить не надо нигде. Потому что не очень понятен уровень
повторяемости использования. А ещё меня интересует, как freeform работает без
карты. Ага! В каждой форме есть своя карта. Что же. Замечательно.

Только там нужна не полная DagMap, а только map компонента, чтобы знать, что
является подграфами.

Знать о компоненте go нужно только в каких-то активных вещах, которые
перестраивают логику. Поэтому и хочется это всё разделить обратно. DagMap можно
использовать внутри для упрощения аргументов. Но снаружи лучше отдельно. Плюс
снаружи теперь можно писать NULL-евые аргументы, которые будут означать, что
соответствующие отображения пустые (может и это пригодится).

Хых. В общем, как в классическом поиске: продолжаем заходить на цель по спирали.

							     2013-08-20 22:17:44

loaddag раньше умел доцеплять новые узлы к списку узлов графа, который
передавался в качестве аргумента. Но, вроде как, это можно сделать вручную через
append. Потому что, вроде как всё равно, не бывает ссылок из одного большого
графа в другой.

А можно просто выгрести формы в текущий environment.

							     2013-08-21 09:21:11

ArrRGh! Ещё одна засада. В контексте же выращивается ещё один граф. И для него
тоже, вроде как, нужна карта. Вопрос в том: это своя уникальная карта, или что?

Засовывать эту карту в саму структуру контекста, вроде как, не очень правильно.
Потому что: а какая карта должна тогда быть у сливаемых вместе контекстов?
Проверять её на совпадение или что?

А когда граф в контексте достраивается, то что? Карта может меняться или нет?

В общем, с философской точки зрения, вроде как, эта карта должна быть внешней. И
нужна она в операциях над контекстом. Добавляем её в аргумент popcontext

							     2013-08-27 14:57:41

ПУНКТ 1

Такая, в общем, ерунда. У E-конструкций тоже должна быть координата в тексте.
Для «E u» и для «E l» это могут быть координаты конца правого поддерева. По
идее, это достаточно просто считается при синтаксическом разборе. Для
закрывающихся скобок это, естественно, координата самой скобки.

Семантика тут: координата последней буквы в выражения. Это необходимо в
дальнейшем для отладки и для формирования сообщений об ошибках для IDE.

ПУНКТ 2

Интерфейс между модулями. Надо как-то сказать, системе вывода: вот, смотри, у
нас такая очередная команда. А с другой стороны этого высказывания штука должна
понять: хопа, я тебя вижу (прямо в стиле Аватара).

Команду можно дать в виде списка из атомов (вроде как, более предпочтительно).
Но тогда вопрос: а как согласовать взгляд на атомы? Не хочется в этом месте
каждый раз строить таблицу с кучей согласований. Ну... Допустим, возможно, кучи
согласований и не нужно. Нужно бы иметь нечто вроде:

	A U B L E F

И это только для проверки одной инструкции. Слишком как-то это не так.

Можно согласовать внешним образом. Сказать: вот у нас тут есть атом для
интерфейса:

	#define AOP
	#define UOP
	#define BOP
	...

И, типа, согласовывайся с ними пользователь библиотеки, как хочешь. Ладно. Это
имеет смысл.

Ладно. Если это согласовано, то можно передавать структуру команды парой чисел:
code и atom. Оба являются атомами. В списки их заворачивать может и не надо,
хотя надо подразумевать, что это список. Плюс ещё координаты там будут где-то
болтаться. Ок. Принято

ПУНКТ 3

Что-то как-то непросто получается с закрывающими E-конструкциями. Действительно
ли надо 3 разных вида? Всё-равно же не охватывают все варианты, допустим,
скобочек. И механизм проверки должен быть более динамическим. С учётом (конечно
же, чего же тут ещё может быть?) атома, параметризирующего команду.

Принято? Ну. Допустим...

						    Position 2013-08-27 18:24:10

О Position. Сложно сэкономить память на Position. Типа, упаковать в какие-нибудь
utf-8 или ещё что. Но кратко не выйдет, скорее всего. Хотя нет, выйдет. Вот
прикидка:

	Нужен, в среднем, байт на имя файла, нужен байт на смещение в строке и
	нужно несколько байтов на строчку.  Ну. Это приемлемо. Тогда, тем более.

	Активных операций с этими параметрами в процессе трансляции проделывать
	не нужно и их можно хранить прицепленными в таком вот виде.

Но кроме этого, в общем-то, особой потребности экономить может и не возникнуть.
Потому что координаты синтаксических элементов нужны только на период вывода
выражения, в котором они участвуют. Пока существуют контексты, эти позиции
нужны. Фактически, эти позиции должны быть полями в контекстах.

Памяти это не особо много требует.

Для форм позиции. Их тоже плодить особо много не потребуется. Для сообщений об
ошибках нужна только информация об источниках узлов. Для этого нужна ссылка на
исходную форму, которая вбрасывается в контекст вывода, и соответствие узлов с
ней.

Сами графы при этом должны быть представлены массивами. Динамизм списков нужен
только при загрузке и конструировании этих графов. А так они могут быть плотно
упакованы.

Вопрос дальше. В принципе, можно упаковать и плотно при помощи utf-8, но тогда
придётся в самих узлах хранить дополнительно информацию о положении этой
самой неопределённой длины строки с номерами. Но это не особо много.

Можно и плотно забить какой-нибудь вектор структурами фиксированной длинны.

Пока берём фиксированную структуру, хоть оно и занимает 12 байтов. Но проще и
быстрее.

							     2013-08-28 18:32:28

Хорошо. Дальше надо определиться с созданием и освобождением контекстов.
Понятно, что A-томы и B-локи -- должны открывать новый контекст. Хорошо. U тоже
должны это делать.

L не должна этого делать. Потому что она должна вписываться в текущий контекст.

Фактически, унарный оператор - это некий L с нулём в качестве левого оператора.
Этот ноль в виде пустого контекста добавляется в процесс вывода, а потом в этот
контекст дописывается U.

L должно дописываться в существующий контекст.

В контексте уже должна быть достигнута целевая форма (вроде как).

Поэтому ещё одна тонкость, когда встречается «A», то контекст уже нужно считать
созревшим и достигшим целевой формы.

Нужно ли ввести явное состояние контекста? Может и не помешает. Получается,
EMPTY, RIPENING (у нас же LiME) и RIPE

							     2013-08-29 10:39:34

Как говорилось в одном культовом фильме о тяжкой судьбе киборга в мире
постапокалиптического будущего: fuck, it is quick. It - это про главного героя.
Он же киборг. Так вот. Fuck, it is quick. Некоторая несогласованность в cfe
требует непредвиденного и преждевременного доведения подсистемы сообщения об
ошибках в lime/lib/ до нового уровня.

							     2013-08-30 15:40:50

Ладно. GCC ближе к стандарту, когда речь заходит о структурах с постоянными
полями. Это как-то не особо адекватно, если подумать. Ну да ладно. Раз стандарт,
значит, стандарт.

От const полей отказываться нет желания, потому что это какой никакой, а
контроль над собой. Имеет смысл даже ужесточить в некоторых случаях. Придётся
иногда использовать memcpy... Что же. За безумные капризы приходится платить.
Зато понятно, что случайно эти const-ы не будут переписаны.

							     2013-08-30 18:18:05

Так. Ладно... Немного мудрости. Не имеет смысл делать .FGPut, рациональнее
сделать .FGoal, штуку, которая выводит в целевой список. Как только понимаем,
что список целевой, говорим, что цель достигнута и чистим контекст.

Это избавляет от необходимости типизировать формы. И позволяет цель достигать
уже прямо из коробки, то есть, прямо в форме, загруженной из окружения

Да и ещё. Имеет смысл помечать унарные контексты, которые будут закрываться при
помощи E-узлов атомами соответствующие унарных операций.

							     2013-09-01 22:31:36

Так. Немного самоидентификации. У нас есть контексты, которые, вроде как
являются аналогами функций в каком-нибудь чистом функциональном языке. У них
есть наборы входов, цепляние к которым дополнительных значений создаёт новые
контексты и т.д.

Хорошо. Формы, получается, это некоторые базовые штуки, примерно как примитивные
операторы в функциональных языках, которые, вроде как, функциями не считаются,
но без них функции не сконструировать. Впрочем, я тут пока не могу провести
какую-либо аналогию (может её и нет, и LiME не есть функциональный язык? а нечто
действительно новое?). Ладно. Дальше.

Дальше. Заметки о поиске по синтаксическим командам. Есть пара вариантов того,
как это сделать. Речь идёт о связывающих конструкциях, вроде L, U, E, которые
должны менять цепочку вывода в зависимости от накопленных в контекстах
значений. Мы должны выбрать какие-то формы из окружения, чтобы дополнить
контексты и продолжить вывод. U вообще ничего не знает про накопленное в
контексте. Об этом знает E, которая закрывает связывает пару контекстов. U
накидывает опеределённые формы в контекст, бла-бла-бла потом.

L и E - вот что надо расписывать более точно для фиксирования общей картины.
Когда приходит L, оно видит один контекст на вершине (оно, конечно, вообще весь
стек видит), но по семантике представления бинарных операторов оно видит только
верхний контекст.

Надо выбрать как-то форму, по L, атому описывающему оператор и содержимому
контекста. Вроде, пока придумалось две разные стратегии, из которых пока выбрана
вторая. Однако, для полноты картины и более полного представления о том, о чём
вообще идёт речь, имеет смысл расписать подробно оба варианта.

1.	Можно учитывать накопленное в контексте значение, чтобы выбрать форму,
	которая продолжит вывод. Но что такое значение в контексте? Это:

	1.1. 	Накопленный граф программы.

	1.2.	Некоторые выходы из этого графа для связывания их со входами
		форм, которые возникнут дальше в ходе вывода.
	
	1.3.	Можно подумать, что этого достаточно и остановится на этом. Но
		возникнет вопрос, а как мы сможем сделать нечто, похожее на
		функции высшего порядка? Чтобы это было возможно нам надо уметь
		получать контексты, в которых есть информация о том, как в них
		чего-нибудь ещё такого подставить, чтобы получить новый контекст
		(контекст - аналог функции). Поэтому у контекста должен быть
		механизм для сохранения каких-то входов.

		Если контекст является аналогом функции из ФП, то у него должны
		быть места для подстановки новых значений (λx и всё такое
		прочее). При чём, среди прочего надо рассматривать и свободные
		переменные. Тут надо углубиться

		1.3.1.	В обычном λ-исчислении без свободных переменных никак
			нельзя, потому что через них получается каррирование
			(curring).  Что-то вроде:

				lambda x = (lambda y = add x y)

			Если рассматривать внутреннее выражение без учёта
			внешнего, то x -- такая вот свободная переменная. Мда.
			Это всё нужно, чтобы функции могли создавать новые
			функции, и тогда можно отображать значение (например,
			какой-нибудь тот же L +) на функцию, которая может
			принять другое значение и так далее. Красиво и логично.

			Только это красиво, когда абстрактно. А когда не
			абстрактно, то функция -- это некоторая
			последовательность байтов в памяти, которую надо
			проанализировать, подставить туда аргумент, получить
			некоторое значение, которое, если оно является
			lambda-ой, вновь надо интерпретировать, как функцию. И
			т.д.

			Но нам надо вывести не функцию, которую надо применить
			ко входам, а граф программы. Можно было бы написать,
			конечно, какой-нибудь LISP-движок... Но тогда на нём
			пришлось бы писать те же самые match-и и разборы
			параметров, чтобы текущая функция выдала следующую
			функцию, которая должна принять остаток синтаксического
			дерева и по нему выдать код.

			В общем, это те самые накладные расходы в труде, от
			которого хочется уйти.

		1.3.2.	Поэтому мы идём несколько нестандартным путём и пытаемся
			заставить графы склеиваться в нужную структуру
			автоматически (хотя бы полу-автоматически).

			Но поучится у функционального программирования всяко
			надо. Ну, или можно назвать это некоторым
			переосмыслением.

			Тут надо понять, что такое подстановка переменной, что
			такое несвязанные переменные (потому что это важно), и
			какие аналоги у нас есть. Потом надо выйти на уровень
			выше (пункт 1.) и написать о том, почему идея о поиске
			продолжающей вывод формы с учётом накопленных в текущем
			контексте выводов может не быть самой лучшей.

			Подстановка переменной - это относительно простая штука.
			Вот есть у нас некоторое значение, в котором упомянута
			некоторая переменная (то есть, нечто, что может быть
			связано с различными значениями). В этом значении
			(которое является функцией) мы на место этого упоминания
			записываем то, с чем связана переменная, и пытаемся
			понять, как надо пересчитать то полученное таким образом
			новое значение.

			Пока всё неплохо и логично.
			
			У нас, в LiME, переменные могут быть связаны с
			некоторыми узлами в графе. И мы хотим делать такую
			пакость:

			- Вот есть у нас некий кусок графа, накопленный на
			  текущий момент. Для этого графа мы хотим варианты его
			  разрастания при приходе другого куска графа,
			  который тоже должен как-то вырасти, чтобы объединиться
			  с графом текущим.

			- Мы не можем отказаться от того, чтобы графы отрастили
			  себе интерфейсы для того, чтобы срастись в один граф.
			  Приведения типов, арифметические операции, через
			  которые графы сводятся вместе и всё такое прочее.

			- Поэтому мы должны один граф цеплять к другому через
			  некий интерфейс. Роль которого играют формы, которые
			  могут одной частью своего входа цепляться к одному
			  графу, и другой частью к другому.

			- Эмс... Так. Но мы хотим делать такую пакость не просто
			  так. Мы делаем её вынужденно, и это есть аналог
			  механизма match-инга.

			  Если бы графы были фиксированными с указанием
			  переменных, отмечающих места подстановки ссылок на
			  части из другого графа, то нам бы пришлось в этом
			  месте писать большой if и явно прописывать механизм
			  трансформации графов для приведения их к общему
			  интерфейсу.

			  Повторение: а мы хотим избежать такой мороки. В
			  надежде, что автоматизация таких вещей упростит нам в
			  будущем жизнь со множеством других фронтендов и
			  позволит повторно использовать куски семантики для
			  разных языков. ОК.

			- Поэтому у нас возникает концепция формы, через которую
			  возникает интерфейс между графами. То есть, граф,
			  фактически говорит системе вывода: а вот, в этом месте
			  я могу срастись так-то при если на входах есть
			  такие-то отростки из другого графа.
			
			То есть, подстановка переменной в LiME происходит не
			просто записью её значения v в определённое место
			значения f, описывающего активную (способную в себя
			подставлять нечто, aka функция) сущность, а через
			указание того, как надо эту сущность (граф) переписать
			(это вместо match-а, который говорит, какую часть
			функции надо оставить в итоговом значении).

			И для этого у графа, выводимого в текущем контексте есть
			список форм, которые определяют варианты процедур
			подстановки.

			Пока хорошо и логично (надеюсь на последнее).

			После такой подстановки у нас появляется набор значений
			(ссылок на узлы графа), которые могут быть связаны с
			другими переменными (за что отвечают формы).

		1.3.2.	Несвязанные переменные в контексте вывода LiME-ового
			дерева -- это подмножество переменных (кто бы
			сомневался). А переменные у нас объединены с формами,
			точнее, с их входами. И, фактически, все формы, которые
			нельзя активировать в текущий момент времени, являются
			свободными (free, unbound) переменными.

			И они являются прямыми аналогами свободных переменных в
			функциях из мира ФП, которые тоже являются некими
			объектами, которые нельзя связать со значениями.

			Так что, у нас тоже возможна механика a la функции,
			возвращающие функции. После слияния контекстов у них
			могут отрасти новые выходы и новые входы. То есть, такой
			вот аналог lambda-ы.

			При чём, у нас даже несколько богаче этот процесс может
			быть, потому что бывают наполовину связанные формы, и
			они могут порождать новые формы и всё такое прочее.
			Хотя, конечно, lambda-исчисление и машину Тьюринга не
			победить. Но, возможно, более удобную форму
			универсальной машины мы получим для своих нужд на этом
			пути.

	Вернулись к 1. Так. У нас есть понимание того, что активация форм - это
	аналог комбинации подстановки переменных в тело функций и одновременный
	выбор продолжения этих функций.

	Теперь надо описать первую стратегию того, как наращивать контексты с
	приходом новой информации извне (синтаксической команды).

	Итак, у нас есть контекст, в котором есть кусок выведенного графа, есть
	набор ссылок на узлы этого графа, эти ссылки будут привязаны через
	активацию форм к графу на следующих этапах.

	Как нам добавить входов (повысить валентность, активность, потенциальную
	энергию, нужное подчеркнуть) контексту, получив новую информацию из
	внешнего мира?

	А добавлять надо, потому что интерфейс контекста (набор входов и
	выходов) должен немного видоизмениться, в зависимости от того, с + мы
	имеем дело или с @p для for-а.

	Ок. Так вот. Первой стратегий может быть выбор нужно формы по ключу,
	который состоит из L, атома оператора и какой-нибудь сигнатуры, которая
	соответствует тому, что есть в контексте на время поступления
	синтаксической команды.

	Но тут возникает трудный вопрос (в том смысле, что переборный), а какую
	комбинацию имеющихся выходов нужно взять для поиска в окружении?

	Можно, конечно, теоретически перебрать все. И что-нибудь да найдётся. Но
	с практической точки зрения это нереально. И для программирования, и по
	времени срабатывания. Контексты и окружения могут быть очень богатыми,
	ведь, когда-нибудь в будущем, инфо-графы в LiME могут отращиваться
	автоматически.

	Кроме того, эта стратегия требует дополнительного алгоритма поиска и
	сопоставления.

	При том, что, вроде как, у нас есть основной алгоритм поиска и
	сопоставления.

2.	Поэтому, здесь может быть другая стратегия. Мы можем сказать: вот у нас
	есть основной алгоритм сопоставления. Он всё-равно ничего лишнего не
	насопоставляет из-за требования уникальности сигнатур.

	И мы можем, когда встречаем определённую синтаксическую команду просто
	вывалить в контекст вывода все формы, которые могут быть, а оно потом
	как-нибудь само да выведется (при чём со сложностью не 2^n, а
	n*log(n)). По количеству выходов.

	И для этого ничего дополнительно не придётся программировать. Потому что
	.FPut нам и так нужен.

	То есть, в окружение мы можем повешать формы на ключи (L; op), (E; op),
	и они будут обрабатываться по тому же принципу, что и (A; op), (U; op).
	Ок. Когда эти ключи сработают, можно просто вываливать мегатонны форм,
	которые потом быстро разгребёт и отсортирует основной алгоритм
	сопоставления.

Ок. Вроде, пока всё относительно просто и относительно логично. Далее. Надо
уточнить, что такое контекст. И походу описать основной алгоритм вывода.

Контекст - это простая штука. Содержащая:

1.	Кусок выведенного графа.

2.	Набор выходов, торчащих из этого графа. Выходы - это список значений, то
	есть ссылок на узлы этого графа.

3.	Набор неактивированных форм, со входами, которые могут быть связаны с
	имеющимися в контексты выходами или будущими. Входы надо собирать в
	отдельный список, точнее в отдельное окружение (но это техническая
	деталь), чтобы проверять уникальность сигнатур.

При таком решении, однако, будет полная симметрия и идилия. Если мы проведём
несколько циклов активации форм, поймём, что всё, вывод закончился... И, что
делать дальше? Что чистить, какие формы удалять, какие оставлять? Какие
входы надо оставить открытыми для дальнейшей эволюции?

Без некой лёгкой ассиметрии это всё повиснет в воздухе. Поэтому в контексте
должен быть ещё один слой форм, входов и выходов - интерфейсный.

В который можно записывать при помощи эмс... Можно придумать специальные verb-ы
для операций:

	.FFPut
	.FFOut

Типа FF = Form Forward. Но тут может быть более мощное (в будущем) и простое (в
реализации) решение. Ведь, структура контекста будет выглядеть примерно так
(опять я на будущем front-end позволю себе пописать):

	context record (reactors array(2) record (outs; ins; forms); dag)

Реакторы (чёрт его знает, как их ещё назвать) - это штуки, в которых происходит
сопоставление. Их нужно два: текущий и следующий (который определяет будущее
формы).

Так как это массив, то в .FPut и .FOut имеет смысл просто ввести первым
аргументом номер того реактора, в который надо выбрасывать выходы
(сформированные значения) или формы с входами (переменные для будущего
связывания).

Запулить в текущий реактор выход.

	.FOut (0; (
		(('00.1."A"); '0a.12."hello world");
		(('00.1."B"); '0a.13."hello world!")));

Запулить в forward-реактор (даже можно без комментариев понятно написать).

	.L forward (1);

	.FPut (forward;
		((('00.1."A"); ('00.2."AB")); .F (.FIn inputs (); ...)))

Запуливатели просто будут брать первый номер в списке своих аттрибутов и по
соответствующей ссылке работать. Что ещё более позитивно, формат аргументов в
.FPut будет таким же, как в .FEPut, то есть, можно повторно код использовать.
Это неплохо. Очень даже.

И, наконец. Алгоритм, по которому обрабатывается текущая синтаксическая
конструкция.

1.	Прочитать конструкцию.

2.	По коду операции и атому составить ключи для поиска (code; atom) и
	(code; .TLook ('C.0."")). Здесь TLook - это поиск в окружении типа с
	именем 'C.0."", где C - это класс atom-а, то есть atomhint(a) & 0xf0. То
	есть, ищем для атома его тип, который условились так означать. Этот тип
	будет загружен в таблицу типов при инициализации lime-knl.

3.	Если не нашли, ошибка. Выражение неверное. Если нашли, то надо, в
	зависимости от кода операции добавить новый контекст в стек. Он
	добавляется для A, U, B

4.	Если нашли. Значит, надо добавит форму с её входами в реактор 0
	контекста на вершине стека контекстов. Контекст может быть не пустой.
	Добавлять надо той же функцией, которой обрабатывается .FPut.

5.	Дальше начинаем процедуру вывода в контексте, пока хоть что-то
	выводится. То есть, пока активируются формы. Форму активируем так:

	5.1.	Сначала evallists с подстановкой списка аргументов, накопленного
		из outs-ов в текущем реакторе.

	5.2.	evalforms, чтобы обновить реакторы.

	5.3.	Сборка мусора из служебных узлов.

	5.4.	Просто append получившегося графа к накопленному в body.

6.	Дальше надо продвинуть контекст дальше. То есть, убрать всё, что
	хранится в текущем реакторе, и сделать forward-реактор следующим.

7.	После этого, если код операции был E, надо объединить два контекста на
	вершине стека. У них должны быть пустыми forward-реакторы и совпадать
	маркеры (чисто assert-проверка для корректности алгоритма).

	7.1.	Объединение осуществляется просто сливанием данных из двух
		0-реакторов контекстов в один общий контекст в 0-реактор. Ну, а
		граф, накопленный в верхнем контексте надо дописать к графу в
		нижнем.

Как-то так

							     2013-09-04 11:55:50

К вопросу о жизненном цикле form. Основное место жизни форм - это окружения, и
контексты вывода.

Ок. В окружении формы должны жить... Так. «Жить» означает быть записанными в
памяти в виде графов. В окружении формы должны жить, пока существует окружение.
Оттуда они попадают в контексты вывода.

В самом реакторе вывода могут появляться формы через .F-узлы, которые потом
используются в .FPut. Появляется это всё в процессе eval-проходов графа.

И мы сам граф портим. Поэтому тут такая история:

1.	Надо получить копию графа формы, которую можно будет испортить
	eval-проходами.

	1.1.	Если форма получена из окружения, то нужно создать копию графа.
		Потому что формы из окружений повторно используются.
	
	1.2.	Если форма берётся из реактора, то прямо граф формы и можно
		портить, потому что формы в реакторе "одноразовые".

2.	В процессе evalforms в нём возникают новые формы, которые идут либо в
	окружение через FEPut, либо в контекст, через FPut.

3.	В обоих случаях нам надо сделать копию графа, потому что исходный граф
	будет подвергнут сборке мусора и служебные узлы из него будут удалены. С
	ключами хитрее:

	3.1.	Если форма отправляется в окружение, то копия ключей
		понадобится. Потому что будет повторно использоваться.

	3.2.	Если форма отправляется в реактор, то ключи будут скопированы в
		окружение ins и их копия не понадобится. Можно поставить ссылки
		на эти списки и не выделять дополнительную память.

Это всё разнообразие можно порешить при помощи флага в структуре Ref. Можно этот
флаг ставить, если нечто живёт в окружении, в котором работает процедура (не
обязательно в environment).

При инициализации этот флаг можно ставить, а при очистке как-то на него
реагировать. Например, при очистке списков freelist может не ходить в подсписки,
отмеченные как environment.

С формами только всё немного сложнее, потому что счётчики имеют смысл только в
контекстах, и нельзя не поддерживать дополнительную стркутуру Form для этого.
Потому что, в

	a + (b + с) + d

Для каждого + будет своя копия счётчика активации формы. Хотя, сама форма может
быть одинаковой.

Но флаг в ref, всё равно, будет верно указывать, как обойтись с формой:
почистить только структурку, или чистить dag-и. Или что скопировать при
необходимости.

Так же, это хорошо сработает и для ref-ов на ключи в ins-ах, чтобы аккуратно
почистились сами формы в реакторах.

Так же, это автоматически решит проблему с forklist-ами в .FIn. Потому что туда
тогда можно будет записать в аттрибуты не сам сам список аргументов, а ссылку на
этот список. И сборка мусора пройдёт легко.

Пока это будет сделано отдельным полем, но вообще, вполне можно совместить с
кодом. Кодов мало. На метку хватит одного бита. Но чтобы не менять интерфейс,
пока так.

Ок. Поехали тогда.

							     2013-09-05 09:31:34

1.	Продолжаем праздник жизни. Надо ещё откорректировать создание форм.
	Потому что, если верить представлениям о жизненных циклах форм,
	регулировать дублирование графа и ключей надо внешним образом...
	Сделано.

2.	Поле goal не нужно... Сделано.

3.	Теперь надо в feputeval (или как она там называется) делать копии графов
	и сигнатур. Пишем в окружение, там должна быть твёрдая копия... Сделано

4.	Проверка... Сделано. Компилируется.

5.	Теперь надо заняться более корректной обработкой узлов FIn в
	evallists... Сделано. Тест пройден.

6.	В evalforms и в освобождении окружения надо учесть, что источником формы
	может быть другое окружение... Сделано. Тестов пока нет.

7.	Далее, потребуется реализация intake.

							     2013-09-06 09:45:00

Приступаем к intake. intake - это часть evalforms, потому что там есть .FPut.
intake должна принимать контексты (или есть смысл работать с конкретным
контекстом? Но, вроде, нет, пока всегда речь идёт о размещении форм в верхнем
контексте в обоих случаях).

Далее. Нужен индекс реактора. Это для .FPut.

Саму форму имеет смысл задать двумя указателями на граф и сигнатуру, потому что
есть много вариантов, откуда эта форма может прийти, и там не всегда будет
стабильная структура Form.

Структуру имеет смысл создать внутри intake, и для этого понадобится флаг
external в интерфейсе intake. При этом, контекст потенциально может забирать в
себя не только формы, но ещё и выходы: .FOuts при обработке evalforms, поэтому,
имеет смысл говорить о:

	intakeform
	intakeout	// милое название

Ещё ориентировка. intakeforms должен проверить уникальность сигнатур входов.
Чтобы сообщать об ошибках в форме должен быть указан источник этой формы:
position. Всяко необходимо делать две разновидности форм.

Во второй версии много чего придётся "всяко делать".

Ладно. Поехали:

1.	Объявить интерфейс. done

2.	Ещё раз интерфейс. Там сейчас написано Context *const. Может, это и
	хорошо? Может имеет смысл не привязываться к стеку? А то, чего там ещё
	будет? Написать: tip(ctx)->ref.u.context не так уж и сложно. ОК. Да
	будет так.

3.	Взять реактор. Создать Ref с новой структурой Form и с учётом флага
	external. Нет ещё не Done. Потому что. В зависимости от external надо
	как-то обработать dag и signature. Зависимость такая:

	3.1.	Если берём external-форму. То ничего не надо делать с dag-ом и
		signature-ой, они стабильны в окружении или где-то ещё и там о
		них позаботятся.
	
	3.2.	Если берём не-external-форму. То она приходит из графа. Этот
		граф потом будет зачищен, и надо бы взять эти signature и dag, и
		от-fork-ать. Вопрос только в том, кто за это должен отвечать? За
		это может отвечать и intakeform, потому что её сейчас пишем.

		БОЛЕЕ ВАЖНО: intakeform должна хитро поступить с локальными
		сигнатурами, потому что локальные сигнатуры могут переехать на
		ПМЖ в текущее окружение ins, и на них просто надо будет взять
		ссылки. И сделать новый список из них.
	
	3.3.	Таким образом, надо сначала разместить сигнатуру в ins с учётом
		external, а потом уже делать форму.

	3.5.	На самом деле, можно сигнатуру размещать по одинаковому
		алгоритму. Там, вроде, не должно быть больших накладных расходов
		именно на верхний слой ссылок. А так. Всё-равно окружения
		скопируют свой кусок ссылок. И меньше if-ов потом будет.

4.	Растолкать signature по ins. С учётом external. Поправка: можно без
	учёта external. Поправка: нельзя. Потому что freeform воспринимает

	4.1.	ArrRGh! Чтобы получить доступ к ключу, который сохранён в
		окружении, keytoref-ы недостаточно. Нужен keytobinding. Написать
		её легко, но, всё равно, ArrRGh! Сколько можно по спирали уже
		ходить!?
	
	4.2.	Хых. Вот вам и пагубное влияние DCPL. Язык-то строгий и мы не
		можем ссылку установить в нужное место. У intakesigone должен
		быть указатель на форму, который надо записать. А этот указатель
		сделает только newform и вообще, получается, задница.
	
	4.3.	Можно сделать относительно глупо: собрать указатели на Ref-ы в
		список. А потом уже их инициировать ссылками на форму. Всё-равно
		это две разные функции будут. Но зато ERR вылезет на уровень
		выше. И информации будет больше для распечатывания ошибки. Ок.
		Допустим.

		Только тогда надо собирать указатели на binding-и. И это
		получится универсальная функция.

		Ну хорошо.
		
		4.3.1.	Потом из этих указателей надо будет собрать список
			сигнатуры (или отдать в форму исходный, если external ==
			1).
			
		4.3.2	А потом создать форму.
		
		4.3.4.	А потом ref-ами на эту форму забить binding-и.

		Придётся несколько раз ходить по списку. Поэтому, разумно
		сделать всё через массивы ref-ов.

		Это пригодится и для intakeouts.

		То есть. Нужна просто функция: listbindings. Принимать она
		должна сигнатуру (её глубоко на корректность не проверяем,
		потому что она уже будет проверена), и выдавать массив в стиле
		writerefs, оканчиавющийся на binding с NULL-евым ключом и с
		ref.code == FREE.

		Ок. Это неплохой вариант. Поехали.

							     2013-09-10 09:57:12

Так. Следующим шагом в progress после засасывания формы должно быть засасывание
некой эмуляции .FOut для пары (key; atom)

ЛИРИКА:	Да, да. Я уже проникся духом LISP и понимаю, что было бы круто писать
	просто (key atom). Долой «;» и всё такое прочее. И я бы переписал
	представление графов, и это дало бы нам некоторые profit-ы. Но блин, до
	deadline 10 дней. И как минимум, через 10 дней надо быть только чуть
	хуже LLVM.

	Блин. Вся жизнь - вечный deadline. Отстой. Ладно. Поехали

Так. Для этого нам понадобится функция intakeout (ага, получился каламбур).
Интерфейс такой:

	intakeout(U, ctx, level, outs);

	- U для вывода сообщений об ошибках;

	- outs должно быть в форме списка из пар (то есть, списков длиной 2), с
	  семантикой (key value);

	- никакой external-флаг не нужен, потому что .FOuts приходит из графа, и
	  ключи вместе со значениями надо будет копировать (потому что граф не
	  надёжный источник).

Алгоритм такой:

1.	Проверки-проверки и выбираем нужный реактор.

2.	Выдираем из outs 0-компоненты пар. Это список sig (ну, тоже сигнатуры).
	Здесь же можно посчитать длину и зафиксировать её.

3.	Делаем listbindings по sig-у. Используем длину из предыдущего пункта.

Глупо. Надо не так.

2.	Проверки-проверки и определяем длину списка + 1 (ну, это N) такой у нас
	будет.

3.	Тут уже можно сделать массив из Ref-ов на value-часть пары. И чтобы 10
	раз не ходить по списку тут же можно выделить и key часть в отдельный
	список, чтобы по нему потом получить список binding-ов из окружения. И
	будет у нас два массива для линейных проходов.

	Не забыть, что в key-часть собирать надо ключи с меткой external, потому
	что это список сразу же надо будет освобождать, и чтобы он ничего
	лишнего не освободил, надо контролировать.

4. 	Дальше всё просто. Идём по массивам, вставляем ref-ы

Ок. Поехали.

ArrRGH:	Надо же ещё счётчик завести в форме при её регистрации.

							     2013-09-10 12:21:12

Так.  Теперь вопрос: когда вызывать intakeout?  Надо как-то же ещё передать
список с ключом наружу.  Потому что типизированные формы (ну, которые не
конкретные, а с типами работают, в сигнатуре, скорее всего, будут указывать
именно тип атома, с которым они работают).

Ладно. Значит, ключ надо возвращать из getform, чтобы потом его приписывать
туда, куда надо. Поехали

Так. Пока ещё езда по кочкам. Вопрос в том: а кто отвечает за копирование
списков, если они стоят в outs? Списки надо копировать, потому что они из
нестабильных графов и их кто-нибудь может зачистить.

Ок. Замечательно. Видимо, это универсально, и проще сделать в intakeout.

							     2013-09-10 13:02:39

Пока езда по кочкам, но intakeout на своём месте. Теперь остаётся закрутить
цикл сопоставления и вывода. АаааАа! Почти победа. Давай детка, работай!

Ок. Цикл закрутить надо, но без того, чтобы посмотреть, чего там внутри
контекстов может быть сложно править ошибки. Надо все dump-функции собрать в
одно место и согласовать, чего они там выводят.

Нужно два режима вывода в dumpdag с человеческими номерами узлов и с
нечеловеческими (то есть, указателями). Чтобы можно было сопоставлять сигнатуры
и накопленные графы.

Хотя. У нас есть комментарии. И человеческий вывод графа можно просто дополнить
комментарием с указанием указателя. ОК. Этот вариант, чтобы с параметрами не
мучиться.

Нужно сделать dumpcontext, но там уже всё как бы и ОК. Это просто. В Environment
надо добавить множество case-ов.

Ок. Ещё. В кусках графов могут быть ссылки на внешние формы, после того, как мы
сделаем evallists (из параметров). Это надо выводить специально в каком-нибудь
нечеловеческом виде. Ок. Понятно.

Или всё-таки два режима вывода графов? Можно же писать N10:0xfb... бла-бла-бла.
Всё равно это для отладки. Ну хорошо. Пусть будет debug-mode (это ещё разрешит и
атомы выводить попроще).

ОК. Будет сделано

Ok. Похоже, кое-что упростится. Потому что dumplist - это на самом деле
dumpattrlist в debug-режиме.

Ладно. Тут действительно надо навести порядок.

dumplist сначала. Всегда может быть параметр universe. Если он NULL, значит,
ходим вслепую и пишем просто номерки атомов.

							     2013-09-15 00:02:25

Ладно. Параметр map нужно размазывать по графу, всяко разно, потому что таскать
его в качестве аргумента уже не только неприятно, но и как-то несогласованно.
Могут ли у разных форм быть разные карты, могут ли они отличаться от карты
накопленного графа? В общем, когнитивный диссонанс какой-то.

Графовость - это, типа, признак узла в графе. И надо его в самом графе и
хранить. И тогда (. F) от (dag F) будет отличаться. Это приемлемо. Структуру
dag-а вряд ли имеет смысл ре-интерпретировать от случая к случаю, потому что,
это как тело функции (хотя, это ещё один теоретический вопрос).

Ладно. Поехали, что ли?

							     2013-09-15 23:50:00

Ок. С map-ами решено. dumpcontext позволяет отлаживать. Продолжаем дальше.

В главном цикле progress остаётся реализовать ещё два шага: цикл вывода (infer)
и forward - перемотать состояние на следующий шаг.

Спать всё-таки надо. Но уже всё к этом готово. Завтра LiME оживёт

							     2013-09-16 10:04:48

Так. Возможно, там жуткая кривизна в intake-ах. То есть, в структуре реактора.
Скорее всего, можно обойтись вообще одним environment во всём этом бардаке. И
очередью ссылок на неактивированные связки. А связка это (да, я становлюсь
фанатом LISP; но пока мозгам так удобнее, не буду им мешать):

	(record (output Ref) (form Form ptr))

B общем-то, этого достаточно. Ну, и счётчик в форме, видимо необходим. Всё это
висит в Binding с определённой сигнатурой.

Но переделка не критична. Вроде, должно работать и так. Только понадобится в Ref
ввести ещё один code: READY (ага, по аналогии с операционными системами, ведь,
планировщики же тоже обрабатывают события).

Так вот READY -- это чисто служебное состояние в R.ins, которое говорит
человечеству, что по этому ins-у мы уже прошлись, нашли для него соответствующий
output, уменьшили счётчик активации формы, и больше на этот ins обращать
внимание не надо.

Ок. Поехали. Сначала надо сделать infer.

1.	Наверное, infer не должен уметь создавать контексты. Хотя... Это пока
	под вопросом.

							     2013-09-16 16:33:34

Эх. Гадские deadline-ы. Требования сделать поддержку LLVM. Для этого нам
понадобится деревянный Environment, узлы вида .Env, которые обозначают кадры
для блоков кода. Узлы .proc. Так табличка:

	.Env
	.proc
	.TNew
	.T

Во-первых, надо переписать environment'ы, чтобы они стали деревянными.
Во-вторых, надо написать evalframe'у -- процедуру, которая создаст из графа
дерево из окружений.

Хорошо. Только вопрос: символы же могут появляться где угодно. В разных линейных
блоках и всё такое прочее.

Это всё-равно под-графы же.

evalframe не может не оценивать типы, потому что символы с типами. А типы сами
попадают в окружения.

Тут понадобится ещё процедура walkenv. Которая будет ходить по окружениям и
чего-нибудь искать.

И это должно отличаться от процедуры lookupenv, которая должна искать снизу
вверх какой-нибудь символ.

							     2013-09-16 20:07:39

Это всё, конечно же, прекрасно. Но возникает вопрос, а как он будет сочетаться с
контекстами вывода и

	(for
		((val i (ui 0) = 0) (i < nodes.count) (i += 1))
		(assert
			(val n Node ptr = ptrdirect dc.nodes i)

			(0 < dbg ->
				  fprintf f "\n%s\t%p\t.%s\tn%u"
				  	dc.tabstr
					(val void ptr = n)
					(atombytes (atomat U n.verb)) i

				: fprintf f "\n%s\t.%s\tn%u"
					ds.tabstr
					(atombytes(atomat U n.verb)) i))))

Ну. То есть. Есть у нас for, у которого есть несколько подграфов, которыми он
оперирует. Надо иметь возможность выразить такую вещь:

	(dag LB (транслируй сюда init))

	(dag LB $cnd (транслируй сюда условие))
	(.Label cnd)

	(dag LB (транслируй сюда тело))

	(dag LB (транслируй сюда конец))

	(dag LB (jmp cnd))

Это должно быть связано как-то с тем, что сами контексты - активные сущности.

Основная тонкость здесь в трансляции условия. Потому что само условие
переведётся в нечто, с торчащими из него boolean-ами. Теперь бы эти boolean-ы
взять и под-merge-ить к контексту, где есть условный jmp с этими boolean-ами.

	(dag LB

							     2013-09-18 21:38:01

Чёрт побери. Опять ходьба по граблям. Нам не подойдёт обычная структура
окружений с указателями.

Потому что, пройдя её один раз во время сбора информации о типах, нужно второй
раз идти, используя точно такую же последовательность проходов.

Каждый .Env должен быть уникальным и записан под известным адресом.

Нет, конечно, указатели там могут быть. Но указатели... Опять таскать. Плюс
дополнительная структура. Плюс нам нужна идентификация какая-то этих окружений.
Да и ссылки у нас в самих окружениях можно запоминать.

Зачем плодить лишний список, если можно прямо спросить:

	keytoref(env, envname, -1).

Сами выделенные окружения можно записать в простой список, но вот иерархию между
ними в них же самих и сохранить.

Или в самом первом хранилище списка. Или в самом высоком на вершине. А потом
просто всю структуру и освободить.

Это, вроде как, компактнее и проще. И, если что, это выражается изнутри LiME. Мы
можем сказать, а дай-ка нам окружение: (1; 2; 4; 14)

Мы можем взять окружение выше. Можем взять ниже. И т.д. Если вдруг понадобится.

Логичная структура такая:

Мы сохраняем ту структуру окружений, которая сейчас есть. Новые элементы
добавляем вначало, а в дне, то есть, в элементе:

	env->ref.u.environment

Мы храним структуру с номерами, которые уникально определяют окружение в дереве.
То есть, какое-нибудь

	(0 1 3 4 5)

Нам не просто откусывать списки с конца. Да и вообще нужно будет часто уметь
искать в иерархии окружений снизу вверх. Поэтому формат лучше сделать
задом-наперёд и списки вложенные:

	(5; (4; (3; (1; 0))))

Хотим посмотреть на родительское окружение, просто берём кусочек списка
покороче. Хотим на дочернее, приписываем номерок спереди.

Всё просто. И можно делать в статике (в DL). env-ы мы умеем чистить pop-ами. Что
хорошо.

Ok. Вроде, сходится. Не плодим сущности, используем env. А чтобы из любого env-а
можно было дойти куда угодно, нам нужно что? Нам нужно записать в него его
идентификационный список под какой-нибудь меткой типа: ID.

И нужно записать ссылку на каталог всех окружений.

Тогда keytoref-ом можно будет искать по правильной траектории. То есть, имея
любой env, мы сможем найти всё, что угодно. Такой задумки и хочется.

Можно потом навернуть систему default-ов. Типа, не можем найти у себя, надо
искать там-то и там-то.

Ладно. Выбираем этот сценарий. Основная причина: возможность потом работать с
этим напрямую из LiME с минимум дополнительной логики.

Здесь, кстати. Тоже логики дополнительной не так уж и много будет. Потому что
всегда можно реконструировать списки окружений, понятные keytoref-у, чтобы
искать всяко разно.

Итак. У нас есть корневое окружение и куча окружений в списке перед ним, и в них
есть ссылка на root-элемент. И мы ищем.

Млин. Многострадальные окружения. В которой раз они уже переписываются? Ужас
просто. Так, значит. Надо почистить код. И реализовывать кактусы.

Массив под типы, кстати, должен быть такой же, как и массив под окружения
(странное совпадение или как?). Поэтому, будет одна не явно-extern (не в
construct.h) функция конструирования в environment.c

Да. Мы рассчитываем на LTO. Иначе, мы бы сдохли в оптимизации

							     2013-09-20 11:10:07

Так. А не избавиться ли нам от всяких штук, типа uimap или там ptrmap? Пусть это
всё будет в окружениях. Зачем плодить лишние сущности? И кода будет меньше.

							     2013-09-22 13:24:49

Ладно. Когда удаляется какое-нибудь окружение. То, вроде как, ничего особого
делать и не надо? Просто удаляем окружение и ставим в Ref.code FREE.

Главное же тут порядок сохранять, нет?

Ладно. Оно будет работать для константных окружений. А потом надо будет
подумать.

Блин. Гадость. Не особо универсально. Как делаем таблицу типов и атомов? Ну...
Хорошо. Это могут быть Ref-ы, ну стандартно.

Хорошо. Ref-ы. А что делать с array-ями тогда?

							     2013-09-22 21:21:19

Ок. Списки могут чистить свои ref-ы тоже. freeformlist не особо нужен. freelist
может это делать. У нас есть маркер external. Ответственность за анализ этого
бита может быть внутри freeX-процедуры

							     2013-09-23 00:01:18

External-маркеры могут пригодится и при выполнении fork. Когда речь пойдёт о
создании ключей для окружений. Это только списки.

							     2013-09-23 13:10:46

При удалении окружения надо о нём забыть в root-окружении.

							     2013-09-23 14:50:03

С окружениями очередной fuck-up. Система с перекрёстными ссылками очень сложной
выходит. И не понятно, кто на кого ссылается. И где чистить и т.д. и т.п.

Надо по другому. Возможно с учётом вечерних мыслей о представлении выражений в
виде кусочков. Видимо, полноценную реализацию нужно будет оставить до лучших
времён. Но сейчас часть идеи взять, чтобы уместить всё в одном массиве.

Итак... Что такое окружение? В нашем текущем смысле: это некая шняжка, имея
уникальный идентификатор которой, и имея некий другой идентификатор, мы можем
найти соответствие этой пары (env id) в окружениях, которые состоят с env в
рефлексивном и транзитивном отношении: быть super-ом.

Ок. Это будет обеспечено, если у нас есть некая одна ассоциативная по спискам
таблица, а окружения мы будем задавать видом:

	(N1; (N2; ... (NK; ()) ...))

Тогда конкретный символ в env можно задать как-нибудь так:

	(("atom" type) env)

Для менеджмента потребуется:

1.
	Когда захотим нечто создать, необходимо как-то это зарегистрировать. По
	этому ключу можно размещать список элементов в этом окружении.

2.
	Когда добавляем нечто в это окружение, то создаём соответствующую
	ячейку. И записываем ссылку на неё в список окружения. Это несложно.

3.
	Когда удаляем нечто из окружения. То освобождаем соответствующую ячейку
	и убираем соответствующий элемент из списка.

	ArrRRGH. Убрать нечто из списка - это отдельная радость физмата. Надо
	тогда убирать не нечто из списка, а весь список.

4.
	Реакторные окружения - это, типа, такие специальные окружения? Ох...
	Разбухнет эта штука. Хотя... Вроде, разнообразие ключей фиксировано.
	Разные окружения могут быть повторно использованы. Хых...

5.
	Вопрос корявый: а дочерние окружения? Как-то сложно. Нет? Как вычистить
	всё? Надо обнулить все объекты. То есть, FREE им присвоить и почистить
	их в случае необходимости.

	ОК?

	Значит, нужен список таких объектов. Список есть... Чего же боле?
	Интерфейс надо предлагать.

							     2013-09-24 08:19:47

Не-OK, чёрт побери. Потому что не хватит в таком подходе динамики. Нельзя будет
достаточно просто освобождать память от неиспользованных окружений. Логически,
так всё работает. Но технически - нет. А если память кончилась? А если ещё что?
А контексты вывода куда девать при таком подходе? А распределённые вычисления?

Не. Окружения должны быть кактусовым стеком.

Идея со вселенной выражений и задания и работа с ними не через указатели, а
через числа - здравая и может поднять эффективность. Но смысл этим выражениям
можно назначить только в рамках некоторого динамически развивающегося окружения.
То есть, можно сказать:

	А вот, в текущем контексте у меня есть out с ключом - выражением номер
	10. Жду соответствующего in

Но сами такие окружения должны порождаться и исчезать, чтобы с выражением номер
10 можно было ассоциировать разные штуки.

Ладно. Это неплохая идея. Которая должна существенно упростить работу с
динамической памятью, фактически, вся динамика будет в окружениях, которые
живут, как стеки (пусть даже и кактусовые) и в этой вселенной выражений, которые
просто вектора из чисел.

Ок. А окружения при этом будут ассоциациями чисел с чем-то.

Хорошо. Подтверждаю. Но этот вариант надо отложить на потом. Пока работаем с
динамическими графами.

Окружения всё-равно придётся сейчас делать кактусовые.

							     2013-09-26 11:30:38

Имеет ли смысл вообще везде перейти на Ref-ы? Ну. Видимо да. Имеет. Тогда и узлы
получатся более осмысленными. Когда можно будет говорить об отсутствии
атрибутов, как о N.attributes.code == FREE.

Ну и плюс assert-ов можно будет поубавить, сказав, что а вот, вся проверка
внутри.

Тогда ещё имеет смысл сделать распаковку. Типа:

	refatom
	atomref
	isatom

Ок. Ладно.

							     2013-09-27 16:39:50

Если всё делать через Ref-ы, то можно от кодов массивов избавится. Этот код
будет в Ref-е и, типа, всё ОК. Один assert и всё проще.

Так. Хорошо. Ref-ы Ref-ами. Но, вдимо, не имеет смысл вводить их для штук,
бывающих в единственном числе: таблиц атомов и типов. Или стоит?

Чтобы код был только в одном месте?

Или всё равно же всё сведётся к lookup и readin, которые на код массива и не
смотрят даже. Ну... То есть, логичнее таки всё в Ref держать. ОК

							     2013-09-28 20:15:07

Что-то мне жутко не нравится Ref-ализация всего и вся. Слишком однородно.
Политику assert-ов надо изменить: если значение передаётся в библиотечную
функцию, там оно и проверяется. Assert-ить снаружи не надо.

Ладно, откатываем

							     2013-09-30 09:11:45

Избавляюсь от Node, как от лишней сущности. Чтобы не тратить силы на
дополнительное управление памятью. Узел легко моделируется списком со
структурой:

	('hh.l."verb atom" (attributes))

Можно оставить за этой структурой название NODE. Потому что текущая логика
подразумевает умение создавать копии графов. В этих копиях ссылки на NODE должны
подменяться ссылками на копии этих NODE. В то время, как списки просто
копируются.

На самом деле... Эмс. Можно было бы с NODE и списками поступать одинаково,
потому что, как сейчас очевидно, во всех случаях мы говорим просто о
структурированных выражениях (S-выражениях) у которых в листьях атомы или
числа. Но переход на такой подход требует полной переработки кода. Поэтому, пока
делаю так. Постепенно.

							     2013-09-30 22:33:53

Итак. Плоды размышлений. От узлов, видимо, всё равно, надо постепенно
отказываться, потому что это выражения. Тут возникает несколько проблем на этом
пути, и надо понять, совместим ли предыдущий интерфейс с таким подходом. Вроде,
совместим. Вот обоснование. По процедурам

1.
	(nodeverb exp verbmap -> unsigned) - достать verb из узла и отобразить
	его через verbmap, если (verbmap != NULL). Это повсеместно необходимая
	процедура, от представления узла не зависит.

2.
	(nodeattribute exp -> Ref) - достать Ref-у с атрибутом. Ну. Раньше бы мы
	написали n->u.attributes, сейчас будем писать nodeattribute(n).
	Возможно, потому это всё можно будет сократить до attribute(n).

3.
	(newnode verb attribute -> Ref) - создаёт Ref-у на список,
	представляющий выражение (узел). (Ref.external == 0), чтобы указать на
	место определения узла, а не просто ссылку на него.

	Отличия от прежнего интерфейса: убираем концепцию dag-овости.
	Приближаемся к концепции выражений.

4.
	(loaddag file U map (Ref atom) -> Ref) вернёт ссылку на узел (читай,
	выражение), которое описывает весь граф. Оно будет таким: (atom (body)).

	Чтобы было всё рекурсивно и красиво. По смыслу ничего особенного,
	вроде. При загрузке так же, что в map-е будет трактоваться как
	замкнутые подграфы в выражениях (читай, изолированные выражения).

	Места, в которых сохраняется ссылка на определение узлов (читай,
	определение выражений) будут отмечены
	
		(Ref.code == NODE && !Ref.external).
	
	Просто ссылки на узлы

		(Ref.code == NODE && Ref.external).
	
	Загружаем слева -> направо, поэтому сначала будут идти определения, а
	потом ссылки на них. Тут всё по-прежнему

5.
	(dumpdag dbg file tabs U dag map) - вывод графа. Вроде, тоже ничего не
	меняется. Только возвращаем map, чтобы выдача была относительно красиво
	сгруппирована.

6.
	(forkdag dag -> Ref) - раз уж мы определяем узлы Ref-ами, то и графы
	надо определять Ref-ами. Потому что граф - это один такой большой узел
	(на самом деле, читай: выражение).

	Процедура fork-а, которая берёт и для всех выражений
	
		(Ref.code == NODE && !Ref.external)
	
	Создаёт копию узла, размещает ссылку соответствия старого и нового
	выражения в keytab, а для всех
		
		(Ref.code == NODE && Ref.external) 
	
	Эта ссылка берётся из таблицы. Ссылка должна быть определена до её
	использования.

	Изолированность узлов при этом сохраняется и тут всё относительно OK.

7.
	(freedag dag). Если мы знаем, где выражения определены, а где на них
	стоят ссылки, то почистить граф достаточно просто: в определениях
	устраиваем рекурсивный геноцид, а просто ссылки пропускаем.

8.
	(gcnodes dag map nonroots marks). Вроде, тоже сохраняет свою
	адекватность. Она ищет определения узлов, которые где-нибудь
	используются. Выражения, verb-ы которых попадают в map, gcnodes не
	должна чистить. Но они могут ссылаться на какие-нибудь другие узлы,
	которых пока нет в marks, и которые могут быть туда добавлены под их
	влиянием.

	Вроде. Особых противоречий пока тоже не наблюдается. Ne?

9.
	(walkdag dag map walkone ptr). Тут вопрос в том, по каким узлам ходим?
	Ну, понятно, что обходим стороной выражения, verb которых попадает в
	map. Что не понятно, так это то по каким элементам ходим.

	Вроде. Если мы говорим о выражениях, то, собственно, особой структуры и
	не наблюдается.

	Ходить надо по определениям узлов (очевидно). Мы всегда работаем с
	определениями. Всякие FEnv-ы, или FIn-ы, или даже LNth

	Ок. Это всё замечательно. Но тогда процесс обхода может управляться из
	walkdag.

	Типа: вызвали walkone для определённого узла и walkone нам сказал:
	вперёд, вдоль аттрибутов!

	Это может быть OK.

	Тогда интерфейс такой (walkdag dag walkone ptr).

	Ок. Следующее.

10.
	WalkOne. Видимо, имеет смысл раздраконить узел на компоненты, которые и
	передать в вызов WalkOne. И мы могли бы сказать, что интерфейс такой:

		(WalkOne verb attribute ptr)

	verb при этом имеет смысл прогнать через verbmap-у, потому что в 80%
	случаев нужна именно такая семантика. Поэтому walkdag может быть такой:

		(walkdag dag walkone ptr verbmap)

	Если verbmap не NULL, то через него будет пропущено значение verb-а
	выражения.

	Ок. Это всё насчёт null/не-null можно передать на управление в
	map-процедуры.

							     2013-10-06 16:25:43


Ладно. Окружения выносят мозг. Но ближе мы стали. Окружения - это независимые
таблицы которые связаны указателями, которые в каждом окружении имеют свои
имена.

Ок. Пусть будет так. Вопрос в том, как настроить окружение. И как в него войти.
Вот есть мы в текущем окружении:

	.Env
	(
		...
	)

Ладно. Нам хочется теперь создать окружение. Но его надо привязать к окружениям
существующим. Нужно, как минимум, иметь parent для поиска родительского
окружения по переменным. Нужно иметь this для этого. Потому что, есть окружения,
которые, по идее, не должны содержать своих собственных привязок переменных
(контексты вывода, например).

Видимо, это всё необходимо указать явно. 

	.Env (0."new"; .E (0."this"; .E (0."this")))

	.ENew new (0."new");

Создали новое окружение. Далее надо его нагрузить связями:

//	.E (new; ((0."env-path"; 0."this"); .E (0."env-path"; 0."this")))

	.E (0."env-path"; (0."this"); .E (0."env-path"; (0."this")));
	.E (0."ctx-path"; (0."up"); ());
	
	...

	.Env (new; ( ... работаем в этом окружении))

.E - это связки между окружениями

							     2013-10-13 13:22:51

Так. Что мы тут делаем? keymap должна вести себя хитрее. Если она получает Ref-у
ключа, то должна её копировать через forkref. Потому что, поведение, когда
почему-то освобождается параметр key после вызова - это, как минимум, очень
странно. А если хочется повторно вызвать с одним ключом?

							     2013-10-14 11:56:33

Так. Очередные грабли в том, что нам нужен частичный порядок, чтобы сказать,
ключ задаёт путь или нет.

Или нет тут верный ответ. Частичный порядок тут не правильный инструмент. Речь
идёт о pattern-matching. Или о самопальных классах эквивалентности.

Ок. Пока говорим о PM. Возможно, нужна более богатая функциональность, но для
проверки всяких ключей и структур пока можно такой вариант:

	match(k, l);

k, l должны быть generic-ключами. В них могут содержаться компоненты FREE,
которые будут отмечать места, в которые может быть подставлена произвольная
Ref-а из сопоставляемого ключа. То есть, если дошли до места, в котором (текущий
k.ref.code == FREE) || (текущий l.ref.code == FREE), то просто его пропускаем. В
противном случае .code должны совпадать.

Если встречаем списки, то надо вызывать matchkeys рекурсивно.


