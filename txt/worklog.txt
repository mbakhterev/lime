Так. Проблема в следующем. Если написано

	ffmpeg -f v4l2 -i "/dev/video0"

То парсер не увидит то, что ffmpeg является атомом слева до тех пор, пока не
увидит -f, и не воспримет уже всю конструкцию, как

	(- ffmpeg (sp f v4l2))

И это, в общем-то определённый уровень задницы. Есть ещё вариант: не мудрить. И
ничего не делать с приоритетами. Однако, это исключит всякие разные радости:

	var R matrix float = (1 2 3 4 5; 6 7 8 9 10);

	var R matrix float =
		((1; 2; 3; 4; 5); (6; 7; 8; 9; 10))

Мда уж. Но, может, в самом деле keep it simple?

	ffmpeg f:v4l2 i:"/dev/video0"

	ffmpeg f:v4l2 i:'/dev/video0'
		vf:(scale(640;480) | colorspace(grayscale(8))) o:'file.avi';

	ffmpeg -f v4l2 -i '/dev/video0'
		-vf scale(640:480).colorspace(grayscale(8)) -o 'file.avi'

Мда. Векторы, как оказывается, продуманы плохо. И что? Борьба будет за двоеточие
с высоким приоритетом? Это не очень хорошо. И это ещё полбеды. Настоящая беда в
том, что не существует никакого левого поддерева. Потому что оно может быть
только в случае, когда у первого apply меньший приоритет. А его нельзя потопить.
Получается, только один вариант:

	ffmpeg f.v4l2 i.dev.video.0
		vf(scale(640;480) | colorspace grayscale.8) fs.dev.video.0

Ладно, когда оно всё вместе написано, то не так уж и плохо выглядит.

	ffmpeg f.v4l2 i.'/dev/video0'
		vf(scale(640;480) -> x; x -> colorspace grayscale(8)) o.'file.avi'

Ладно.

	swtich
	(
	x && y -> dosomething(1);
	x -> dosomething(x + 2);

	y ^^ z ->
	(
		var f = something.1();
		var x = something.2();
		var y = something.3();

		for(x != y)
		(
			x += 1;
		);

		pin = f
	);

	default -> dodefault()
	);

Альтернатива

	swtich (
	x && y -> dosomething(1);
	x -> dosomething(x + 2);

	y ^^ z -> (
		var f = something.1();
		var x = something.2();
		var y = something.3();

		for(x != y)
		(
			x += 1;
		);

		pin = f);

	default -> dodefault())

Ладно. Будем тогда в этой модели дальше думать.

								 К ВОПРОСУ О «:»

Вообще, переменные можно было бы вводить и при помощи двоеточки. Потому что
область видимости может быть привязана к области видимости оператора. Это не
страшно. Но вопрос в том... В чём? В том, что нужен какой-нибудь вменяемый
приоритет для этой двоеточки.

	x : list int = (20; 30; 40);

	for((x;y) := range2d(1:20; 30:40))
	(
		print '%d.%d\n'.fmt(x;y))
	)

Вполне возможно, что вменяемая позиция - это где-нибудь между «=» и прочими
операциями. И что дальше? А ничего...

Крупица полезного смысла здесь в том, что операторы сами могут быть привязаны к
области видимости. Ну ладно...

	x: list int = (20; 30; 40);

	for((y; z) := range(1:20; 30:40))
	(
		print "%d.%d\n".fmt(x + y; z);
	)

И чего с этим делать? А пусть будет так:

	(x > 10 && Ex y Nat : x * y == 20) -> x == 2;

	x Nat : (Ex y Nat : x = y * 2) -> Ex z Nat : x = z << 1;

Сойдёт. Значит, система приоритетов получается примерно такая (^^ - это то же
самое, что и !=):

	0: ;
	1: = *= /= %= >>= <<= &= += -= |= ^= ||= &&=
	2: ->
	3: ||
	4: &&
	5: == != < <= > >=
	6: + - | ^
	7: * / % << >> &
	9: .

Было бы неплохо, видимо, иметь приоритет двоеточия где-то чуть выше стрелки.
Замечательно. Тогда можно писать

	fun max(a Num; b Num) = a > b -> a : b;

Ну и всё. Это однозначно говорит о том, что приоритет выше «=». Ладно, ок. А
Haskell стиль?

	fun max(a Num) = (fun(b Num) Num = a > b -> a : b)

	var x = max(2)(3);

	fun max(a num; b num) num = a > b -> a : b;
	stdin.bytes.filter(x byte) max(12345, int = x);


						   Mon Nov 19 13:40:29 YEKT 2012

Ок. Примеры из истории надо рассмотреть. Потому что сейчас очередной когнитивный
диссонанс пришёл, который вызван тремя возможными способами управлять
приоритетами:

	1. Очень просто. Однонаправленные связи, фиксированный приоритет.
		s-apply с высоким приоритетом.

	2. Обратная связь от движка, который говорит: а подними-ка ты временно
		вот эти приоритеты в правом поддереве. Правое поддерево хорошо
		определяется, как и левое в стандартном парсере.

	3. Сделать низкоприоритетный s-apply.


Посмотрим на примеры из истории.

	DISPLAY=:0.0 evince mcp.pdf &>/dev/null </dev/null &

	DISPLAY=0.0 evince 'mcp.pdf' (all)>dev.null <dev.null

Да. Это возможно, если уметь сказать, что неким магическим образом приоритет
пробела упал. Ок. Если этого сказать нельзя, как это может быть выражено?

	(DISPLAY=0.0; (1:2)=dev.null; evince) 'mcp.pdf'

Мечта идиота (моя), склонного к LISP? Ладно. Допустим. Что дальше? Что-нибудь
такое:

	(HOME=/tmp/flc/mike/ nice -n 20 linuxdcpp) &

	(HOME=tmp.flc.mike; n=20; nice) linuxdcpp

Ок. А что насчёт эпического?

	screen -S mp mplayer ~/Downloads/87* -vf crop=280:210,scale=320:240 -ao null -osdlevel 0 -display :32.1 -fixed-vo -loop 0

	screen S.mp mplayer vf(crop(280:210):scale(320:240)) ao.null osdlevel.0 display.32.1 vo.fixed loop.0 '~/Downloads.87*'

Ладно. Допустим. Хотя не очень красиво.

	{ [ -f /tmp/agent ] || ssh-agent > /tmp/agent; } && . /tmp/agent && ssh-add ~/.ssh/0xfb.mb

	var a='/tmp/agent'; (test f.(a) || ssh.agent 1.(a)) && (ENV += a) && ssh.add '~/.ssh/0xfb.mb'

	a=/tmp/agent; { [ -f "$a" ] || ssh-agent > "$a"; } && . "$a" && ssh-add ~/.ssh/0xfb.mb

Ну. Определённый уровень корявости есть.

	DISPLAY=:0.0 evince mcp.pdf &>/dev/null </dev/null &

	(DISPLAY=0.0; (1:2)=dev.null; evince) 'mcp.pdf'

	(DISPLAY=0.0; evince (1;2).w('/dev/null')) 'mcp.pdf'

Ладно. А так?

	a = '/tmp/agent'; (test f.(a) || (1=(a); ssh.agent) && (ENV += a) && ssh.add '~/.ssh/0xfb.mb'

Ещё

	mkdir /tmp/0x01 -p && sshfs mike@0x01.imm.uran.ru:/tmp/flc /tmp/0x01

	mkdir p '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/fls' '/tmp/0x01'

	mkdir p '/tmp/0x01' &&  sshfs 0x01.imm.uran.ru(mike).tmp.flc '/tmp/0x01'

	'/tmp/0x01' mkdir.p && 0x01.imm.uran.ru(mike).'/tmp/fls' '/tmp/0x01' sshfs

MoarrrrR

	gcc payload.c -fPIC -o pl.so -static-libgcc -shared -Wl,-static -lc -Wl,--strip-all -Wl,--gc-sections

	gcc f.pic shared Wl(static stripall sections) lc lstatic.libgcc o.'pl.so' 'payload.c'

---

	su -c 'cat /root/sys.d/nv-sync'

	su c.(cat '/root/sys.d/nv-sync') // уже распарсено

---
	#!/bin/dash

	set -e

	alias ctl='/usr/bin/systemctl'
	alias stat='/usr/bin/stat'
	alias su='/bin/su'
	alias chmod='/usr/bin/chmod'
	alias chown='/usr/bin/chown'
	alias mktemp='/usr/bin/mktemp'
	alias touch='/usr/bin/touch'
	alias mv='/usr/bin/mv'

	sync() {
		local backup target usr lock temp

		backup="$1"
		target="$2"
		user=$(stat -c %U "$backup")
		lock="$target/.nv-sync.lock"

		echo "$backup($user:$mode) -> $target"

		if [ -d "$target" ]
		then
			{ flock -xn 7 \
				&& su -c "/usr/bin/rsync -a --del --exclude .nv-sync.lock '$target/' '$backup/'" $user \
				|| { echo "will not sync. can't obtain lock: $lock"; exit 2; }; } 7<"$lock"

			return
		fi

		echo "no target: $target"
		if [ "$3" != 'up' ]
		then
			echo "no special parameter. not going up"
			exit 3
		fi

		temp=$(su -c "/usr/bin/mktemp -d '$target-XXXX'" $user)
		chmod --reference="$backup" "$temp"
		echo "going up: $temp"

		su -c "/usr/bin/rsync -a '$backup/' '$temp/'" $user
		touch "$temp/.nv-sync.lock"
		mv -n "$temp" "$target"
	}

	case "$1" in
	up)
		sync "/nvram/mb" "/home/mb" up
		;;

	down)
		sync "/nvram/mb" "/home/mb"
		;;

	sync)
		if ctl is-active nv-sync
		then
			sync "/nvram/mb" "/home/mb"
		else
			echo "not active"
			exit 1
		fi
		;;

	*)
		echo "unknown task"
		exit 4
	esac


LiME:
	exp mames = (ctl; stat; chmod; chown; mktem; touch; mv; rsync);
	val names = usr.bin.names;
	val su = bin.su;
	cmd sync (backup string) (target string) (up bool = 0) =
	(
		val user = (stat c.'%U' backup).out(0);
		val lock = target + '/.nv-sync.lock';

		echo '%s(%s:%s) -> %s'.fmt(backup; user; ''; target);

		if(test d.target)
		(
			run(7 = lock
				&& (flock xn.7 || (echo 'won\'t sync. can\'t obtain lock: ' lock; exit 2))
				&& su user c.(rsync a del exclude('.nv-sync.lock') target backup));

			return
		);

		echo 'no target: ' target;

		if(!up)
		(
			echo 'no special parameter. not going up';
			exit 3
		);

		val temp = (su user c.(mktemp d.(target + '-XXXX'))).out(0);
		chmod reference.backup temp;
		echo 'going up: ' temp;

		su user c.(rsync a target backup);
		touch '%s/.nv-sync.lock'.fmt(temp);
		mv n temp target
	)

	val sync.cmd = sync '/nvram/mb' '/home/mb';

	switch(CMD.1)
	(
		'up'	-> sync.cmd 1;
		'down'	-> sync.cmd;
		'sync'	-> if(ctl isactive 'nv-sync') sync.cmd or (echo 'not active'; exit 1);
		default -> (echo 'unknown task'; exit 4)
	)

Так. Вопрос ещё есть, возможно так:

	mkdir p "/tmp/0x01" && sshfs "mike@0x01.imm.uran.ru:/tmp/flc" "/tmp/0x01"

	mkdir p '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' '/tmp/0x01'

	var mp = '/tmp/0x01'; mkdir p mp && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' mp

	mkdir(p) '/tmp/0x01' && sshfs 'mike@0x01.imm.uran.ru:/tmp/flc' '/tmp/0x01'

	tar xv f.'some.tar.gz'

	(0='some.tar.gz'; gzip cd) | tar mx;

	gzip -cd some.tar.gz | tar mx;

	gzip 'some.tar.gz' cd | tar mx;

Эх. Идеала не существует

	val temp = (su (user) c.(mktemp d.(target + '-XXXX'))).out(0);
	chmod reference.(backup) temp;
	echo 'going up: ' (temp);

	su user c.(rsync a (target:backup));
	touch '%s/.nv-sync.lock'.fmt(temp);
	mv n (target:backup)

	mv(target:backup) n;
	run(rsync(target:backup) a) u.(user)

	git.filter branch fcmd.(rm rf 'src/password')

	tar c './' | (out='some.tar.gz'; gzip)

В этом, может быть, что-нибудь да есть. Потому что

	mv n (source.1 source.2 source.3 : target)

Структура может помочь избежать ошибок. Unix Haters Handbook

	mkdir -p /tmp/http-root/{tm,dl} && { mount -R /tmp/flc/mike/Downloads/ /tmp/http-root/dl; mount -R /tmp/0x01 /tmp/http-root/tm; }

	fun hr = '/tmp/http-root/%s'.fmt; mkdir p (map(hr) tm dl) && mount R hr(dl).'/tmp/flc/mike/Downloads'  hr(tm)).'/tmp/0x01'

						   Fri Nov 23 18:11:03 YEKT 2012

Немного воспоминаний об указателях (это вопрос о том нужна ли унарная «.»).
Может и не нужна но опять возникает вопрос о переписывании какого-нибудь кода.
Эмс... Возьмём AVL, только куда я его засунул?

static unsigned avl_tree_add_internal(avl_iface(t) * tree, avl_iface(pivot_t) * pivot, avl_iface(pivot_t) ** pivot_ptr) {
	avl_iface(pivot_t) * p;
	avl_iface(pivot_t) * q;
	avl_iface(pivot_t) * r;
	avl_iface(pivot_t) * s;
	avl_iface(pivot_t) * t;
	unsigned ok, found, la, lna;
	unsigned rv;
	int a;
	int rcmp;
	avl_iface(key_t) * key = pivot->key;

	p = tree->root;
	r = q = s = NULL;

	*pivot_ptr = NULL;

	rv = code_avl_ok;

	if (p) {
		s = p;
		t = NULL;
		found = 0;
		while (!found) {
			rcmp = avl_iface(key_compare)(key, p->key);

			if (rcmp == 0) { // (key == p->value.key) {
				found = FOUND_MATCH;
			}
			else {
				if (rcmp < 0) { // (key < p->value.key) {
				 	q = p->links[LEFT];
				 	if (!q) {
						found = FOUND_LEFT;
					}
				}
				else {
					q = p->links[RIGHT];
					if (!q) {
						found = FOUND_RIGHT;
					}
				}
			}

			if (!found) {
				if (q->ballance) {
					t = p;
					s = q;
				}
				p = q;
			}
		}

Это начало. И можно записать так (без обобщённых типов).

fun addinternal(tree avltree.ptr; pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) =
(
	var (p; q; r; s; t) pivot ptr;
	var (ok; found; la; lna; rv) unsigned;
	var (a; rcmp) int;
	var key avlkey.ptr = .pivot.key;
)

Точка нужна префиксная, потому что это очень частый use-case. Если представить
себе ядро, то там указазатель на указателе. Так же нужен специальный синтаксис
для указания на указатель, чтобы сложные конструкции читались однозначно:

	array(20) hash(string) int ptr

	array(20) hash(string) (int ptr)

	(array(20) hash(string) int).ptr

	array(20) hash(string) int.ptr

Ладно, к вопросу о штуках.

fun addinternal(tree avltree ptr; pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) =
(
	var (p; q; r; s; t) avlpivot.ptr;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(val) = .pivot.key;

	.p = .tree.root;
	.p = .q = .s = NULL;
	pivotptr = NULL;
)

Вот тебе и косяк. Почему в var и не-var различная семантика? Тогда уж должно
быть так

fun addinternal(.tree avltree; .pivot avlpivot; ..pivotptr avlpivot)

Или тогда уж прямым текстом:

fun addinternal(ptr tree avltree; ptr pivot avlpivot; ptr pivotptr avlpivot ptr)
= (
	ptr (p; q; r; s; t) avlpivot;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	ptr key avlkey = ptr pivot.key;
)

fun addinternal(.tree avltree; .pivot avlpivot; .pivotptr avlpivot.ptr) uint =
(
	var (.p; .q; .r; .s; .t) avlpivot;
	var (ok; found; la; lna; rv) uint;
	var (a; rcmp) int;
	val .key avlkey.val = .pivot.key;

	.p = .tree.root;
	.r = .q = .s = NULL;

	.pivotptr = NULL;

	rv = codeavlok;

	if(p)
	(
		.s = .p;
		.t = NULL;
		found = 0;

		for(!found)
		(
			rcmp = keycompare(key; .p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH
			)
			else
			(
				if(rcmp < 0)
				(
					.q = .p.links(LEFT);
		)
	)
)

Эх. В этом можно и запутаться за 5 секунд, что и произошло. Ок. И чего дальше?

fun addinternal(
	tree avltree.ptr;
	pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) uint rv =
(
	var (p; q; r; s; t) pivot.ptr;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(l) = pivot(l).key;

	val key avlkey.ptr(l) = pivot(1).key;

	p = tree(l).root;
	r = q = s = NULL;

	pivotptr(r) = NULL;

	if(p)
	(
		s = p;
		t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(key; p(l).key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				q = p(l).links(LEFT);
				if(!q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			q = p(0).links(RIGHT);
			q = p(l).links(RIGHT);
			if(!q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q(l).ballance)
			(
				t = p;
				s = q
			);
			p = q
		)
	)
)

У штуки может быть и другой смысл. Типа, указатель - это адрес, относительно
которого можно вычислять всякое. Почему бы не повычислять p(0)?

 	mm = get_task_mm(task);
	if (mm && mm != current->mm && !ptrace_may_access(task, mode)) {
			mmput(mm);
			mm = ERR_PTR(-EACCES);
	}
	mutex_unlock(&task->signal->cred_guard_mutex);

	mm = gettaskmm(task);
	if(mm && mm != current(0).mm && !ptracemayaccess(task; mode))
	(
		mmput(mm);
		mm = ERRPTR(-EACCES)
	);
	mutex.unlock(ref task(0).signal(0).credguardmutex);

	(ptr task(0).signal(0).credguardmutex).unlock();

Это могло бы и так выглядеть:

	(ptr task@.signal@.credGuardMutex).unlock();

	task:.signal:.credGuardMutex

Ладно. Ещё один вариант.

	(ptr task(0).signal(0).credGuardMutex).unlock();

Тут хитрые штуки, последняя проверка на сегодня.

	bool flush_delayed_work(struct delayed_work *dwork)
	{
		local_irq_disable();
		if (del_timer_sync(&dwork->timer))
			__queue_work(dwork->cpu,
					get_work_cwq(&dwork->work)->wq, &dwork->work);
		local_irq_enable();
		return flush_work(&dwork->work);
	}


	fun flushDelayedWork(dwork ptr delayedWork) bool =
	(
		localirq.disable();
		if(delTimerSync(ptr dwork(0).timer))
		(
			sys.queueWork(dwork(0).cpu; getworkcwq(ptr dwork(0).work)(0).wq; ptr dwork(0).work)
		);
		localirq.enable();
		return flushwork(ptr dwork(0).work);
	)

	fun flushdelayedwork(dwork ptr delayedwork) bool =
	(
		localirq.disable();
		if(deltimersync(ptr (dwork timer)))
		(
			sys.queuework(dwork cpu; getworkcwd(dwork work) wq; ptr (dwork work))
		);
		localirq.enable();
	)

Так. Нужно ещё проверить комбинации с точками.

if (mod->symtab[i].st_value <= addr
		&& mod->symtab[i].st_value > mod->symtab[best].st_value
		&& *(mod->strtab + mod->symtab[i].st_name) != '\0'
		&& !is_arm_mapping_symbol(mod->strtab + mod->symtab[i].st_name))
	best = i;

if(mod(0).symtab(i).stvalue <= addr
	&& mod(0).symtab[i].stvalue > mod(0).symtab[best].stvalue
	&& (mod(0).strtab + mod(0).symtab(i).stname)(0) != '\0'
	&& !isarmmappingsymbol(mod(0).strtab + mod->symtab[i].stname))
(
	best = i
)

if(val m mod.ref; val t (ptr symtab(i)).ref; pin =
	t.stvalue <= addr
	&& t.stvalue > m.symtab(best).stvalue
	&& (m.strtab + t.stname)(0) != '\0'
	&& !isarmmappingsymbol(m.strtab + t.stname))

if(val m mod.ref; pin
	 = m.symtab(i).stvalue <= addr
	&& m.symtab(i).stvalue > m.symtab(best).stvalue
	&& m.strtab(m.symtab(i).stname) != '\0'
	&& isARMMappingSymbol(m.strtab + m.symtab(i).stname))
(
	best = i
)

Какая-то не особо сахарная вата.

if(mod@.symtab(i).stvalue
	&& mod@.symtab(i).stvalue > mod@.symtab(best).stvalue
	&& (mod@.strtab + mod@.symtab(i).stname)@ = '\0'
	&& (mod@.strtab + mod@.symtab(i).stname).is(armmappingsymbol))


	x = --py@ + 1

	x = --py(0) + 1

	object@.firstMethodCall(a; @b; c)@.secondCall(1)@.nextCall(10);

	object.firstMethodCall(a; .b; c).secondCall(1).nextCall(10);

if(mod.symtab(i).stvalue
	&& mod.symtab(i).stvalue > mod.symtab(best).stvalue
	&& (.mod.strtab + mod.symtab(i).stname) = '\0'
	&& isARMMappingSymbol(.(.mod.strtab + mod.symtab(i).stname))

Ладно. Может, точка и не самый дурацкий вариант. Попробуем последить.


fun addinternal(
	tree avltree.ptr;
	pivot avlpivot.ptr; pivotptr avlpivot.ptr.ptr) uint rv =
(
	var (p; q; r; s; t) pivot.ptr;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey.ptr(l) = .pivot.key;

	.p = .tree.root;
	.r = .q = .s = NULL;

	pivotptr = NULL;

	if(.p)
	(
		.s = .p;
		.t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(.key; .p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				.q = .p.links(LEFT);
				if(!.q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			.q = .p.links(RIGHT);
			if(!.q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q.ballance)
			(
				.t = .p;
				.s = .q
			);
			.p = .q
		)
	)
)


Логика может быть такой, что всё является указателем. Это стиль JavaScript и это
не плохо. Плохо то... Или не плохо. Есть же концепция коробки. Будем называть её
клеткой, дабы было тематично

fun addinternal(tree avltree; pivot avlpivot; pivotptr cell(avlpivot)) uint rv =
(
	var (p; q; r; s; t) avlpivot;
	var (ok; found; la; lna) uint;
	var (a; rcmp) int;
	val key avlkey = pivot.key;

	p = tree.root;
	r = q = s = NULL;

	pivotptr.val = NULL;

	if(p)
	(
		s = p;
		t = NULL;
		found = 0;
		for(1)
		(
			rcmp = keycompare(key; p.key);

			if(rcmp == 0)
			(
				found = FOUNDMATCH;
				break
			);

			if(rcmp < 0)
			(
				q = p.links(LEFT);
				if(!q)
				(
					found = FOUNDLEFT;
					break
				)
			);

			q = p.links(RIGHT);
			if(!q)
			(
				found = FOUNDRIGHT;
				break
			);

			if(q.ballance)
			(
				t = p;
				s = q
			);
			p = q
		)
	)
)

						   Tue Nov 27 14:11:54 YEKT 2012

Так. Коллеги дали добро на такую трактовку указателей. Да будет так

						   Thu Nov 29 11:32:44 YEKT 2012

Очередная проблема для обдумывания такого свойства. Во-первых, слишком сложный
формат токенов, если на пути lex -> sntx ещё терпимо, то когда они записаны в
sntx -> engine, почти не читаются. Во-вторых, результат синтаксического разбора
надо бы уметь записывать для последующего использования. Это может потребоваться
и для специализации, и для шаблонов. Это всё должно записываться примерно в
таком виде:

	x + y * z

	.atom	a1 = x
	.atom	a2 = y
	.atom	a3 = z
	.add	e1 = a1		// всегда известно, что бинарные операторы 
	.mul	e2 = a2		// задаются через левый вектор
	.join	e3 = e2 a3
	.join	e4 = e1 e3

Но чтобы можно было отлаживать (показывать тот исходный текст, где это было
написано) или чтобы выдавать сообщения об ошибках, здесь должна быть информация
о позиции в тексте.

Сам файл с текстом может быть объявлен в каких-нибудь заголовках модуля или в
специальных записях библиотеки или ещё как-то, это пока не важно. Здесь же
должны быть указания на позицию в коде. Видимо, в виде пары: l.c (да, я
испытываю странную тягу к точке, и тут может быть любой другой символ):

	.atom(1.0)	a1 = 1.1.x // подсказки о длине символа и его типе
	.atom(0.4)	a2 = 1.1.y

l.c - это +l к предыдущей строке и +с к текущей позиции в строке. Так получится
немного сэкономить.

Ок. Исходя из этого надо упростить лексемы 

	l.c N.1 1 =
	l.c E.1
	l.c N.2 37 8.11.hello world

Для операторов достаточно указать один номер, а приоритет уже потом восстановить
из таблицы. Дополнительно, для проверки корректности и читаемости можно указать
строковое представление символа.

Ещё один вопрос о двоичном кодировании этих всех структур. Видимо, длина каждого
кода должна быть 16 байтов из такого расчёта:

	2 байта	- основная инструкция
	2 байта	- уточнение типа (векторные форматы тоже надо учитывать)
	2 байта	- +l (бывают длинные комментарии)
	2 байта - +c (длинные лексемы)
	4 байта	- ссылка на первый операнд (могут быть длинные зависимости)
	4 байта	- ссылка на второй

Это всё очень длинно. На первое время сойдёт, но потом надо что-то вроде utf-8
будет применять.

Ок. Time to refine the spec

						    Tue Jan 1 21:00:03 YEKT 2013

Так. Нужна возможность писать примерно так:

	operator (a int + b int) int = core "add.4i t = a b; pin t"

Нужно определится, что такое a и b. По идее, в c-выражении это свободные
переменные и их надо к чему-то привязать. Как мы знаем, это интерпретация в виде
суммы произведений доменов (sum-of-products interpertation). То есть, как бы,
функция сопоставления (match) должна выбрать соответствующий синтаксический
домен, привязать переменные и оценить значения.

Ok, это может работать. Но возникает вопрос: как определить выражения для
переменных? Там же надо иметь какую-нибудь цепочку вроде:

	addr	p = a;
	rd.4i	v = p;
	cnst.4i	c = -1;
	add.4i	t = v c;
	pin	t

						   Wed Jan 23 22:50:13 YEKT 2013

Так. Есть определённая философская проблема. Что такое метка? Метка - это нечто,
что связывает два участка кода в одно целое. Это некая точка в геометрии кода
(есть у меня такое необоснованное ощущение). Ок. Допустим.

Ладно. 1. Хватает всего двух видов ветвлений: условное ветвление и ветвление с
link-ом. В принципе, это может быть одна операция, но с разным количеством
полей. Типа:

	br C : target : link;

И это достаточно сложно парсить. Ничто не мешает при этом, однако иметь
возможность составлять списки:

	label	lx = l.1;
	label	ly = l.2;
	join	labels = lx : ly;

						   Sun Jan 27 12:34:57 YEKT 2013

Ладно. Нужны списки - это определённо. Но надо что-то делать с метками. Путь,
который просматривается примерно такой:

	- метка в текущем выражении уникальна;

	- но сами выражения являются λ-выражениями, поэтому они могут
	  применяться одно к другому; это позволит вставлять в нужные места
	  новые подвыражения;

	- некоторые метки нужно запоминать для goto (или, возможно, для switch
	  case или возвратов из функций) и это надо делать явно.

Примерно так. Ещё имеет смысл всё же разделить элементы выражений на ядерные, и
обычные.

	k.pin
	k.mark
	k.link
	k.br
	k.brl

	и т.д. по мере надобности

Имеет смысл иметь два режима подстановки выражений в другие выражения:
постановка готового выражения или подстановка с компиляцией. Тогда поток
синтаксических конструкций для каких-нибудь for-ов или if-ов не записывать.
Синтаксис записывать всё-равно придётся для шаблонных функций или чего-нибудь
такого.

Но размышлять надо в сторону того, чтобы отказаться от такой записи. Но,
наверное, это невозможно.

						   Wed Feb 27 08:34:18 YEKT 2013

Итак. Оно, конечно, идеологически понятно, что хорошо бы иметь обобщённые
функции (или аналог). То есть, когда речь заходит о какой-нибудь арифметической
операции, то это некий ArtithOp, который выражается как:

	link	t = P.0;
	link	a = P.1;
	link	b = P.2;
	op.t	r = a : b;
	pin	r

Этот самый arithop вполне можно за-lookup-ить по какому-нибудь атому, а потом
применить.

Но для lookup-а по общей логике нужен специальный атом. Следовательно, можно всё
ещё существенней упростить.

						    Wed Mar 6 18:09:23 YEKT 2013

Так. Хьюстон, у нас проблема. Не понятен основной механизм основного цикла.
Понятно, что это должна быть некоторая рекурсия (что ж ещё?), но не понятно,
какая именно.

На вход мы получаем несколько видов выражений:

	A	atom
	B
	L	atom
	E b
	E l

Так. Ну. Хорошо. Чего look-up-им-то? По, идее. У нас есть текущее выражение на
вершине стека (условно, оно может быть просто текущим). И мы получаем нечто
вроде:

	LiME Current -> "L" -> atom -> 

Так. ПОхоже, можно сделать некий динамический вариант match. Примерно по
технологиям RiDE. Попробую уточнить.

						    Sat Mar 9 23:29:54 YEKT 2013

Так. Сколько у нас всего link-ов, чтобы заработали типы? И в какой они форме
должны быть? Хых. Похоже,

	link x = A.N

Это не самый удобный формат. Потому что смысл A становится понятным только после
чтения «.». Как-то это не правильно. Поэтому лучше всю типизацию link-узлов
вынести в suffix.

	link.suffix

Таким образом у нас выходит:

	link.AN	x = N
	link.TN x = N
	link.A	x = hint.size."bytes"
	link.T	x = exp;
	link.B	x = exp;
	link	x = y : z;
	link.N	x = N

	L.AN	x = N;
	L.TN	x = N;
	L.A	x = hint.size."bytes"
	L.T	x = exp
	L.B	x = exp;
	L	x = y : z;
	L.I

Так. Ещё нужны обязательно Pin, Symbol, Const. Ладно. Но ещё нужна и Soma. Можно
ли назвать Symbol Var-ом? Soma. Как-то глупо. Назовём это rule. Назовём это
глупо - soma.

						   Sun Mar 10 21:34:19 YEKT 2013

Ладно. Можно называть нормально - это всё похоже на форму, поэтому Form. Пока не
очень понятно, как представлять списки. Почитаем классику... Классика - это:

	cons
	head
	tail
	empty

Значит, надо:
	l.na	x = N;
	l.nt	x = N;
	l.la	x = hint.size."bytes";
	l.lt	x = exp;
	l	z = x : y;
	l.h	x = y;
	l.t	z = y;

Ещё нужно как-то обозначать пустой список. С которого надо начинать
конструирование. И как его обозначить? Пусть будет

	l	x;

Ладно. Сойдёт. Но есть ещё одна проблема. Как представлять списки внутри движка?
Кольцевой список подойдёт? Подойдёт, чего бы и нет? append тоже сработает.
Вместо NULL пишем то, что нужно, получается append.

						   Mon Mar 11 01:08:51 YEKT 2013

Нет. Это слишком уж громоздкий подход. При этом, refal существует. Посмотрим ещё
раз. Ок. Refal подойдёт. Только у него pattern-matching совсем уж странный. Но
нам пока до такого далеко.

						   Fri Mar 15 13:04:30 YEKT 2013

Так. Небольшая проблема всё-таки с логикой. Форма это что? Можно ли считать, что
это вызов функции в контексте? НууУу... В принципе, наверное. Только мы не тащим
контекст с собой, в качестве аргумента. А ещё... Ещё же нет возврата. То есть,
не происходит нечто вроде:

	fn F0(c Context; l1 Leg1; l2 Leg2; ...) = (
		F1 = (l1; l2; l3; ...); // ну, типа, зависят.
		F2 = (l1; l2; l3; ...);

		c.append(F1; F2);
		evaluate(c);
	)

явного evaluate у нас нету. По идее, вроде как. Эквивалент, скорее всего, был бы
такой:

	fn form(c Context; l Legs; f Continue) = (
		fn f1 (c Context; l Legs; f Continue) = ( ... );
		fn f2 (c Context; l Legs; f Continue) = ( ... );

		...

		c.append(legs1 = f1; legs2 = f2);
		eval(c; f)
	)

Примерно нечто такое. Ну, да. И что? А ничего. Можно просто сказать потом: вот
вам библиотека для Си. По-прежнему вопрос: не усложняем ли чрезмерно? Но тут всё
ещё остаётся программируемый match-ing. То есть, идея всё-равно в том, что вызов
функций идёт не напрямую, а через eval. Это может быть ценно.

						   Sun Mar 17 15:03:06 YEKT 2013

Похоже, Y-узел не особо нужен. Вопрос об узле, выбирающем вариант. В принципе,
возможно это сделать через несколько форм:

	A.l	T = 00.4."True";
	A.l	F = 00.5."False"ш;
	A.l	A = 10.0."";		// Атом для поиска типа
	T.l	A = 10.0.""

	F.b	fe = T : A;		// форма на случай того, что символ
					// найден
	...
	F.e

	F.b	fn = F : A;		// символ не найден

	L.s	x = someatom;		// поиск символа. Возвращает True или
					// False
	
	F.p	fn;
	F.p	fe;
	P	x : (A : someatom);

Примерно так.

Скорее всего, Y-ки всегда будут использоваться в первой форме, которая
подставляется по синтаксису. Но это можно делать и не явно, и не пудрить мозг
пользователю. Ведь, фактически, разветвление на формы нужно, когда возникает
неопределённость в дальнейшем выводе. Пока неопределённости нет, можно обходится
и одной формой. А то, что надо читать Y - вполне определено. Не определено то, в
каком окружении это надо читать. А это окружение вполне может определённо
построить первая синтаксическая форма.

Алгоритм может быть такой:

	- встретили синтаксис X ..., значит надо найти форму и применить
	  её (X - это A, B, L, U);

	- встретили синтаксис E X ..., значит надо найти форму,
	  применить, а потом сливать с предыдущим контекстом вывода (X -
	  это l, u, b) и выводить цель.

Должно сработать.

						   Thu Mar 21 12:32:05 YEKT 2013

Ладно. Новый вариант выражений будет выглядеть примерно так:

	F f = (
		// Первый элемент в списке - список из входов
		((A.l 00.1."V"; T (A.l 00.10."Expression")));

		// F.i - это список, и это первый элемент в L.n
		L.n a = (F.i; 1; 1);
		L.n t = (F.i; 0; 1);

		F.o (A.l 00.1."V"; (a; t))
	);


						   Fri Mar 22 18:01:22 YEKT 2013

Ладно, теперь есть вопрос о том, что такое списки. Списки у нас - это нечто из
узлов, на самом деле. Когда мы грузим линейный участок, то это DAG из структур
вида:

	typedef struct ListStruct {
		union {
			unsigned atom;
			unsigned number;
//			unsigned special;
			struct ListStruct * list;
			struct {
				unsigned name;
				unsigned suffix;
				struct ListStruct * references;
			} node;
		} u;
		unsigned code;
		unsigned atline;
		struct ListStruct * next;
	} List;

Некоторые узлы могут быть числами, специальными узлами (например, T, при разборе
L.n) или атомами.

Хотя, вроде, нет. special не нужен. Потому что это просто атом, обрабатываемый
особо. Значит, остаётся только atom или number. По идее, это одно и то же, но
для выразительности пока оставим.

Ок. Вроде, ок.

Ещё нужно поле list, потому что в списке могут быть подсписки. Всё такое.

						   Sat Mar 23 10:54:59 YEKT 2013

Ошибка вот в чём. Списки - это отдельно, узлы - это отдельно. Списки должны
состоять из (это или, в каждом узле нечто одно из):

	- атомов;
	- типов;
	- чисел;
	- ссылок на узлы;
	- подсписков.

Атомы и типы должны быть даны своими номерами. Узлы должны иметь вид:

	- код;
	- суффикс;
	- список ссылок;
	- счётчик ссылок.

Загрузка должна проходить в две стадии (скорее всего, возможно их можно
объединить, но пока мы не оптимизируем).

1.	Обход записи списка в глубину с упорядочиванием таким образом узлов. При
	этом, атомы и типы имеет смысл обработать на общих основаниях и сделать
	из них узлы.

2.	Подстройка списка, чтобы вместо различных lookup операций по таблицам
	стояли определённые конкретные номера элементов. Нам критично это прежде
	всего для атомов и типов, потому что мы по этим объектам будем
	производить всякие разные поиски. Поэтому они должны быть в «нормальной»
	форме, в которой это всё сводится к списку из номеров атомов и номеров
	типов.

Ок. Переигрываем. Менее эффективное, но более удобное в конструировании решение.

Элемент списка - это одно из:

	- ссылка на узел;
	- ссылка на подсписок (начто в скобках);

Узел - это

	- код;
	- суффикс;
	- одно из:
		- номер (это может быть номер атома, типа, или просто число;
		  определяется кодом и суффиксом);
		- список источников (ссылок на другие узлы; список
		  структурированный);
	- число ссылок на данный узел (для сборки мусора после некоторых
	  трансформаций).

Будем в угоду однообразности поступать так. Сами узлы не будут содержать ссылок
друг на дружку, как список. Просто сделаем внешний список из узлов.

Свободные узлы запишем в список свободных узлов, в виде такого же списка, то
есть, из элементов списка, ссылающихся на узлы.

Вот такая, блин, радость. Преимущество в том, что код станет более однообразным.
Потери в производительности из-за дополнительного уровня косвенных ссылок. Но
это они дают дополнительную гибкость. Ок... Поехали.

Так. Переигрываем немного обратно. Потому что хочется в ходе оценки графа узлов
иметь такие же списки, которые задают атомы или типы. А там просто номера.
Можно, конечно, сделать таблицы атомов или типов, состоящими из узлов, но это
усложнение в двух местах.

Так как у нас списки всё-равно в два этапа загружаются: сырая загрузка и оценка
по атомам-типам-числам, то лучше эту трансформацию оставить здесь.


						   Sun Mar 24 01:31:52 YEKT 2013

Что-то у меня сегодня прямо праздник тупости какой-то. Итак. Кольцевые списки -
это списки, в которых есть один указатель. Если этот указатель на начало, то,
вставлять сложно новый элемент, ибо, это же надо проматывать весь список до
конца. Так? Так. И в примерах в интернете так.

Поэтому, это должен быть указатель на конец. Указатель на начало тогда
получается как ptr->link.

						   Sun Mar 24 09:53:34 YEKT 2013

Так. Надо менять интерфейс. Чтобы можно было вызывать в каком-то контексте
чтение списка. Контекст - это какой-то набор связанных с узлами указателей.
Поэтому делаем так:

	loadrawlist(FILE *, AtomTable *, const List *const names)

Имена - это список из таблицы атомов и массива ссылок на узлы, которые
обозначены этими атомами (атомами, стоящими после =).

names имеет смысл явно вынести в интерфейс, потому что: ну а вдруг? Append
должен уметь работать с NULL-евым списком вначале.

Так. Ещё одно замечание. В List мы добавим ссылки на окружения. Окружения будут
универсальными с поиском по спискам из типов и атомов. Поиск по атому - это то
же самое, что и поиск по списку из одного атома. Так? Так. Next.

В окружениях может быть разное, поэтому кроме, собственно массива из списков и
индекса у нас должен быть массив из item-ом. Где каждый item - это структура с
объединением разных указателей.

Возможно, имеет смысл это назвать Binding.

Ещё надо сделать push для массивов, потому что это частая операция. И постоянно
exporesize-ить вручную смысла нет.

						   Tue Mar 26 16:16:19 YEKT 2013

Так. Надо подкорректировать несколько опять формат списка. Суффиксы - это плохая
идея, потому что если их использовать и для ссылок на типы, и для каких-то
уточнений в инструкциях, получиться слишком много if-ов при анализе.

Поэтому, новый формат примерно такой:

	F f = ((AL 00.1."A"; TL (AL 10.0.""); (
		AL	T = (00.4."True");
		AL	F = (00.5."False");
		LN	a = (FI; 1; 0);

		F ft = ((T; a); (
			LN	a = (F.i; 1; 1);
			SL	s = a;
			FO	(s; TL (AL (00.7."Symbol")))
		));

		F ff = ((F : a); (
			LN	(FI; 1; 1);
			TL	f4 = (AL (00.1."F"); AL (00.1."4"));
			S	s = (f4; a);
			FO	(s; TL (AL (00.7."Symbol)))
		));

		FP	(ff);
		FP	(ft);

		FO	((SE (a)); a);

		TL	ts = (AL (00.6."Symbol"));

		F fs = ((ts); (
			LN	s = (FI; 1; 0);
			ST	t = s;

			TL	p4 = (AL ((0.0."P")));

			addr	x = (p4; s);
			rd	x = (t; s);
		))
	));

					     FIXME Tue Mar 26 23:51:02 YEKT 2013

Текущий heapsort не универсально организован. index должен быть именно индексом,
то есть, не ссылаться на ключи, а хранить номера записей в массиве. Потому что
иначе достаточно универсально не выйдет сделать.

Сейчас индекс - это массив указателей с предположением о том, что в самом ключе
записана позиция элемента в некотором массиве (atom содержит id). Но для списков
это не так. И глупо делать это так, потому что в каждый элемент списка id
добавлять что ли?

Поэтому index должен быть номерами записей в массиве. Значит, интерфейс к
сортировке и функции сравнения поменяется:

	heapsort(unsigned *const index, const void *const data, L, M);
	cmp(const void *const data, const unsigned i, const unsigned j)

В такой постановке можно в атом тогда не записывать его идентификатор.

					     FIXME Wed Mar 27 08:21:02 YEKT 2013

Так. Можно воспользоваться пока тем, что есть. В Binding можно добавть id, но
это не лучший вариант.

С типами можно порешить так: а пусть программист сам устраивает преобразование к
более общему типу (который является суммой). Тогда все типы будут конкретными.
Это плюс.

Минус в том, что надо будет как-то извлечь информацию обратно. Ну. Конкретный
тип может быть передан параметром. Или может быть передана цепочка трансформаций
типа. В общем, есть варианты. С цепочкой - это хорошо, кстати. Получиться, что
будет задана некая цепь в частичном порядке типов, и это дополнительная
информация. Хм... // Тут надо задуматься о более общей постановке. Но потом.


						   Wed Mar 27 23:58:10 YEKT 2013

Да нет же, блин! Не выйдет так. realloc опять будет портить все ссылки. Надо
переписывать heapsort и менять структуру атомов немного.

						    Sat Apr 6 10:40:59 YEKT 2013

Так. Надо понять ещё раз, какой формат списков должен быть.

	fs = F((ts) (
		s = LN(FI 1 0)
		t = ST(s)
	)

Ладно.

	fs = F((ts); (
		s	= LN(FI; 1; 0);
		t	= ST(s);
		p4	= TL(AL(0.0."P));
	)

Неа. Лучше сразу видеть, что за узел. Ок. Утверждаем пока это:

	F fs = ((ts); (
		LN	s = (FI; 1; 0);
		ST	t = (s);
		TL	p4 = (AL 0.1."P");

		addr	x = (p4; s);
		rd	x = (t; s)
	)

Кстати, действительно, совсем не понятно, что такое ST. Нужны вменяемые имена.

						    Sat Apr 6 19:55:55 YEKT 2013

Так. Следующий вопрос: как же таки загружать списки более общим методом? По
идее, примерно так:

1.	Надо создать массив с реакциями на чтение определённых узлов. Для
	определения, можно использовать массив recode - из unsigned-ов. Примерно
	с такой логикой:

		a = loadtoken(...);
		n = lookup(recode, a);

		if(n == -1) { ERR(...); }

		n - это некий номер для чего-нибудь

2.	Для этого n должна существовать функция для обработки. В которую нужно
	передать, допустим, FILE * и void * со всякими разными параметрами.

Тогда loadrawdag получается сложной:

	loadrawdag(
		Universe,
		UserAtomsRecode,
		KeywordsRecode,
		KeyFunctions,
		FILE *
	)

Recode вполне можно назвать map. Потому что есть прямое и обратное отображение.
Интерфейс такой:

	Array makemap(unsigned code);
	void freemap(void);

	unsigned map(unsigned val); 
	unsigned direct(unsigned x);
	unsigned reverse(unsigned y);

Возможно. Наш Array - это никакой не Array, а вообще Map и есть. Поэтому, имеет
смысл (для вероятного будущего) обозвать это всё uimap.

						    Sun Apr 7 21:22:10 YEKT 2013

В новой постановке ядерного языка надо как-то различать узлы и метки. Например,
когда написано:

	ANum FIn = 01.2."34";
	FIn

FIn - это что? Ссылка на узел, или указание на входы формы?

						   Wed Apr 24 10:17:41 YEKT 2013

У нас проблема со списками, с fork/free. Вопрос в том, должны ли они уметь
удаляться вместе со своим содержимым и должны ли уметь от-fork-иваться с
копированием содержимого. Проблема в данном случае с узлами. Если их fork-ать
всегда, то получится каша, потому что, ведь, речь идёт о DAG-ах, а не о
несвязанных узлах.

Можно бы было сделать (чтобы вообще со ссылками не связываться в списках)
какие-нибудь массивы узлов, а списки бы тогда содержали только число - номер
узла в этом массиве. И тогда можно было бы свободно оперировать списками, зная,
что все узлы и так висят в массиве.

Но это плохой подход. Потому что, возникнут проблемы со сборкой общего dag-а из
более мелких: как сшивать два таким образом представленных графа? Перенумерация
всякая понадобится. Можно так сделать, но это сложный алгоритм.

Поэтому, видимо, придётся делать так: forklist и freelist - это специальные
функции для списков. Необходимые при сборке мусора или конструирования списков в
'L-узлах. Они не должны трогать узлы.

Для dag-ов же нужны специальные функции:

	forkdag(const List *const dag);
	freedag(List *const dag);

Может понадобится ещё и клонирование узла (тут возникает вопрос, со списком?)

	forknode(const Node *const n);

Но это потом. Пока, вроде, хватает того, что есть. Логику списочную менять не
будем.

						   Wed Apr 24 15:14:02 YEKT 2013

Ещё одна проблема со списками. Вообще, такое ощущение, что конструировать списки
по одному элементу может быть особо не удобно. Более того, просматривать его по
одному элементу тоже не особо удобно. Иногда нам нужно знать, какая конфигурация
элементов в списке: верно ли что второй и третий элемент списка - ссылки на
узлы, а первый - номер типа. И всякое такое.

Если это делать так:

	elat(list, 1)->code == TYPE && elat(list, 2) == NODE 

Ну, в общем, много лишних слов. Если бы была возможность всё сбросить в массив,
то было бы удобнее:

	Ref refs[3];
	if(writerefs(list, refs, 3) != 0) {	// 0 означает, что список был
		ERR("wrong format");		// ровно из 3-ёх элементов
	}
	
	if(refs[1].code == TYPE && refs[1].code == NODE && refs[2] == NODE) {}
	else { ERR("wrong format"); }

Соответственно, readresfs:

	readrefs(MKR(
		refnode(T),
		refnode(newnode()),
		refnode(newnode())
	));

Это проще, чем:

	append(newlist(refnode(T)), append(newlist(refnode(newnode())), ...))


						   Thu Apr 25 09:25:28 YEKT 2013

Так. Разумно сделать newnode в стиле LCC, чтобы сразу и sources инициировать, и
code. Чтобы писать лаконичнее:

	f = newnode(ATOM, RL(refnum(ATOM, 1));
	s4 = newnode(ATOM, RL(refnum(ATOM, 2));
	t = newnode(TYPE, RL(refnode(f), refnode(s4)));

	return RL(refnode(f), refnode(s4), refnode(t));


						   Fri Apr 26 19:29:46 YEKT 2013

Уточнение процесса разбора выражения. Видимо, имеет смысл использовать CSP для
наглядности (символы показаны самими символами или регулярными выражениями,
процессы обозначения большими буквами. ->, :, { }, | - это символы для описания
CSP).

	END	- конец разбора
	LRD	- Load Raw Dag
	CORE	- видимо, основной цикл разбора
	CE	- CORE or END

События
	num	- число
	ref	- ссылка на другой узел

Непонятное в рамках CSP
	ENV(P)	- выполнить P в новом окружении

	LRD: ( -> ENV(CORE)

	CORE: {
		'		-> NODE		-> CE |
		(		-> ENV(CORE)	-> CE |
		[0-9]+		-> num		-> CE |
		[0-9a-zA-Z]+	-> ref		-> CE |
		)		-> END
	}
	
	CE: { ; -> CORE | ) -> END }

	NODE: [0-9A-Za-z]+ -> CODE -> {
		[0-9A-Za-z]+ -> NAME -> = -> LDR	|
		( -> CORE
	}

Так. Надо постараться обойтись хвостовой рекурсией, поэтому loadrawdag должен
принимать пару аргументов. Контекст и список-аккумулятор, к которому будет
дописывать свой список эта самая loadrawdag, Соответственно, все другие процессы
тоже должны аккумулировать.

Так. Очередная тонкость. Интерфейс у всех этих последовательных процессов должен
быть другой.

1.	Контекст разбора - это некоторая константа, и лучше её выделить
	отдельно.

2.	Не константами являются окружения и списки. Их тоже лучше выделить
	отдельно в аргументах.

3.	Сама loadrawdag вполне может вернуть всего лишь список узлов, но
	промежуточные процессы чтения должны вести два списка: список узлов и
	текущий список ссылок. Первый - просто линейный список узлов. Второй -
	структурированный список ссылок.

Кроме интерфейса. Нужно обрабатывать скобки - «(» и «)» - на одном уровне
рекурсии, чтобы контролировать их соответствие. Хотя... Может, это и не
проблема. Фактически, ведь, это всё будет обеспечиваться структурой рекурсии.
Ок. Сначала такой вариант. Если не сработает, надо думать.

Так. Ещё одна запись пропала. Вопрос о том, как накапливать списки. Потому что,
должна быть разница между списком всех узлов dag-а и текущим накапливаемым
списком ссылок.

Видимо, loadrawdag не особо должен возвращать два списка. Раз это загрузка
dag-а, то результатом должен быть просто список узлов. Но внутренние функции
должны протаскивать (thread) эти два списка и дописывать к ним узлы. Поэтому,
интерфейс у них такой примерно:

	LoadCurrent fn(LoadContext *ctx, List *env, List *nodes, List *refs);

nodes - протаскиваемый список узлов. refs - текущий, конструируемый список
ссылок.

							     2013-04-30 08:38:54

Так. Значит, схема выше не особо хороша. Она может допускать цепочки:

	x; )

Которые не имеют смысла. Поэтому, надо выделить ещё один процесс в нашей
CSP-схеме: LIST, который и будет нести ответственность за открытие-закрытие
скобок.

	LDR: «(» -> LIST

	LIST: (
		x: {«(» «[0-9]+» «[A-Za-z][A-Za-z0-9]+» «'»}
			-> rewrind(x); ENV(CORE) |
		«)»	-> END
	)

	CORE: (
		«(»			-> LIST			|
		«[0-9]+»		-> ( num -> CE )	|
		«[A-Za-z][A-Za-z0-9]+»	-> ( ref -> CE )	|
		«'»			-> ( NODE -> CE )
	)

	CE: (
		«;»	-> CORE	|
		«)»	-> END
	)

	NODE: «[A-Za-z][A-Za-z0-9]+» -> CODE -> (
		«[A-Za-z][A-Za-z0-9]+»	-> ( name -> «=» -> «(» -> LIST ) |
		«(»			-> LIST
	)

	NODE: [0-9A-Za-z]+ -> CODE -> {
		[0-9A-Za-z]+ -> NAME -> = -> LDR	|
		( -> CORE
	}

							     2013-05-11 19:54:32

Ладно. Вопрос в том, надо ли биндить метку при встрече. И если биндить, то к
чему? Надо биндить, чтобы косяков избежать. И чтобы косяков избежать, надо
биндить к NULL. А потом уже заполнять эту метку. Ух.

							     2013-05-16 15:45:47

Так. Нам нужно уметь собирать мусор на различных графах. Алгоритм сборки
примерно такой. Ну. Это mark-and-sweep должен быть классический, но чтобы не
возиться с дополнительными полями в узлах и использовать те структуры данных,
которые уже есть, будем делать так:

1.	Бежим по списку узлов. Если встречаем корневой узел, заносим его в
	ptrmap какую-нибудь.

2.	Если встречаем не-корневой узел, ничего не делаем.

Это инициализация корней. Потом надо распространить волну

1.	Снова идём по списку узлов, в каждом узле, который есть в ptrmap
	проходим по списку атрибутов и добавляем каждый узел в ptrmap.

Это стадия разметки

1.	Снова идём по списку узлов. Если узел в ptrmap, складываем эту ссылку в
	новый список. Можно просто откусывать узлы и прилеплять их в новый
	список.

2.	Если нет, то 

							     2013-05-17 14:26:04

Вопрос с под-dag-ами. Вроде, есть подграфы, куда надо заходить и есть те, в
которые не надо. Вопрос в том, как это обрабатывать? По идее, речь здесь идёт о
формах. В формах не нужно раньше времени собирать мусор или, допустим, оценивать
типы. А кое-где и нужно это делать. Например, в блоках. Вопрос: как
регулировать?

Можно ввести два контроля? Типа, subdags, subignore. В пересечение не ходим. Ну,
видимо, так? В формах можно собирать атомы и всё такое прочее. ОК. Пока так.

							     2013-05-17 17:43:42

Хьюстон, у нас опять проблема. Вопрос в отношениях между сборкой мусора и
dag-ами.

Q:	Должны ли мы собирать узлы с dag-ами в атрибутах?

A:	Вроде, причин не собирать нет. Если какой-то узел собирается, значит, на
	него нет ссылок из корней. А раз так, им и не воспользоваться.

	Если граф был выкинут в контекст свёртки, то он уже туда выкинут.
	Скопирован и вообще всё неплохо у этого графа.

В чём тогда процедура удаления dag-а? Это просто: почистить каждый узел. Узел
надо чистить так: удаляем список атрибутов, освобождаем узел. Это процедура
killnode. Наверное, она внутренняя. А снаружи вполне сойдёт удаление dag-а из
одного узла.

Q:	Тогда, наверное, возникает вопрос о том, где принимать решение о том,
	как удалять подграфы. Если удаляемый узел - это узел с графом, то?

A:	Ну. По идее, решение же заключается в том, чтобы удалить узел. Удаление
	с графом, вроде как постулировано. Следовательно... Решение надо
	принимать в процедуре freedag. И ей же нужны метки подузлов.

Ещё один вопрос: упрощение интерфейса к keymap. У нас уже есть ES. Надо
пользоваться.

							     2013-05-20 15:59:25
Так. Интерфейс к gcnode примерно такой:

	gcnode(dag, keymap(ES("F", "R")), keymap(ES("R")), keymap("A"));

Ну и нормально, наверное.

Нет. Похоже, не особо рационально. Вызов keymap сложный. И всё-равно нужны
переменные. Поэтому, можно оставить указатели.

							     2013-05-20 22:34:57

Так. Вопрос ещё в том, а на кой это в сборке мусора? Сборка мусора она на то и
сборка, чтобы собирать всё. Нужно только знать, где подграфы, в которые
спускаться. При этом спускаться надо в процедуре rebuild. В которой будет
freedag. В котором и должна быть рекурсия... Эмс.

Как-то замороченно получается. Хотя. Нет. Ведь, то что удаляется, то удаляется.
А то что оставляется, то собирается. И это надо делать после стадий анализа.
Значит, сейчас freedag

							     2013-05-27 20:58:15

Менее наивный и более универсальный вариант dumpdag:

1.	Собрать узлы.

							     2013-05-30 13:52:11

Так. Мне вот что не нравится. Во всех этих контекстах загрузки/выгрузки. state
задумывалась как состояние для сallback-ов: загрузили специальный узел, вызвали
что-нибудь такое этакое. Но... Вроде как. Наверное...

Это будет относительно плохим решением, потому что управлять из callback-ов
памятью (типа, иначе, зачем они нужны? Чтобы последовательно всё подгружать).
Это редкостное «удовольствие». Тогда что? В общем случае - ничего. Похоже, что
так.

Но это редкостное удовольствие можно, вероятно, как-то оптимизировать. Но,
видимо, в следующих версиях. Пока state не нужно. И не нужно с ним
заморачиваться так сильно. И FILE *, видимо, лучше передавать аргументом. Эх...
Опять нам предстоит небольшой rewrite на пути к доброму, умному, вечном.

Так. Логика, значит, такая. Чтобы не идти по пути «надо, видимо, два
контекста», FILE * придётся вынести в аргументы. Да, придётся его передавать
постоянно. Жаба давит, но смысл в том, чтобы контекст загрузки/выгрузки
создавать один раз. Кроме того, FILE * может и поменяться...

Так. Короче. Жаба задавила окончательно. Будет два контекста.

Но при этом параметр - DumpCurrent в DumpAction всё-равно нужен. В итоге,
FILE * остаётся в структуре.

							     2013-06-14 09:42:15

Ок. Видимо, делать для атомов compatoms и decompatoms особого смысла нет. Атомы
- они же как числа. Проще немного изменить процесс загрузки. Добавить нечто
вроде:

	.TNew x = ('00.1."F"; '00.1."4");

Тогда процесс загрузки будет выглядеть примерно так:

	LDR: «(» -> LIST;

	LIST:
	(
		  x: {«(» «[0-9]+» «[A-Za-z][A-Za-z0-9]+» «'»}
			-> rewrind(x); ENV(CORE)
		| «)»	-> END
	);

	CORE:
	(
		  «(»				-> LIST
		| «[0-9]+»			-> (num -> CE)
		| «[A-Za-z][A-Za-z0-9]+»	-> (ref -> CE)
		| «'»				-> (atom -> CE)
		| «.»				-> (NODE -> CE)
	);

	CE:
	(
		  «;»	-> CORE
		| «)»	-> END
	);

	NODE: «[A-Za-z][A-Za-z0-9]+» -> CODE ->
	(
		  «[A-Za-z][A-Za-z0-9]+»	-> (name -> «=» -> «(» -> LIST)
		| «(»				-> LIST
	)

							     2013-06-18 16:30:10

Так. В общем. Если нам не нужны специальные процедуры загрузки для атомов, то
можно обойтись без этих всех ключевых штук. Возможно, имеет смысл отказаться и
от keyonly-загрузки. Потому что формы же будут добавляться в область видимости
после специального вызова: compforms.

Для загрузки и выгрузки тогда нужны такие параметры.

Загрузка:

	file, universe, dagmap

Выгрузка:

	file, universe, dagmap

Вполне приемлемо без дополнительных аргументов. Разве только надо будет
инициализаторы для dagmap-ов написать. Ок. Работаем

							     2013-06-24 12:38:32

Вроде, графы на каждом шаге процесса должны быть замкнутыми относительно самих
себя. Сцепляться они должны в процессе интерпретации через узлы FOut и FIn. Ну.
Клёва. Что дальше? Значит, forkdag должен быть написан в этих предположениях.
Возможно, они потом поменяются. Но пока пусть будет так.

Примерный алгоритм:

1.	Собрать в ptrmap M все узлы.

2.	Выделить массив N подходящего размера под новые узлы. Можно прямо в
	клон узла n будет находится по адресу N[ptrreverse(ptrmap, n)].

3.	Идём по ptrmap-е. Можем встретить узел с подграфом или обычный узел.

	3.1.	Если узел с подграфом, то всё просто
		
		n = ptrdirect(M, i);
		N[i] = newnode(n->verb, forkdag(n->u.attributes, dagmap));
	
	3.2.	Если узел со списокм атрибутов, то всё сложнее:

		n = ptrdirect(M, i);
		N[i] = newnode(n->verb,transforklist(n->u.attributes, i, M, N));

4.	Собрать массив узлов в список.

Тут вся соль и сложность в transforklist, которая должна идти по списку
аттрибутов, копировать его, сохраняя структуру и менять ссылки местами.

Этот самый transforklist(list, bound, M, N)  должен вести себя примерно так.

1.	Если bound = 0, то это должен быть обычный forklist. Bound должно
	говорить о том, сколько узлов находится в обычном массиве N: от 0 до
	bound.

Эта гадость не сработает для первого узла. Потому что, для N[0] bound будет
равен нулю. А transforklist в этом случае должна ругаться на любые ссылки вне M,
а не просто вести себя как forklist.

Что делать? Флаг придумать? Или какие-нибудь NULL/не-NULL?

	transforklist(attr, bound, M, N);

Наверное, NULL и не-NULL. transforklist(attr, bound, NULL, NULL) =
forklist(attr). Если карты (M) нет, то есть, если она NULL, то это и должно
означать, что делаем просто forklist. Это ветвление должно быть в forkitem в
случае NODE.

							     2013-06-25 15:16:49

Так. Следующее, что понадобится - это evallists, которая должна трансформировать
ссылки на узлы вида

	.L x = (a; b; c);

В списки, указанные справа. Это, значит, такой вот конструктор списков
(возможно, немного странный; и, точно, не шибко эффективный). Но нужна
возможность подстановки для формирования больших списков из маленьких:

	.L x = (a; b);
	.L y = (c);
	.F (x; y)

В последнем узле нужно получить список вида

	.F (a; b; c);

Это получается вроде как передача аргументов по значению.

Другой тип узлов - это деконструкторы. Нужно уметь ссылаться на элементы
списка. Формат должен быть такой примерно (Nth - от слова энный):

	.LNth	 z = (x; 1; 2; 3; (4; '00.1."H"));

Тут важно, чтобы x было ссылкой на списочный узел (на L или на FIn)

							     2013-06-27 15:44:00

Проблемы с gcnodes в графах с под-графами. Суть проблемы не ясна, но есть
очевидные места, которые надо править.

1.	Когда принимается решение делать expand, то раскрывать под-графы явно не
	нужно, потому что ссылки в них только внутренние. Если их раскрывать,
	получится какая-нибудь ерунда.

2.	... видимо, ещё должны быть косяки, но где?


							     2013-07-02 11:41:06

Очередной вопрос такой: в каком порядке проходить узлы в walkdag-е. Вопрос: кто
заходит в под-dag-и и как? В них заходит сам walkdag. Обычные обработчики,
вроде, не должны срабатывать. Поэтому, нужен if.

Вопрос ещё в том, а нужен ли divemap?... Теоретически, да. Это указание тех
узлов, в которые не надо заходить. И туда вообще ходить не надо. Даже
walkone-ом.


							     2013-07-03 17:20:33

Так. Теперь вопрос о том, что делать при evallist. evallist, по задумке, должен
переписывать списки атрибутов у некоторых узлов. Самое простое, при этом, иметь
в его current некоторую штуку

							     2013-07-21 17:11:21

Так. Как делать LNth.

							     2013-07-23 15:39:38

FUCK! Всё сдохло на нотбуке. Так. Надо восстановить. Во-первых, формат узла
такой:

	.LNth (list; (index));

index - это список из номеров или пар из номеров. Номера элементов бывают от 0
до N (просто какое-то число, смотри исходники, чем оно там ограничено) и
'00.1."T" - это указание на последний элемент списка (от Tail). Очевидно, что
первый элемент легко задаётся номером 0. Наверное, можно было бы сделать
операцию определения длины списка. Но у этого логика сложнее, да и внутреннее
представление у нас для такого не приспособлено. Поэтому такая вот фигня пока со
специальным атомом, указывающим на последний элемент в списке. Пример:

	.LNth (list; i1; i2; '00.1."T"; (i3; '00.1."T"))

Так... Это надо интерпретировать так:

	- взять из списка элемент i1;
	- оно должно быть под-списком и из него надо взять элемент i2;
	- который тоже под-список и из него берётся последний элемент;
	- из которого берутся элементы с i3 до последнего.

Так. Каждый номер i из множества {0, ..., N, '00.1."T"} разумно интерпретировать
как отрезок (отрезок, потому что края включаются): (i; i).

Поэтому для реализации всего этого счастья понадобится функция. Какая-нибудь
forklistcut. При этом... Различные косяки в индексах - это не обязательно баг, а
может быть ошибка пользователя. Поэтому, на корявых диапазонах forklistcut не
должна ломаться, а должна возвращать нечто вменяемое.

Например, она должна возвращать NULL, чистить за собой память, если что-то
использовалось, и устанавливать какой-нибудь флажок в true/false. Удобнее такой
интерфейс:

	forklistcut(l, from, to, &correct);

from и to могут быть равными -1, указывая на последний элемент списка. Ок.
Только fork-ов для списков у нас уже много. Поэтому придётся делать некий
megafork. Примерно такой:

	transforklist(l, M, N, bnd)
		= { megafork(l, 0, -1, M, N, bnd, &correct); assert(correct); }

	forklistcut(l, from, to, &correct)
		= megafor(l, from, to, NULL, NULL, 0, correct);
	
	forklist(l) = transforklist(l, NULL, NULL, 0);

Так. Значит, надо писать megafork с адским анализом параметров. В адском
анализе вариантов надо учесть, что бывает from = to = -1

							     2013-07-24 20:35:50

Ладно, ещё одна проблема, Хьюстон. Ссылка на .LNth должна вести себя примерно
так же, как .L, когда на неё ссылаются из другого узла. Там нужна подстановка,
поэтому в rewriteref в switch надо добавить ещё один вариант.

Ок. Это была простая часть.

Дальше должна быть сложная часть. Когда надо атрибуты .LNth переписать в
соответствии с индексом.

							     2013-07-26 09:26:38

ВАЖНО. Я ошибался. По двум пунктам.

1.	В стандартном C99 значения в enum-ах всегда целочисленные (int).
	Обычно считается, что компилятор подбирает наилучший тип для этих чисел,
	но в стандарте они всегда - int. Это надо помнить во избежании косяков с
	типами операций. Компилятор может выбрать более короткое представление
	этих значений (например, битовое поле), но это всегда int по семантике.
	Не unsigned int.

2.	В стандартном Си99 схема приведения типов такая:

		int -> unsigned int -> long int -> unsigned long int
			-> long long int -> unsigned long long int

	То есть, сравнивать наши unsigned-овые индексы, атомы и типы со
	значениями из enum-ов или с -1, то всё будет нормально, потому что эти
	int-ы будут переведены в unsigned-ы и операция будет выполнятся над
	значениями без знака.

Значит, ничего можно не переписывать (а то как-то слишком некрасиво
получается). По-прежнему, -1 кодирует максимальный unsigned и является
спец-значением.

							     2013-07-28 20:48:04

Гадасть. Надо выносить функцию переработки Ref в индекс для LNth
