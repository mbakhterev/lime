Результаты работы волшебной команды

	./ops c=1 s=4 i=4 l=4 h=4 f=4 d=4 x=4 p=4	

с комментариями. Сначала о результате продолжительных измышлений. Не
получится обойтись не более, чем двумя параметрами - ссылками на другие
узлы. Нужна параметризация и ссылкой на тип. Для арифметических операций
это не особо важно, но есть ещё конструкции для работы с составными
типами: cnst, соответствующие ARGB, INDIRB, ASGNB (работа с составными
типами данных). Возможно, в будущем этот же механизм потребуется и для
работы с шаблонами в Си++ или высокоуровневыми типами или функциями
(higher order types, functions).

Поэтому теперь предполагается, что узел (по максимуму) имеет такую
конфигурацию:

	code.t x = y : z

где t, y, z - ссылки на другие узлы. При чём t должна быть ссылкой на
какой-нибудь тип, который конструируется при помощи конструктора типа (не
путать с конструкторами C++; конструктор типа - это нечто вроде списка:
«hash» string long, где «hash» - атом, string и long - ссылки на другие
типы; это нужно для сопоставления уникальным способом синтаксических
выражений и типов в таблице; по конструкторам можно осуществлять поиск
по этой самой таблице; ну и ещё кое-что делать, в текущем контексте не
важное).

Так. Что ещё? Ещё нам понадобятся списки. Чтобы сосредоточить все
неравномерности и неоднородности относительно разбора узлов (штук вида
code.t x = y : z) в одном месте, предлагается этим местом назначить
любимый узел link. Который и так достаточно неоднороден, ибо должен
уметь в dag вычисления вставлять ссылки на объекты, отличающиеся от
узлов:

	A.x - на атом с номером x;
	C.x - на константу в таблице констант с номером x;
	S.x - на символ в таблице символов с номером x;
	T.x - на тип с номером x в соответствующей таблице;
	L.x - ссылка на метку в таблице меток.

Во время работы ядра, link должен уметь связываться с подвыражениями,
которые служат основами для конструирования более сложного выражения на
основании этих подвыражений и некоторого оператора. Это формат

	R.x - ссылка на подставленный в процессе сопоставления с
	образцом операнд оператора (вообще, в литературе эти штуки
	называют рандами и раторами, поэтому и R).

Это всё унарные формы link. Бинарную форму link можно использовать как
раз для составления списков.

	link	a = A.1;	// допустим, это ссылка на атом «list»
	link	b = T.10;	// допустим, это ссылка на тип int
	link	c = a : b;	// список из двух элементов. Это может
				// быть хорошо согласовано, потому что a
				// и b можно считать списками из одного
				// элемента. link строит списки.

Так. Вооружившись этим, переходим к описанию соответствия
LiME и LCC-конструкций.

1.	CNSTF4=4113
	CNSTI1=1045 CNSTI4=4117
	CNSTP4=4119
	CNSTU1=1046 CNSTU4=4118

	Эти конструкции нужно выводить из такого представления:

	link	c = C.x;

	x - это номер константы в таблице констант.

	В таблицу констант константы попадают в процессе обработки таких
	цепочек:

	link	t = T.x
	link	a = A.y;
	link	r = a : tail;	// tail - это какой-то дополнительно
				// накопленный хвост списка
	cnst.T	C.z = r;

	x, y - это номера в таблицах констант и атомов, соответственно.
	T - это атом, описывающий ссылку в таблицу типов (4i, 4f и т.д.
	В общем случае, может быть нечто более сложное: struct28x)

	list - конструкция, которая составляет список из элементов (нам
	потребуется составлять списки из нескольких видов значений:
	типов, атомов, некоторых инструкций. Списки должны быть
	типизированными: в списке атомов не должно быть типов и т.д.). В
	данном случае она должна составлять текстовое представление
	константы из атомов. Список будет длиннее одного элемента пока
	только в случае константы с типом F, константа будет
	представлена в виде списка: «целая часть» «дробная»
	«экспонента».

	Но стоит помнить, что константы бывают и сложные: структуры,
	массивы. В этих случаях без списков значений не обойтись.

	Это достаточно легко потом собрать в константу, завести новый
	атом под это дело, или ещё что-то сотворить. В таблице констант
	будет ссылка на тип константы, по которому можно будет
	восстановить суффикс операции.

2.	ARGB=41
	ARGF4=4129
	ARGI4=4133
	ARGP4=4135
	ARGU4=4134

	С ARGB пока не понятно, это оставим до работ над сложными типами
	данных. ARGB в LCC используется для указания
	аргумента-структуры. Остальные конструкции будут выражаться
	конструкцией:

	arg.T	a = prevargs : val
	arg.T	a = val

	T	- это ссылка на тип (не обязательно чисто числовая);
	val	- значение, которое следует сделать следующим аргументом
		  функции;
	arglist - предыдущий накопленный список аргументов (опыт работы
		  над LCC говорит о том, что неплохо иметь именно
		  список);
	a	- это ссылка на текущий узел arg, но так как у него есть
		  в kids[0] ссылка на предыдущий arg, то это как раз и
		  получается ссылка на список.

	Пример:

	link	f = C.1;
	link	i = C.2;
	arg.4f	a = f;
	arg.4i	b = a : i

	Да, тут тоже будет неоднородность в кодировании инструкции. Можно
	было бы, конечно, предусмотреть какой-нибудь null, как указатель
	на пустой список. Но если думать дальше, о двоичном
	представлении всех этих узлов, то возникнет вопрос: а что такое
	null и как его закодировать? Это специальный атом? Или это ноль?
	Сложно. Иметь же просто два разных вида инструкции (два разных
	двоичных op-кода для разного формата) кажется более простым
	решением.

3.	ASGNB=57
	ASGNF4=4145
	ASGNI1=1077 ASGNI4=4149
	ASGNP4=4151
	ASGNU1=1078 ASGNU4=4150

	ASGNB пока оставляем в стороне. Для остального код такой:

	wr.T	addr : val

	Штука ничего не возвращает.

4.	INDIRB=73
	INDIRF4=4161
	INDIRI1=1093 INDIRI4=4165
	INDIRP4=4167
	INDIRU1=1094 INDIRU4=4166

	INDIRB пока в стороне. Для остального:

	rd.T	x = addr

5.	CVFF4=4209
	CVFI4=4213

	CVIF4=4225
	CVII1=1157 CVII4=4229
	CVIU1=1158 CVIU4=4230

	CVPU4=4246

	CVUI1=1205 CVUI4=4277
	CVUP4=4279
	CVUU1=1206 CVUU4=4278

	Эти операции должны быть параметризованы двумя типами.

	link	T = T.x;
	link	t = T.y;
	cv.T	x = u : val	// вполне допустимо и однозначно: T без
				// «.» - это ссылка на узел; T. -
				// префикс для поиска в таблице типов.

	Преобразование из типа T в t, оба берутся из таблицы типов.

6.	NEGF4=4289
	NEGI4=4293

	neg.T	x = y

	На самом деле MCp не умеет такую операцию выполнять, но у него
	есть замечательная инструкция insub, которая используется в
	данном случае. Это чуть более эффективно, чем если бы мы
	заменили neg на:

	link z = C.0;	// ссылка на константу с нулём
	sub.T	x = y : z;


7.	CALLB=217
	CALLF4=4305
	CALLI4=4309
	CALLP4=4311
	CALLU4=4310
	CALLV=216

	Актуальной будет только инструкция CALLV. LCC вставляет CALLx
	(для других x) прямо в граф (dag) выражения, а MCp так не умеет.
	CALL обязательно должен идти отдельным параграфом. Поэтому
	сейчас CALLx пилиятся на пары параграфов, один с CALLV, другой с
	чтением возвращаемого значения из специального символа,
	связанного с адресом (#SP,4), по которому записывается
	возвращаемое значение.

	Нам это не нужно, и это будет сделано всё явно на другом уровне
	трансляции исходника в промежуточное представление. Всегда нужно
	будет генерировать CALLV.

	Генерировать будет необходимо по таким узлам:

	brl	targets;		// branch with link
	brl	args : targets;

	На самом деле вызов функции - это ветвление с сохранением в
	кадре вызываемой функции тем или иным способом (на ARM через
	регистр, например) адреса возврата. Обычно, этот адрес - адрес
	следующей инструкции. Но в MCp - это адрес параграфа, и не
	обязательно следующего. И его надо указывать явно. Поэтому:

		- targets - это список из двух значений: адрес целевой
		  функции и адрес возврата, который надо записать в
		  стека;

		- args - список аргументов.

	LCC (как и GCC или LLVM) нас не поймёт. И ему всегда нужно
	будет просто сказать CALLV с определённым адресом точки входа в
	функцию.

	Но на уровне трансляции Си в наше промежуточное представление
	нам понадобится именно такой формат. Для последующих оптимизаций
	понадобится иметь ссылку на список аргументов, а не просто
	считать, что brl происходит только с цепочкой ранее
	встретившихся аргументов, обозначенных узлами arg.T.

	Поэтому так (если кто-то предложит более элегантный метод, буду
	только лишь рад этому).

	Здесь опять две инструкции для удобства кодируются однообразно.
	Пример:

	link	4i = T.1;
	arg.4i	a = v1;
	arg.4i	b = a : v2;

	link	fn = S.1234;	// символ, связанный меткой кода функции
	addr	fa = fn;	// адрес этой метки
	link	ra = L.1;	// метка адреса возврата, которая уже
				// адрес
	link	ts = fa : ra;
	brl	b : ra

	label	L.1;

8.	RETF4=4337
	RETI4=4341
	RETP4=4343
	RETU4=4342
	RETV=248

	Не понадобится. Ядро будет генерировать явный код записи
	возвращаемого значения по специальному символу, и явный переход
	на эпилог функции, который будет пробрасывать вычисление дальше,
	в соответствии с targets.

9.	ADDRGP4=4359

	ADDRFP4=4375

	ADDRLP4=4391

	Информация об области видимости символа у нас будет записана в
	самом символе. Адрес всегда имеет один и тот же тип - указатель.
	Можно считать, что он будет всегда записан в таблицу под именем
	T.ptr. Поэтому, просто будет конструкция:

	addr	a = s;	// s должен быть через link настроен на
			// некоторой символ.

10.	ADDF4=4401
	ADDI4=4405
	ADDP4=4407
	ADDU4=4406

	Это элементарно.

	add.T x = y : z;

11.	SUBF4=4417
	SUBI4=4421
	SUBP4=4423
	SUBU4=4422

	Элементарно

	sub.T x = y : z;

12.	LSHI4=4437
	LSHU4=4438

	Элементарно

	lsh.T x = y : z;

13.	MODI4=4453
	MODU4=4454

	Модель процессора, для которой мы работаем, не умеет делить
	целочисленно. Деление и остаток берутся через вызов внешней
	функции, для чего mcp.c производит трансформацию дерева. Но
	логичнее просто генерировать нужный dag на уровне front-end-а C
	и ядра LiME. Это и будет сделано. Ничего транслировать в MODx не
	нужно.

14.	RSHI4=4469
	RSHU4=4470

	BANDI4=4485
	BANDU4=4486

	BORI4=4517
	BORU4=4518

	BXORI4=4533
	BXORU4=4534

	Элементарно

	rsh.T x = y : z;
	and.T x = y : z;
	or.T x = y : z;
	xor.T x = y : z

15.	BCOMI4=4501
	BCOMU4=4502

	Это операция инверсии битов - «~» в Си.

	not.T x = y : z
	
16.	DIVF4=4545

	Элементарно

	div.T x = y : z;

17.	DIVI4=4549
	DIVU4=4550

	Как и MOD это нужно делать через вызов процедуры. Этот вызов
	будет сгенерирован в ядре по информации от фронтенда Си. Ничего
	в эти DIVx переводить не надо.

18.	MULF4=4561
	MULI4=4565
	MULU4=4566

	Элементарно

	mul.T x = y : z;

19.	EQF4=4577
	EQI4=4581
	EQU4=4582

	GEF4=4593
	GEI4=4597
	GEU4=4598

	GTF4=4609
	GTI4=4613
	GTU4=4614

	LEF4=4625
	LEI4=4629
	LEU4=4630

	LTF4=4641
	LTI4=4645
	LTU4=4646

	NEF4=4657
	NEI4=4661
	NEU4=4662

	Это операции условного ветвления. В них нужно будет превращать
	такие конструкции (они выбраны с учётом требований последующей
	оптимизации).

	{eq, ge, gt, le, lt, ne}.T	r = x : y;	// сравнение
	br				r : target;	// условный
							// переход
	
	target - это адрес перехода (либо ссылка на L.n, либо нечто
	вычисляемое в процессе вычисления, в отличии от brl тут только
	одна цель).

	Обработка этой конструкции должна быть примерно такой: смотрим
	по таблице на первую ссылку в br, и по коду операции,
	сохранённому в узле, генерируем соответствующий CCx.

	Когда мы будем переписывать mcp.c, или сразу писать генератор из
	LiME в ассемблер, всё будет проще.

19.	JUMPV=584
	
	Немного не элементарно, потому что это другая инструкция с той
	же мнемоникой (для удобства программиста), что и br. При чтении
	нужно будет проверять число аргументов.

	br target

20.	LABELV=600

	Это нужно будет генерировать по конструкции

	label	L.x

	Ранее, в спецификации это называлось mark. Но что-то мне сложно
	разрушить даже в самом себе существующую традицию именования
	разных штук в программировании. Метка - это label.
