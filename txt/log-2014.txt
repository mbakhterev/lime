							     2014-01-13 23:01:44

Адская проблема с цитатой цитат. И вообще сложный вопрос: должен ли генератор
графа программы уметь генерировать новые генераторы программ?

По идее, должен. Это наиболее простой способ разобраться со структурами и
union-ами всякими. Ок. Зафиксируем это. Нам нужна генерация генераторов.

Но как это сделать? Вероятно, имеет смысл размышлять так. Наши программы - это
просто строки. И генераторы - это тоже строки (собственно тут ничего особо
нового, lambda - это тоже строки, поэтому здесь мы с генерального пути не
сходим). Ок.

Но дальше возникает вопрос с подстановками. Если мы хотим генерировать
генераторы, то указания на подстановки не должны выполнятся. Их надо
экранировать.

В lambda это экранируется собственно lambda-ми... Хм. Ну, Ок. И что?

--

C lambda всё хорошо, потому что там последовательность подстановок явно задана
(в обратном порядке) последовательностью lambda-термов. Но если мы хотим нечто
параллельное и событийное, нам нужно отойти от этой упорядоченности.

--

Когда у нас есть L = (lam x (lam y (x y))), то мы последовательно подставляем
другие выражения. При чём явно и последовательно. Сначала вместо x, потому
вместо y.

И делаем мы это явно, записывая ((L a) b). Но это не события, а последовательное
применение.

Если мы хотим событий, то должны писать как-то так: (e1.(signature 1) ...
eN.(signature N) (a.(add e1 e2) (sub a eN))

--

Проблема вот в чём (возможно). Когда мы говорим о лямбда, то у нас есть просто
группоид с аппликацией L1 L2 -> L3. Из одного выражения применением к другому
получается третье. Замечательно. Но в этом месте и различие.

Когда мы говорим о RiDE, то у нас есть некоторый контекст и к нему мы применяем
правило (форму), и получаем новый контекст (или даже новые контексты; но для
простоты можно считать, что он один). И мы должны писать C1 f -> C2.

f, при этом, вносит кусочек своего тела в новый контекст. Хм. Можно сказать, что
это похоже на трассы (trace) из CSP и теории следов (trace). Ок. Замечательно.
Мы пока не далеко ушли от общепринятого.

А. Ну и вот тут, собственно, загвоздка. А как нам превратить контекст в форму?
Это как раз и нужно для формирования форм для обработки структур и функций. Так,
замечательно. Значит, вопрос сводится к более конкретному: как формировать формы
из контекстов.

--

По идее, нам должно помогать то, что и формы, и контексты - это деревья (точнее,
ориентированные графы без циклов, но dag-и не звучит).

В принципе, мы могли бы сделать нечто такое. Вот есть форма - это F-узел с
атрибутами, содержащими некоторое дерево. Допустим, можно сказать, что вот в
этом дереве может быть G-узел, который содержит то дерево, которое пойдёт на
дописывание в контекст. Мы можем добавить парочку узлов, типа GWr, GRd для
обмена с этим поддеревом информацией через специальную таблицу.

Но в итоге это не особо спасёт нас от рекурсии: а что если мы хотим в
результирующий граф как раз и дописать узлы GWr, GRd? И вложенные G до кучи?

И ещё одно contra против подхода: в lambda можно обойтись только lambda.
Z-комбинатор и всё такое прочее.

--

О! А если мы посмотрим так. С логической точки зрения. По идее, форма может
являться конъюнктом, то есть штукой, для которой нужно выполнение всех условий,
чтобы сработать.

Контекст при этом является у нас дизъюнктом (ну, чем-то вроде), который ожидает
срабатывания одного из условий.

Это не изоморфизм, а просто аналогия. В принципе, формы и контексты могут быть
равноправными в том смысле, что мы можем копировать и запоминать в окружениях не
только формы, но и накопленные контексты.

Теоретически, этого может хватить для реализации структур. Ок. Эту мысль надо
развернуть.

P.S. Да, я в курсе, что в lambda все компоненты, необходимые для логики
(константы и операции) выражаются лямбда-термами. Возможно, где-то тут зарыта
тонкость. Потому что lambda всё равно требует вычисления значений всех
переменных. А когда мы говорим о распределённых и параллельных вычислениях, то
для принятия решения об истинности ИЛИ нам необходимо дождаться первого
истинного значения.

--

Тут +1-ом проходит то, что такой контекст мы можем записать в виде формы: в
штуке будет просто много выдачей с разными ключами тех форм, которые составляют
контекст.

Гомоиконичность соблюдается. Генерация такого контекста эквивалентна генерации
такой формы. Ну +\- какие-то детали, но в целом, похоже на правду.

Дальше? А дальше нам нужен конкретный пример. Потому что, возникает вопрос: а
как нам результат эволюции одного контекста приписать к контексту другому.

--

Проблема всё-равно с подстановкой в нужное место. Ну, банальная ситуация: if(a <
b) { c = d; } Накопленный контекст для ветки "c = d" нужно вставить в структуру
блоков, которая соответствует if-у. Так?

Так. Для этого у нас есть Crop. Специально его экранировать не нужно, потому что
он и так внутри формы стоит. Формы в нашем случае это аналоги lambda. Несколько
витиеватые, но сойдут для версии 0.D.

Так. Вроде. Этот вариант должен работать. Тут нет необходимости шаманить с
Quote-ами и eXecute-ами. Вроде, всё понятно и можно сделать без них.

--

По идее, у метода +100500 достоинств.

Формы всегда замкнутые. Мы можем свободно перекидывать их между контекстами без
проверок. Их можно использовать в качестве значений для параметров других форм.
В FOut-ах, то есть.
По узлам всё упрощается существенно. Дополнительная логика, которая потребуется - это Crop + R и всё. То есть, только areaeval без execeval с глючным смыслам.  Сами контексты (R-ы) можно тоже передавать в качестве параметров в формы.  Ну и тут мы ближе к lambda. Не нужно два варианта апликаций и экранов. Хватает
просто форм. От lambda мы отличаемся тем, что умеем явно манипулировать
распределёнными контекстами вывода.

Ок. Принимаем такой вариант. Будем пробовать.

PS: Eureka

							     2014-01-14 09:36:16

Так. В свете этого всего новая последовательность progress должна быть такой:

1.
	ntheval (75, надо немного прокачать Nth, чтобы оно сразу позволяло
	разбирать типы и символы) - подстановки всякие. FIn и Nth

2.
	enveval (100) - надо оценить окружения, нужно быть готовым к тому,
	что формы будут опубликованы в них

3.
	areaeval - оценка областей вывода. R, REnv и Crop получается

Пространство для работы создано

4.
	typeeval (100) - типы, потому что они могут входить в состав ключей

5.
	symeval (100)

6.
	formeval (100) - формы FEnv, FPut

7.
	outeval - обработка FOut

8.
	К следующей итерации алгоритма

							     2014-01-16 12:49:38

Обнаружилась ошибка в алгоритме enveval. Env-узлы обрабатываются позже, чем
узлы, которые они должны помечать. Поэтому в envmarks попадают неверные
отметки.

Для исправления ситуации алгоритм нужно разбить на три части, а не на две
текущие: (1) конструирование, определение (как раз Env) окружений, разметка
узлов на текущем уровне определений; (2) проход на уровень ниже.

Должно быть три части: (1) конструирование и определение окружений на текущем
уровне; (2) разметка узлов на текущем уровне; (3) проход на уровень ниже.

							     2014-01-16 14:03:53

Видимо, имеет смысл области вывода делать тоже списками из нескольких массивов.
Типа, areacurrent, areaforward и areadag. Чтобы не заморачиваться с управлением
памятью.

Так. Но что-то тут не так, как надо. Потому что области должны уметь ссылаться
друг на дружку.

И makepath для них тоже должен работать.

Поэтому, области - это keymap-ы, получается. И у них должно быть 3 поля. Это
связки с другими keymap-ами. Ну ладно. Плюс информация о том, чего там накоплено
к настоящему моменту.

Ну, хорошо. А как понять... Да, вроде, всё должно работать.

							     2014-01-16 16:13:00

Ага. Вопрос был о том, а как понять, можем ли мы собирать (Crop) контекст.
Ссылки же могут быть двусторонние. По идее, в полноценной реализации мы просто
понимаем, что все каналы закрыты и тогда контекст можно закрывать, если он сам
не проявляет активность.

Область и контекст - это одно и то же. Ну, супер. И что?

Другие варианты:
	
	- контекст может сам себя закрыть;
	- контекст может закрыть все свои каналы;

Вата. Закрывать по одному каналу тяжко. А что делать с закрытыми областями? Мы
их можем собрать и тогда освободить структуры. А если он закрылся, и никто его
не хочет собирать?

Хорошо. Он закрылся. А ссылка на него висит, например.

							     2014-01-27 18:10:54

Чёртов exprewrite. assert-ится. Правильно делает, конечно. Но мать его за ногу.
Что делать в этом месте? Можно включить в обработку определения узлов, так?
Чтобы он просто пропускал узлы, которые во что-то отображаются. И ходил по
атрибутам простых узлов.

Вероятно, это более предпочтительный вариант в сравнении с последующей сборкой
мусора. Выглядит аккуратно. Только ещё надо учесть тонкость: если мы
переписываем узел на него же самого, то это означает, что его надо оставить.

Частные случаи, чёрт их.

Ну получается же, что нам надо делать нечто похожее на forkdag. Странно как-то
получается.

Нет. Не forkdag. У нас в exprewrite может быть ещё допустимая ссылка на не
понять куда. Получается, forkref-ом тоже не получится в полной мере
воспользоваться. Гадость.

Эх, реально же гадость. Получается, что надо повторить структуру forkdag с
учётом всяких разных тонкостей.

И что с этим делать? forkref переписать что ли? Не, не пойдёт. Значит,
exprewrite жертва. Поехали

							     2014-01-27 21:24:53

Собственно, exprewrite так и устроен. Только вот forkref не работает в этом
случае. Там должен быть rewrite, видимо

							     2014-01-28 08:11:12

Эх. То nodemap, которое в exprewrite это совсем не то nodemap, которое нужно.
Вообще, получается какая-то странная логика.

Ещё раз. exprewrite берёт на вход выражение в виде графа. Берёт отображение
узлов этого графа в другие выражения (возможно, другие графы) и берёт verbs-ы
тех узлов, которые надо переводить в новые значения.

Так. Nodemap - это внутреннее отображение, используемое для forkref на тот
случай, если подставлять придётся графы целиком.

forkdag выглядит вот как, если что:

	Ref forkdag(const Ref dag)
	{
		Array *const M = newkeymap();
		const Ref r = forkref(dag, M);
		freekeymap(M);

		return r;
	}   

Ок. Но, значит, если мы при переписывание узлов копируем определения... Нам же
надо сохранить целостность ссылок. И чего делать?

Мы же должны сохранить ссылки

							     2014-01-28 13:15:06

Продолжение о exprewrite.

1.
	В реализации у нас есть nodemap для forkref-ов. Можно отображать копии
	узлов исходного выражения в этой nodemap. По идее, чисто внешне, эти
	узлы не должны пересекаться с узлами в обрабатываемой форме (откуда тот,
	кто сотворил подстановки может знать о форме, которая сама была
	скопирована, чёрт знает откуда.

2.
	В принципе, можно сделать два разных прохода. Отдельный проход
	подстановки, а потом собрать мусор. Но это не решение проблемы. Косяки
	тут те же самые, потому что основная проблема не в мусоре, а в
	подстановках.

Поэтому продолжаем мысль

1.
	В NM (nodemap) не должно быть пересечений с текущей формой. Но они могут
	возникнуть из (а могут ли? нужно учитывать, что каждое определение
	живого узла относительно уникально, занимает свой набор ячеек в памяти):

	1.1.
		NM дописывается в forkref при подстановке значения из map. Это
		дописывается в том случае если в значении встретилось
		определение узла, и этот узел был скопирован. И дальнейшие
		ссылки на него транслируются через эту трансляцию.

	1.2.
		NM может дописаться при активности в exprewrite при дублировании
		исходной формы.

	1.1. и 1.2. могут пересекаться в случае, если в map упомянуто как-то
	определение узла из обрабатываемой формы. А это может произойти, если в
	map в качестве значения стоит сама форма.

	А при нормальном течении алгоритма такого быть не может, по идее. Формы
	перед обработкой копируются из хранилищ. Ок.

3.
	На случай пересечения у нас может быть два решения. На самом деле, там
	надо решать проблему ещё с несколькими forkref-ами в течении одной
	подстановки. Они тоже могут пересекаться своими определениями.

	3.1.
		Можно каждый раз брать свою keymap. И для forkref, и для
		основного процесса exprewrite. Но это плохо, ибо незамеченными
		могут оказаться самые разные косяки. И потом, не понятно, а если
		пользователь захочет добиться связи разных значений в одно
		целое? То есть, чтобы ссылка на один и тот же узел
		была подставлена корректно? Поэтому НЕ ВАРИАНТ, хоть и какое-то
		решение.

	3.2.
		Нужно делать через одну NM для всех. Грабли начнут вылезать,
		если отклонимся от основного хода алгоритма. Но это, вроде, и
		полезно, чтобы они повылезали.
	
Вооружаемся вариантом 3.2.

Перепланирование:

1.
	Надо включить копирование определений узлов в exprewrite.

2.
	Надо научить сборку выражения пропускать ссылки, у которых
	(Ref.code == FREE).

3.
	Не забыть о тонкости, когда в map узел указывает сам на себя. Такой узел
	надо оставить в итоговом графе.

4.
	Проверить.

							     2014-01-28 16:41:53

В процессе:

П:1.
	Надо включить копирование определений узлов в exprewrite.

П:3.
	Не забыть о тонкости, когда в map узел указывает сам на себя. Такой узел
	надо оставить в итоговом графе.

П:4.
	Проверить.

Готово:

П:2.
	Надо научить сборку выражения пропускать ссылки, у которых
	(Ref.code == FREE).

Проблемы теперь с пунктом три. Что делать с узлами, которые хотят оцениваться
сами в себя? Потому что, если мы вдруг хотим скопировать такой узел, то в map-то
останется прежняя ассоциация.

Варианты решения проблемы:

1.
	Грязным хаком подменить ассоциацию в map.

2.
	assert-ится на таких ассоциациях, как на бессмысленных.

Грязный хак - это плохой вариант. Map может быть использована повторно. Поэтому
пойдём по варианту 2. Для этого нужно:

П:5.
	Нужно сразу же превращать Ref-у на узел в Ref-у через map. И сразу
	проверять, что нам не подсовывают "тавтологию".

Только это, всё равно, не спасает гигантов мысли. Ссылка может быть указана
через какой-нибудь уровень вложенности. И хрен её тогда поймаешь. Нужен более
общий подход.

							     2014-01-28 18:12:01

В общем, надо менять стратегию. Нужно отказаться от попыток всё сделать в одном
проходе. Прохода должно быть два. Один - «раскопирование» графа для создания
места для подстановок, а потом «починка» этого графа с правкой ссылок на
исходные узлы в ссылки на узлы новые.

Определения при этом можно оставить на месте.

Логика с использованием общей nodemap здесь не меняется. Пускай будет для
надёжности.

ИЗ ЗАНЯТНОГО:
	
	За один проход, с созданием новых узлов и переписыванием ссылок мы не
	сможем корректно построить новый граф. Но за два прохода: copy и fix -
	можем.
	
	Q:
		Должны ли мы рассматривать копирование, как процесс создания
		места для вычисления новой фиксированной точки, а переименование
		узлов, собственно, как само вычисление?
	
	Q:
		Может ли на самом деле процесс «затягивания узлов» из мира ФП и
		рекурсии быть процессом отождествления?

							     2014-01-28 19:16:00

В общем, видимо, из той же оперы: мы не можем определить то, оставлять ли
какой-то узел в выражении или нет, потому что, фиг знает, когда на него всплывёт
ссылка. В принципе, можно сконструировать разные варианты.

Для надёжности надо собирать мусор уже после copy-fix. В итоге всё превращается
в четыре стадии:

	eval:
		Написано, не проверено

	exprewrite:
		copy:
			Написано, но надо выделить

		fix:
			Написано, но надо выделить

	GC:
		Написано

Так. Ладно. Замечательно. Потом тогда надо будет сделать финт ушами и заменить
forkref на exprewrite с нулевыми отображениями узлов на значения (map) и verbs.

							     2014-01-30 12:08:34

Блин. Аккуратнее надо. Так.

1.
	Не надо пытаться пропускать Ref.code == free (готово).

2.
	Так. В проходе copy мы не транслируем ссылки, потому то бессысленно
	(готово).

4.
	Надо смягчить политику forkref. Потому что в текущем варианте он будет
	вылетать с assert-ами, потому что не будет знать, куда отображать
	ссылки (готово).

5.
	Переопределения узлов надо сложить в nodemap. При это надо рекурсивно
	пройтись по атрибутам (готово).

							     2014-02-01 14:08:07

exprewrite, вроде как, снова готова. Надо теперь выполнить проверку. Оценка и
копирование.

Эх. А потом ещё надо будет собрать мусор

							     2014-02-02 18:39:00

Ещё один косяк, связанный с forkref-ом. Когда нас просят скопировать список, при
чём, с nodemap != NULL, то чего делать, если Ref.external?

По идее, а какая разница? В любом случае (именно можно, а не нужно) сделать
копию списка. Тонкость в том, что нужно возвращать ссылку с !Ref.external. Ok,
замечательно.

							     2014-02-05 10:02:16

Цепочка работы должна быть такой на текущем этапе:

1.
	Загрузили (готово).

2.
	Нужно оценить типы (готово).

3.
	Символов, теоретически, быть не должно. Символы приходят из исходного
	текста программы.

4.
	Обработать формы. На этом месте всё должно быть готово. Оценивать надо с
	пустым контекстом, потому что контексты должен порождать исходный текст
	программы.

Значит, занимаемся формами. Для форм нужны контексты. Контексты никуда не
годятся в текущем варианте: утечки памяти, которые создают проблемы. Нужно
заменить их на области вывода, реализованные поверх наших Array-ев.

1.
	Описать структуру данных для AREA (готово).

							     2014-02-05 10:18:10

Следующие шаги

1.
	Подогнать обработку форм под AREA.

2.
	Совместить разные eval-ы в одном проходе. А то уже неприлично
	получается. Вроде, структура у всех eval-ов может быть одинаковая и её
	можно закрыть одним циклом.

	Даст дополнительную выразительность и упростит Алексею Ефимову работу.

	Сделать просто, потому что все eval-ы уже будут готовы.

Начинаем 1. Для этого последовательность адаптации функций:

1.
	intakeform

2.
	intakeout

3.
	formeval

Поехали.

							     2014-02-05 11:08:46

Проработка intakeform.

Наши формы сейчас - это списки. Это облегчает управление
памятью, но создаёт непонятки.

Мы, естественно, хотим в контекст записать только ссылку на форму, если форма к
нам пришла из окружения. Ну или известно, что она какая-нибудь external.

Но проблема в том, что эти формы должны обрастать счётчиками и всем таким
прочим.

Значит, надо эту форму сразу передавать как форму, если она обнаружена в
окружении, только создавать её при этом так:

	newform(markext(formdag(F)), markext(formkeys(F)));

Ок. Принято.

Значит, в intakeform надо устроить проверку на то, что форма всегда должна быть
!Ref.external, чтобы можно было спокойно добавлять счётчик.

Ключи в Array могут быть тоже external и ссылаться на элементы в списке ключей.

Хорошо. Логика должна сработать.

Только для вывода сообщений об ошибках надо ещё запоминать, где форма была
определена. Или intakeform должна говорить: ошибка. Потому что в обработке FPut
будет известно, какой именно узел обрабатывается.

Принято

							     2014-02-05 13:03:53

Работа над intakeform.

Логика спотыкается вот в каком месте: ну навешаем мы этих input-ов, но во время
навешивания input-ов могут быть уже output-ы. И что тогда делать?

Не хотелось бы рекурсивно уходить в обработку ставших активными форм. Это не
нарушает семантику, но отладку сделает адски нетривиальной. В граф будут
дописываться куски, которые не связаны именно с текущей формой.

Значит? Надо копить список форм отдельно. И смотреть, в каких счётчики упали до
нуля. Или сразу были нулевыми.

Хорошо. Мы будем копить такой список. Тогда надо исходить из особенностей
output-а.

Видимо, всё надо структурировать. Должно быть три компоненты в реакторе:

1.
	Output-ы - это ключ -> значение

2.
	Input-ы - это ключ -> список ожидающих форм.

Форм может быть действительно список, и это не нарушает логику графа. Output-ы
должны быть уникальные.

Когда мы забираем форму, то, кроме подготовительной ерунды всякой делаем
следующее:

1.
	Заводим у формы счётчик.

2.
	Добавляем форму в список форм в реакторе. Специальное поле должно быть

3.
	Для каждого ключа в сигнатуре делаем:

	3.1.
		Проверяем, есть ли такой output. Если есть, значит, уменьшаем
		счётчик на 1.
	
	3.2.
		Если нет, то добавляем форму в соответствующий список для
		input-а.

Когда придёт время для активации формы (счётчик упал до нуля). Идём по её
сигнатуре и собираем соответствующие output-ы в один список для подстановки в
.FIn

Это автоматически даст нам обработку форм с пустыми сигнатурами. Можно выкинуть
это странное требование о не-пустоте. Концепция хорошо согласуется с тем, что
может быть много форм с одинаковыми сигнатурами. Просто все сработают. Это ближе
к RiDE.

Чтобы это заработало, нужно уметь проверять счётчик формы без его уменьшения.

1.
	Чтение счётчика формы без его уменьшения

							     2014-02-10 12:41:15

Правка ошибки в обработке символов. С текущей архитектурой символы надо сложить
в отдельную таблицу, а в окружениях поставить ссылки на их номера. Основное
место жизни символов - эти таблицы. В окружениях ключи можно брать через
markext. Но в саму таблицу надо занести имена символов.

При этом, в symmarks узлы надо пометить номерами символов в этой таблице. Дело
должно быть примерно так, как с типами.

Хорошо. Для этого:

1.
	Поменять getexisting на поиск в текущем окружении... Готово

2.
	Поменять setnew на загрузку в таблицу и на установку локального
	binding-а... Готово

3.
	Ждём проверки в боевых условиях.

							     2014-02-11 20:58:02

Ладно так. Открытый вопрос в том, можно ли в evalforms обойтись без информации о
типах и без вспомогательных отображений. И поэтому что? Вообще-то удобнее с
ними, если .FEnv-ы нужно обрабатывать.

Ок. Пусть будет. Тогда .FEnv будет похожа на .S.

Что ещё?

Надо не забыть об .FOut-ах. Проверки всякие не то, чтобы не было ссылок на
служебные узлы (Nth раскроется).

Может быть, имеет смысл вернуть L-узлы.

Типы тоже понадобятся. Потому что сигнатуры в .FOut-ах должны быть оценены в
идентификаторы типов.

							     2014-02-12 21:02:17

Да вашу ж мать! В форме могут быть и другие окружения. И .FEnv может жить в них.
Поэтому надо сделать evalmarks. Получается, при оценке форм окружение всегда
должно быть и сперва надо будет всегда вызывать enveval. ГрррРр.

И тут возникает вопрос об области вывода: она-то хоть есть у нас? Без понятия.
Мозги уже почти не работают. Пока пусть будет просто параметр.

Ладно.

							     2014-02-12 21:40:09

Ещё одна безрадостная новость: типы в сигнатуре надо сперва переписать... Готово

							     2014-02-12 23:41:02

Ещё одна проблема. Так где же копировать эти чёртовы формы?

							     2014-02-13 10:34:40

Так, спокойно. Надо понять, какой цикл жизни у формы.

1.
	Форма записана в некотором графе. Граф после обработки будет сильно
	трансформирован и, фактически, уничтожен.

	Поэтому форму из графа надо копировать.

2.
	Форма уже может жить в некотором окружении. Можно просто брать на неё
	ссылку. Хотя, это не правда. Если мы берём форму в некоторую активность,
	типа в область вывода, нам нужна новая копия счётчика. Так?

	Да. Так. Значит, мы должны в intakeform всегда создавать новую форму.
	Зафиксируем. От этого и нужно отталкиваться.

Теперь, значит, вопрос к newform. Должна ли она fork-ать свои аргументы? Нет.
Это не окончательный ответ.

Ещё раз смотрим. Мы можем сказать, что intakeform просто берёт подготовленную
уже форму. Ничего не fork-ает, а пишет так, как оно есть.

Видимо, в этом месте нет универсального рецепта. Проще всего сделать два режима
у extractform. В которых он возвращает разное, понимая, что от него просят.

Если для intake форма нужна, тогда он формирует форму для intake. Если для env,
то там можно обойтись ссылочками.

Принимаем этот вариант.

							     2014-02-13 12:54:58

Не рабочий вариант. Потому что опять куча if-ов непонятных. Нужно
перепланировать. В предыдущем варианте evalforms extractform возвращал не форму,
а структуру. Может, имеет смысл её и вернуть?

Гадость. Почему в мелочах самые сложности и вылезают. Ну что за хрень? Ладно.
Пусть структура. Там думать меньше надо.

							     2014-02-13 13:38:33

Опять не выходит. Вопрос: а что делать с той формой, которая была сформирована в
порыве прекрасного? Её надо удалить.

Но мы не можем её удалить, если она завязана на от-fork-нутые dag и keys.
Значит, форму надо создавать внутри процедуры. Где можно принять решение о том,
как эта форма будет жить.

Так? Видимо, так.

Теперь про newform тогда. Там нужно больше гибкости, видимо. Надо сделать
аналогично newnode. В том смысле, что не надо там делать fork-и автоматически.
Пусть пользователь этим управляет.

Ладно. Хорошо. Принято... Готово. Так и оставим. Пляшем от этого.

Следующее, от чего пляшем: форму надо создавать там, внутри функции с логикой
обработки этой формы. Если речь о setnew, то внутри setnew.

Значит, extractform должен ошмётки формы добывать. Так? Так. А setnew должна
этими ошмётками пользоваться. Так?

Вашу мать. Не сходится. Потому что setnew должна уметь сохранять просто ссылку
на форму, если написана какая-нибудь ерунда вроде
	
	.FEnv ("hello"; .FEnv ("world"));

Это не вопрос экономии памяти, а вопрос того, чтобы было одно и то же. Ладно.
Значит, передаём ошмётки.

С ошмётками получается трэш и угар какой-то. Потому что всё равно это не
вписывается в корректную схему, в которой должна быть ещё и трансляция выражения
для ключей в вид, где типы - это номерочки.

							     2014-02-13 14:40:18

Ок. Алгоритм без трэша и угара, видимо, такой:

1.
	extractform создаёт именно форму. Она может надыбать указатель на форму
	в недрах окружений. И вернуть этот указать и для setnew это всё OK.
	intakeform должна включить мозг.

2.
	intakeform, если видит, что это ссылка на форму, то должна создать
	внутри себя форму корректно. Если видит, что это определение формы, то
	может его и использовать.

3.
	Соответственно логика и для setnew должна быть примерно такой же.

Вот в этом варианте как раз можно сделать всё однообразно, если с разной
степенью тупизны всё копировать. Ладно. Примерно понятно. Действуем

							     2014-02-18 17:17:43

Косяк, на который опять налетаю :( Пока мы там свои таблицы модифицируем,
указатель на список форм или на граф в окружении могут переехать куда-нибудь.
Поэтому к ним наод обращаться только перед самым использованием.

И уж точно на области реактора не должно быть прямых ссылок во время проходов
по спискам

							     2014-02-24 20:06:55

Да блин. Опять косяки. Ну сколько можно-то!? FEnv неверно отрабатывает вариант с
одним аргументом.

И, видимо, это совсем уродский вариант, когда речь идёт о том, что FEnv
регистрирует форму вместе с ключами для её параметров. Ключ относятся к части
активации формы, а не к её поведению. Это надо учитывать всё.

Придётся переписывать и FEnv и FPut.

Когда ж это всё кончится?

							     2014-02-25 21:03:11

Хорошо. Ещё раз. Что делаем с формами? Во-первых, сигнатуры. Сигнатуры берутся
из графа и всегда копируются. Должно быть так.

А ещё можно просто забить на эти тонкости и всегда копировать. Потому что,
скорее всего, форма будет использована.

							     2014-02-27 13:24:08

Так, видимо, перед тем, как переходить к обработке форм надо сделать обработку
условий. Вроде как не очевидно, что это может понадобится. Но, а вдруг? Ну.
Опять же. Пару операций надо добавить?

	.Ex ("TEnv";
	.Ex ("S";
	.Ex ("FEnv"; ("CVT"; ("F"; 4)));

Ладно. Сойдёт. Плюс сравнение. Оно тоже может быть вида True-False... Так? Да
ладно. Пусть будет .Cmp на все случаи жизни. Можно даже называть Eq

	.Eq (x; y);

							     2014-02-28 09:07:52

Ок. Ладно. Поправки надо внести в reform и registerone. Когда мы реконструируем
форму, то надо создать список из ключей с метками external. Ссылки эти должны
вести на ключи внутри реактора. Поэтому, когда регистрируем форму, то кусочек
сигнатуры надо внутрь неё и копировать. Нужно тогда добавить ещё и возможность
получить ссылку на Ref-у с ключами формы.

Ок. Получается:

1.
	Добавить возможность получать ссылку на Ref-у для формы

2.
	reform должна возвращать заготовку для формы из графа и пустого списка

3.
	registerone должна пересобрать сигнатуры для формы. При этом, ссылки
	можно брать и на output-ключи. Если output-а нет, то копируем
	input-ключ.

4.
	Убедится, что при активации граф формы копируется.

Так нет. Это плохой вариант, потому что мы не можем создать форму без счётчика.
Ну и где-то же посчитать надо будет количество ключей в сигнатуре. Поэтому,
логика другая

1.
	registerone может подправить ссылки в сигнатуре. Логика такая

	1.1.
		Если ключ нашёлся в списке output-ов, то ставим ссылку на ключ в
		output-е, а саму компоненту исходного ключа уничтожаем.

	1.2.
		Если ключ не нашёлся, то создаём новую ячейку в массиве с
		использованием bindkey. Кусочек ключа копируется. Исходный ключ
		уничтожаем, вставляем ссылку на ключ из Binding-а.

2.
	Убедится, что при активации граф формы копируется.

Поехали

1.
	Готово +20 минут

2.
	Готов +3 минуты. activate начинается с ntheval, которая конструирует
	форму при помощи exprewrite, поэтому граф новый создаётся. Вроде как.

							     2014-03-04 15:38:17

Так. Что дальше? Дальше нужно добавть Ex и Eq конструкции. Для Eq нужно оценить
типы, чтобы можно было сравнить ключи. Можно было бы сравнивать и с учётом
ссылок на узлы, но это бессмысленно. Поэтому нужно оценить сначала типы, а потом
уже Eq.

Ex - это запрос на видимость некоторого объекта из текущей области видимости.
Вопрос в именах. Какие имена позволяем? Да без ограничения общности. Пусть ключи
будут всякие.

Ну ладно. Ключи всякие, а дальше?

							     2014-03-04 16:13:10

Что-то оно не клеится опять. Что должно быть результатом areaeval? Новые области
вывода. И ещё результат Go. Ну. Замечательно. Но Go мы хотим выполнять только из
вершины стека. Или из вершины дерева. И чего?

А того, что areaeval должна что-то возвращать. Логика такая: она же живёт в
рамках одного контекста. О стеке она не особо знает. Эту проверку имеет смысл
оставить progress-у.

Ладно. Хорошо. Что дальше? Дальше нужно осознать семантику двух вещей:

	.Rdy () 
	.Rip (0|1; .R (такое-то))

Ещё раз. Ready должно закрывать вывод в контексте. Rip должна собирать этот
контекст.

Со сбором и т.д. Относительно понятно. А вот с Rdy совсем не понятно. Оно должно
как-то быть связано с тем, что контекст можно освобождать. Вечно хранить
контексты очень дорого.

Возможно, такая вот логика будет более корректной:

1.
	Rip-нуть один контекст два раза в общем случае нельзя. Потому что
	накопленный контекст - это форма со своим FOout-ами, которые не могут
	повторяться.

2.
	Тогда мы можем сказать, что после того, как сделали .Rip одна связь
	порвалась. Когда уйдут все связи, контекст можно освобождать.

Ладно. Дополнительная проблема: когда мы говорим .Rdy, то больше никакой
активности в этом контексте быть не может. И, значит, никакие связи не могут
быть больше разорваны. Значит, либо разрывать принудительно, либо сообщать об
ошибке.

Противоречие. Нужна двусторонняя связь между областями. Они равноправные в
некотором смысле. Симметрия нарушается, когда одна из них говорит: я готова.

Тогда такое высказывание верное: контекст можно удалять, когда все окружающие
его контексты готовы, сказали .Rdy ().

Не-Rdy контекст нельзя собирать. Это два высказывания:

1.
	Область можно удалять, когда все окружающие области сказали: я готова.
	Ну, и сама область это сказала.

2.
	Область, которая не сказала Rdy нельзя собирать.

Значит, надо понимать взаимосвязи. Так. Взаимосвязь какая? Когда в одной области
другая известна под определённым именем. Ладно. Когда R1 известна в R2 под
определённым именем, то когда R2 становится Ready, R1 теряет одну активную связь
с мирозданием.

Может быть так, что у нас получится изолированный не-Rdy контекст. Теоретически
и принципиально это означает, что у нас появился некий новый независимый процесс
вывода и это может быть нормально. Что с этим делать - отдельный вопрос. Пока
говорим, что это ошибка.

Когда все окружающие области стали Rdy. Окружающие - это те, кто знает об этой
области. Связь односторонняя. Когда они стали Rdy, то текущую область можно
освобождать. К ней уже никто не обратится.

Ок.

Это всё хозяйство, значит, требует организации следующего:

1.
	При обработке Rdy надо пройтись по всем именованным связям с другими
	контекстами и вычеркнуть текущий контекст из них.

2.
	Что должно заставить изменить поведение makepath. Нужно создать
	необходимые для этого вычёркивания условия.

Ok. Надо развить мысль с makepath. Хватит ли для такого вычёркивания простого
подсчёта ссылок.

Вроде, должно хватить. Потому что Rdy инициируется независимо от количества
ссылок. Поэтому кольцевые структуры должны обрабатываться корректно.

Даже если R1 ссылается на R2, а R2 на R1, то когда R1 становится Rdy, счётчик
уменьшиться в R2. И когда R2 станет Rdy, счётчик уменьшится в R1, и её можно
будет освобождать.

Хорошо. Одна тонкость

	У нас может быть не-Rdy контекст, с соседними Rdy. Если он на вершине
	стека находится. Вроде как.

В makepath, получается, нужно добавить счётчики ссылок. Нужно ли добавлять
обратные связи? Можно добавить. А именем считать тогда первую из списка. Само
имя можно хранить в окружении. А в список вставлять только ссылку на него. Будет
работать.

Хорошо. Что дальше? Дальше надо понять последовательность обработки.

							     2014-03-06 22:08:24

Последовательность обработки. Вообще, для форм надо оценить R-узлы. А, может, не
страдать и сделать вообще отдельно? Сначала R-узлы, затем Rip и Rdy. Но вопрос о
том, как это упорядочить с обработкой форм открытый.

Ну. Rip и Rdy нужно обрабатывать те, которые вне форм стоят. Так? Это вообще с
формами не пересекается. Но R надо обработать до. При этом Rip вообще граф
должен переписать.

А ещё не надо забывать о Go. Ладно. Тогда последовательность такая:

	R
	Формы
	Go Done (Rdy)
	Rip

Замечательно? Ok. Это уже хоть какое-то разбиение на подзадачи.

	reval
	formeval
	goeval
	ripeval

formeval должна выдать список потенциально активных контекстов. goeval должна
выдать признак того, что обнаружен Go. Отработанные области можно чистить и
автоматически.

Ok. Принято. Начать надо с makepath. Для того, чтобы всё заработало нужно

1.
	Добавить счётчик связей. Наверное, имеет смысл сделать нечто вроде
	linkup/linkdown

2.
	Списки имён добавлять по указателям на окружения/контексты. Имена будут
	записаны в самих окружениях, а в списки будут вставлены только
	Ref.external

Ok. Принято. Это уже обозримая перспектива. Дополнительно нужно:

1.
	isconnected

2.
	areadone/isareadone

							     2014-03-07 19:33:12

linkup, linkdown и isconnected сделаны. Однако надо снова открыть вопрос о
поведении makepath в связи с обработкой Done.

Когда мы говорим: Done, то мы проверяем счётчик ссылок. Так? Ну. Типа того. И мы
вычитаем по единичке из каждой связи с другими областями. Значит, увеличивать
его надо, когда связь устанавливается. Так?

А если это ссылки сами на себя? Да хоть 100 штук их. Перед тем, как
окончательно зафиксировать Done счётчик гоним вниз. Ещё раз философское отличие
от простого сборщика мусора со счётчиком:

	Инициирует уничтожение Done, а не структура ссылок.

Так что, всё Ok. А как себя должны вести обратные связи? И Вообще, это же
получается не совсем сборка мусора. Этот метод с Done.

А обратные ссылки нужны? Или можно просто сделать поиском по вхождениям?

							     2014-03-09 16:13:36

Да ёжкин же ж кот! Ну сколько можно напарываться на одну и ту же беду с этими
самыми прыгающими binding-ами?

							     2014-03-11 15:25:45

Ещё одно изменение в makepath. Это основа и для создания областей вывода тоже.
Но с этими областями мы не можем обращаться так же вольно, как с окружениями.
Поэтому в makepath добавлен ещё один параметр - creative. Который меняет режим
работы. Если creative = 1, то это обычный makepath. Если creative = 0, то
makepath отказывается создавать промежуточные значения.

Таким образом, все области вывода создаются только в progress на стеке. А потом
от этого стека отцепляются и т.д.

							     2014-03-11 15:28:14

Кроме этого. Нужно поддержать AREA. При чём надо поддержать её в dumpkeymap.
Гадость.

Следующие шаги, значит

1.
	areaonstack(A, 0|1)
	isareaonstack(A)

2.
	areadone(A)
	isareadone(A)

3.
	В dumpkeymap включить области по признаку: оно на стеке или не на стеке.

4.
	Надо сделать dumpareastack

5.
	Обработка стека в progress

							     2014-03-11 16:21:41

1.
	Готово

2.
	+26m Готово

Просто нельзя уничтожать область, пока её кто-то видит. Вот и всё. Но мы и не
собираемся это делать.

Поэтому, всё ОК. Если кто-то хочет получить доступ через данную область к
другим, то он получит его.

Хотя. Допустим

	R -> R1 (DONE) -> R2 (DONE)

R1 не уничтожаем, потому что R её выидит. И через R может быть доступ. А почему
R2 не уничтожаем?

							     2014-03-18 08:48:25

Приветствую, коллеги. Я пишу дополнительно ещё нескольким продвинутым
программистам, в надежде на их участие в диалоге. Если будете отвечать,
то кликайте на "ответ всем".

В общем, залип я на управлении этими контекстами. Попробую расписать всё
в виде свободного текста, может, поможет. Ну, и на советы тоже надеюсь.

Есть пара источников проблем и сомнений. Наверное, один такой более
абстрактный, а другой конкретный. Но оба они связаны с неочевидностью
ответа на вопрос: как нам корректно интерпретировать область вывода, и
когда же от неё избавляться. Если не избавляться, то пожирается память.
При чём, в огромных количествах.

Про RiDE.
	Наш компилятор не является компилятором в вакууме. Он построен
	примерно так же, как наша система распределённого
	программирования RiDE. Она так же предназначена для
	динамического построения графа. Только там строится граф потока
	данных распределённого процесса, а не граф программы. Но суть
	примерно одинаковая: есть правила (аналогичны формам в
	компиляторе), которые запускаются, когда готовы их входы. Они
	могут породить данные на выходах, которые потом подключатся к
	другим входам, и новые правила.

	В общем, полный аналог форм в lime, только более... Эмс. Нельзя
	сказать, что общего назначения. Более высокого уровня, может
	быть.

	Так вот. В системе RiDE (в одном из вариантов, который лучше
	всего проработан теоретически) тоже есть области вывода. Чтобы
	можно было одно вычисление изолировать от другого. И провести
	нечто по частям.

	Ими достаточно просто управлять: пока об области вывода знает
	некая форма (буду называть так правила, чтобы быть ближе к
	компилятору), или некая другая живая область вывода, то область
	вывода живая. Когда формы забывают об областях вывода, когда она
	не указана на входе или выходе одного из правил, то система
	забывает форму.

	Примерно так. Чтобы не забывать какую-то область вывода формы
	явно передают её друг дружке.

	Хм. Может, это и не самый прямолинейный вариант, но он очевидно
	и эффективно реализуется. И он достаточно выразительный, чтобы
	обеспечить в RiDE схемы для описания циклов типа while/for и
	т.д.

	Ну и можно строго доказать, что с такими областями вывода мы
	получаем универсальную систему исчислений, полную по Тьюрингу
	(или Чёрчу, или кому кто больше нравится).

	Ещё раз подчеркну особенности. Для самого себя:

	1.
		Чтобы область вывода оставалось живой, её должна хотеть
		какая-то форма. То есть, если форма F знает об области
		L, то если она не хочет забыть об L, то она должна
		породить форму, которая на эту L будет ссылаться.

		Ага. И вот тут вот первое тонкое отличие от LiME. В LiME
		выход может жить в контексте относительно долго.

		Но это не проблема на самом деле. И в RiDE (допустим,
		это вариант от меня. Поэтому в RiDE.mb; у нас есть ещё
		вариант от Паши), и в RiDE.mb выход может жить
		относительно долго в некой области вывода, дожидаясь
		появления формы, которой он нужен. В компиляторе так же.
		Всё ОК.

		В RiDE.mb можно ссылку на область вывода (или на
		какой-то выход или вход) передать в другое правило
		непосредственно. И этим обеспечивается threading
		областей вывода по вычислению.

		А можно и не непосредственно передавать эту ссылку. В
		RiDE.mb есть понятие о локальной группе форм, и пока эти
		формы не обработаны, все объекты, которые в этой группе
		упоминаются, считаются живыми.

		О! Это надо запомнить. Есть локальные группы форм. И на
		самом деле, хотя, вроде как логически, эти время жизни
		данных привязана именно к формам. Но технически, нужно
		привязывать их сначала к локальным группам, а потом
		когда обработка групп завершена уже к конкретным
		правилам.

		Зачем я об этом? А затем, что возникает вопрос: не
		являются ли эти локальные группы правил аналогом области
		вывода в компиляторе?

		Так. Это Q1:
			Не эквивалентны ли области вывода в LiME
			локальным группам форм в RiDE.

	2.
		В компиляторе, в отличии от RiDE.mb есть фишка.
		Накопленная область вывода сама может превращаться в
		форму. Это необходимо, потому что нам надо формировать
		формы для структур (сюда попадают и union) и для функций
		во время обработки исходного кода. Потому что их нельзя
		прописать заранее и нужно делать это динамически.

		В RiDE.mb все области вывода являются пассивными
		объектами. Они помнят имена, но превратить их в форму
		нельзя.

		Хотя, теоретически, это можно было бы сделать.

		Q2:
			А оно нам надо? Превращать области вывода RiDE в
			формы? Может и не надо. Но возможность есть
			такая. Ладно. Это не суть.

	3.
		Есть ли ещё важные особенности? Да, видимо. Как раз о
		временах жизни ещё раз. В RiDE.mb область видимости
		будет висеть до тех пор, пока есть правила, которые
		хотят эту область видимости. Но эти формы могут никогда
		не сработать, потому что никогда не возникнут нужные им
		выходы. Так? Так.

		В LiME некоторые формы вполне могут не сработать из-за
		того, что система готова к тому, что кое-что не
		понадобится. Уточняю, когда мы видим выражение

			a = a + b;

		То «a» должно вызывать справа и слева от «=» нечто
		первоначально одинаковое, но что может превратится слева
		в lvalue (адрес для записи), а справа в rvalue
		(прочитанное из памяти значение). А раз оно должно быть
		разным, то какие-то формы не сработают.

		АГА:
			Видимо, здесь и лежит ключевое различие между
			областями RiDE.mb и LiME. Области в LiME должны
			уметь закрываться, даже если в них есть активные
			формы.

		Ok. Фиксируем. И тогда резко переходим к LiME.

Про наш ВК-01 (Велосипед Компиляторный):
	Но если так, должен быть другой признак возможности освободить
	контекст. Для этого в LiME предусмотрена конструкция «Done».
	Если какая-то форма сообщает о том, что вывод в текущей области
	закончен, то он закончен. Дальнейшее обновление информации в
	этой области невозможно.

	Ok:
		Это понятно. Значит, надо отслеживать этот признак
		готовности и не позволять использовать эту область в
		конструировании новых цепочек областей вывода (они же
		связаны как граф у нас).
	
	Но при этом сама область сформирована как некоторое значение. И
	оно может быть использовано, как источник данных или форм (на
	самом деле в компиляторе все данные - это формы) для других
	областей вывода.

	И вот тут как раз и возникает вопрос, который насилует мне мозг:

	Q:
		До каких пор, чёрт возьми, хранить эту самую область
		вывода?
	
	Мы могли бы её хранить бесконечно долго. Но, блин, память же вся
	утекать будет на эти области вывода, потому что мы по одной
	создаём на каждый токен в исходном тексте.

	Значит, нужны правила удаления. Если мы сделаем явный Delete, то
	это не будет выходом, потому что а откуда форме, которая хочет
	сказать «Delete» знать о том, что этот контекст не будет
	использован ещё и в других местах? Такое запросто может быть,
	например, с областями, которые описывают анонимные структуры. Их
	просто некуда привязывать в окружениях. Они сущности временные.

	Ok. Отбрасываем этот вариант. Следующий вариант - сборка мусора.
	Тоже не особо подходит. Потому что, единственное, как мы можем
	судить о том, нужна или не нужна область вывода в другой области
	вывода - это наличие связи между ними. Так?

	А если просто сказать «Done», то на число связей это не влияет.
	И все области вывода потянутся длинным паровозиком за свои
	перекрёстные ссылки и их просто не будет повода освобождать.

	Ok. Отбрасываем. Но тут есть важное замечание.

	АГА:
		Область вывода R1 может быть использована в области
		вывода R2 только в том случае, если в R2 есть ссылка на
		R1 (может быть и не прямая, а через другие области).

	АГА:
		Оу. Тут, кажется, проясняется решение.
	
Потенциальный вариант управления областями вывода для ВК-01:
	Итак, нам надо редактировать связи между областями вывода, чтобы
	управлять процессом их освобождения. Если какая-то область
	вывода больше не видна из других областей, её можно освобождать.
	Плюс ещё проверить, что она Done. На самом деле, всё будет
	работать, даже если какая-то область ушла в одиночное плавание,
	но смысл такого поведения не очевиден.

	Ладно. Это лирика. Не лирика в том, что метод всё-равно не особо
	рабочий, потому что даже если мы сделаем нечто вроде:

		.Unlink (.R (("some"; "area"; "path")));
	
	То всё разболтается. Потому что, как и в случае с
	не-активными формами, которые не должны нас удерживать от
	освобождения области вывода, мы просто в общем случае можем не
	знать все имена всех привязанных к данной области вывода
	областей.

	Но у нас есть событие, на которое можно повесить освобождение
	всего подряд: если окончательно отцеплена область вывода,
	помеченная, как завершённая (то есть, «Done»), то можно
	отцеплять вообще всё, что к ней прицеплено. Ну и понятно, что
	сделать это можно рекурсивно.

	Ok. Это вариант номер 1. Он даёт больше свободы, но меньше
	надёжности. И больше if-ов в коде:

	1.
		Можем ли мы делать Unlink того, чего лежит в другой
		области вывода? Не нарушение ли это целостности? Другие
		формы же не особо в курсе нашего Unlink-а могут быть.
	
	2.
		А не получится ли так, что мы всё-равно должны будем
		передавать области вывода R1, ..., RN, которые являются
		значимыми для некоторых r1, ..., rk, в эти самые r1,
		..., rk и уведмолять их о именах этих областей, чтобы
		они rI могли к ним привязаться?

		То есть, мы должны будем передать Ri в rj, а потом
		сделать (unlink Ri) в текущей области. Или не должны
		будем сделать? А если не должны, то кто потом сделает
		unlink?
		
		Тут можно попробовать согласовать всё с (1): мы можем
		отцеплять формы из done-областей. Хотя, опять же
		проблема, мы же понятия не имеем о внутренних именах
		этих областей.
	
	3.
		И т.д. И т.п.
	
	На самом деле, кажется, именно из-за таких заморочек в RiDE.mb и
	нет явного unlink. Видимо, это такая карма распределённых
	параллельных систем со слабой связностью (эта слабая связность -
	то преимущество за которым мы гоняемся, потому что она позволяет
	уменьшить объём работы на поддержку этой связности). Мы уже в
	LiME это показываем автоматизацией процесса продвижения типов.

	Ладно. Это опять лирика. Не лирика.

	Для снижения степени неопределённости можно принять такую
	систему правил:

	1.
		Когда область говорит сама себе «Done», она закрывает
		все связи с соседями.
	
	2.
		Если область вывода никто не видит, мы можем её
		уничтожать.
	
	3.
		В done-областях нельзя создавать новые области. Иначе
		ошибка.
	
	Проблема только в том, как дать понять формам, что лавочка
	закрыта? Как избежать гонки на публикацию/закрытие?

ВК-01. После обсуждения с коллегой.
	Возможно, никакой проблемы с гонками и нет. Потому что публикации
	публикациями, но если область вывода сказала Done, то это уже Done и
	новая поступившая информация не будет принята к сведению. Но может быть
	тонкая проблема в том, что кто-то успел забросить формы в область
	вывода, а потом область вывода сказала Done, но формы успели прокрутится
	и что-то выдать в 1-ый контекст.

	Но на самом деле это не так страшно. Это отслеживаемая ошибка. Хотя,
	может быть и трудно отслеживаемая.

	То есть, такой метод с Done и с явной передачей ссылок на области
	вывода между другими областями может сработать.

	Но есть такое стойкое ощущение, что в нашем текущем варианте областей
	вывода смешаны две сущности. Собственно, некая сущность для вывода
	некоторого представления участка программы и само представление участка
	программы. Так?

	Если бы это представление было бы оторвано от контекста вывода, то всё
	было бы намного проще. Потому что тогда области вывода передавали бы
	ссылку на это представление. И само бы представление умирало бы вместе с
	Done последней из областей.

	Это прямо подобие оригинального поведения RiDE. Хорошо. Это подобие.
	Можно распространить аналогию.

	1.
		Контекст вывода - это локальная группа правил RiDE. Только у нас
		она уже не совсем локальная, а живущая до тех пор пока Done в
		ней не случится.

	2.
		Другая терминология - это такая анонимная область вывода. Без
		имени... Хм. Но ладно. Не надо эту терминологию.

	3.
		Ещё одна перефразировка. Реактор R0 - это на самом деле активная
		область вывода и локальная группа правил. Граф и R1 - это,
		собственно одна сущность, которая результат работы.

	Чтобы такая логика работала нам нужно нечто вроде:

		FPut(.R (такой-то); нечто).

	Но у нас такая логика и без того есть. ХммМмм. А в чём фишка и
	особенность? Там бы фишка и тонкость была бы в том, что мы бы писали в
	сигнатуре формы эти самые .R-ки для каждого входа.

ВК-01. Идеальная схема.
	Идеальная схема, значит, такая:

	1.
		Есть области вывода. В которых происходит сопоставление входов с
		выходом и активация форм. Формы привязаны к этим областям вывода
		и могут сообщить о том, что некая область завершила свою
		активность.

		В RiDE этому аналог - локальная группа правил.

		Ещё более точно здесь речь может идти о некотором процессе
		вычисления, к которому можно приписать развёртывающиеся формы.
		Процесс может быть завершён, в частности, если выполняется
		инструкция Done (это как exit из мира UNIX).

	2.
		Есть области обмена. Через которые формы из разных областей
		вывода могут обмениваться данным. Такую область можно
		формализовать как уникальный префикс в сигнатурах выходов.
		Соответственно, при публикации форм этот префикс нужно
		указывать. Некоторые области можно создавать автоматически и
		управлять возможностью размещения в них имён, разруливать
		конфликты и т.д.

		В этом случае формы должны уметь регистрироваться в этих
		областях обмена и всё такое прочее.

	Видимо, терминология должна быть такой: процесс развёртывания графа надо
	выделить именно как процесс. А ту область памяти, где регистрируются
	входы и выходы нужно называть областями вывода.

	3.
		В случае с компилятором на каждый токен у нас создаётся

		1.
			Процесс вывода

		2.
			Область вывода для локального пользования

		3.
			Области вывода для взаимодействия с другими процессами
			для других токенов.
		
		Это идеальный такой вариант.

	4.
		А идеальный он, потому что очень легко в такой постановке
		управлять временами жизни сущностей.

		1.
			Процесс живёт, пока живо хотя бы одно правило или пока
			для него не выполнено Done.

		2.
			Области вывода живут, пока на них есть ссылки из живых
			процессов.

			Можно так же добавить условие: или из живых областей
			вывода, потому что для lime это тоже работает хорошо:

			Пример с «a + b»:

			1.
				Когда завершается процесс вывода для «a», то
				должна закрываться внутренняя область вывода
				(ссылка только у одного процесса есть).

			2.
				К этому моменту уже должна быть связь с
				процессом вывода для «+» через общую для этих
				процессов область вывода. Которую видно и там, и
				там. Или это могут быть две области с разным
				направлением обмена.

				В любом случае, одна ссылка закрывается. Когда
				завершится процесс вывода для «+» закроется и
				другая ссылка. И ничего из этого тянуться наверх
				не будет.

			3.
				Даже в том случае, если ссылка на область
				видимости залипнет в какой-нибудь области
				видимости для «+». Ну, если «+» решит что-то
				передать наверх, то он сможет это сделать.

			Ок. То есть, в таком варианте система подсчёта ссылок
			работает. И хорошо подходит для управления в LiME.
	
	5.
		Тут важно не упускать из виду ещё один момент: возможность
		динамически накопить некоторую форму. Превратить данные в
		программу и завершить тем самым круговорот информации в
		компиляторе.

		Ну. В общем-то тем же самым способом, что и для текущего
		варианта LiME:

		1.
			Взять накопленный в области вывода граф.

		2.
			Взять все помеченные выходы из этого графа в текущей
			области. И даже проследить, что других нет. И дописать
			один большой FOut к накопленному графу.

		3.
			Взять .FIn-ы из этой накопленной области и понаписать
			.FPut-ов с соответствующими формами, которые к этим
			.FIn-ам привязаны. В общем-то и всё.

		4.
			При этом, вроде как, префикс, определяющий область
			вывода, в котором всё это накоплено, должен быть стёрт.

		5.
			Видимо, эти префиксы должны быть примерно так же
			устроены, как префиксы в CSP.

Немного детализации областей вывода с привлечением CSP.
	Тоже не помешает для формирования полноты картины. В CSP тоже есть
	концепция областей видимости. Они устроены проще, чем то что нужно для
	RiDE и LiME но служат примерно той же цели: изоляция процессов друг от
	друга и абстрагирование их.

	Области видимости там создаются при помощи фиксирования префиксов для
	всех событий, происходящих в дочерних процессах. И общую картину
	наблюдает родительский процесс.

	Дочерние процессы не могут добраться друг для друга при такой схеме.
	Возможно, это нас существенно ограничивает. Возможно, имела бы смысл
	возможность передавать эти префиксы через каналы связи между процессами,
	чтобы связывать их друг с другом.

	Что-то такое, возможно, через костыли можно сделать в CSP. Но надо
	дополнительно анализировать.

	Тут основная фишка, на которую хочется обратить своё внимание такая:
		
		Эти самые префиксы назначаются процессам для процессов же.
	
	Здесь тонкий вопрос для нас. К чему должны быть привязаны области
	видимости? К процессам и другим областям видимости? Или только к
	процессам.

	Можно вспомнить и сети Петри, где есть разделение на места (допустим,
	аналог областей) и действия (допустим, аналог процессов). И действия с
	действиями непосредственно не связаны, как и области. Может быть, в этом
	есть тонкая философская истина?

	По идее, основной вопрос вот в чём. Допустим, у нас есть процесс,
	который наплодил область вывода L1. А потом может там наплодится область
	вывода L2?

		L1.L2
	
	Как бы, абстрактно да, может. Мы все любим деревянные структуры. Ну и на
	самом деле, тут надо задавать вопрос.

	Q:
		А каким же ещё мистически-магическим образом можно будет
		группировать тучи сложных объектов в нечто единое целое с единой
		точкой доступа?
	
	Q:
		Есть ли альтернативные варианты? Это важно понять, потому что
		определение времени жизни области двумя параметрами создаёт
		дополнительные if-ы и сложности. Хотелось бы их минимизировать
		на системном уровне.
	
	А:
		Видимо да. Можно рассматривать альтернативное решение. Когда
		области видимости связывают процессы, через них можно добраться
		до искомых данных по URL-ям. Некий вариант DNS-а. Но такое
		ощущение, что это не то.

	Интуитивно, скорее всего, области видимости хоть и должны начинаться в
	каких-то процессах, но сами тоже должны формировать структуру с
	управлением по ссылкам. Как файловая система.

	Ок. Пусть так. Не ограничиваемся CSP.

	Но пора с высот не особо конкретного теоретико-философского потока
	сознания вернуться в многострадальный код компилятора. Там есть такой
	файлик lib/lime/keymap.c. Он реально многострадальный.

ВК-01. Теперь о печальках.
	В текущей реализации у нас нет разделения на процессы и области вывода.
	У нас всё в куче. Что плохо и не красиво. Но всё-равно, надо ставить
	вопрос о том, можно ли текущую реализацию свести к идеальной с минимумом
	потерь по времени. Желательно, за 2-3 дня. Во второй версии кода будем
	уже делать идеальное и корректное решение.

	Итак, сейчас у нас область вывода (в идеальной терминологии) это
	процесс и пара областей вывода: текущая и на будущее. Которая, вроде
	как, прилепляется в тот контекст, который её хочет забрать.

	Прилепляется она всей своей сущностью.

	Но мы всё-равно можем оперировать идеальной терминологией для описания
	происходящего. И, возможно, нам даже не придётся ничего переписывать, а
	добавить пару if-ов в нужные места.

Рано. Нужно вернуться в абстрактный полёт мысли. Потому что процессы.
	Процессы - это простая сущность. Некий идентификатор для множества
	форм. Вроде как.

	По идее, сценарии для процесса такие:

	1.
		Его запускают и говорят: вот, работай дорогой. Твои области
		вывода, результат сюда, ограничения на пространство имён
		такое-то.

	2.
		Процесс работает. Что-то там привязывает куда-нибудь. Одни
		области в другие. Запускает новые процессы. Формирует формы.

	3.
		Потом завершается и его результаты подхватывают другие процессы.
	
	Ок. В LiME У нас нет ничего специального для порождения процессов.
	Каждый входной токен их порождает. Вроде, это логично. В RiDE может быть
	специальная зюквочка для указания на то, что вот эта форма будет
	запускаться в новом процессе.

	Хотя. Про LiME вру. Там же есть команда Go, которая должна
	интерпретироваться так: а перейдём-ка мы, дорогой наш, к новому токену.
	Это, собственно, и есть формирование процесса.

Возврат на землю исходников на Си
	Ок. Итак, что у нас есть в Велосипеде? Напомню себе идеальную
	терминологию

	Область вывода:
		Штука, в которой живут выходы и через которую формы цепляются к
		ним через свои входы.
	
	Процесс:
		Это процесс активации форм. Место привязки создаваемых областей
		вывода и выброшенных в процесс вывода форм.

	В LiME сейчас нет ни того, ни другого. Там есть некая сборная сущность,
	которая называется в исходниках область (AREA), но это не область
	вывода, как сейчас понятно. Буду здесь эти штуки называть реакторами.
	В исхониках реакторами называются два компонента этой самой AREA, но
	они-то как раз и являются областями вывода. Более близки к этому
	понятию.

	Но пока абстрагируемся. Есть просто реактор.

Пока всё ещё рано.
	Есть проблема с for. В дереве for глубоко зарыты те «;», которые должны
	приводить к синтезу инициализации, условия, инкремента, тела и т.д.

	Они должны быть сформированы. Ладно. Хорошо.

	Если это делать через систему иерархического именования, то это адский
	ад. Потому что имена должны быть типа таких:
		R; R; L
	
	Для for это ещё фиксированная структура. А что делать с case-ами? Где
	дерево будет динамическое. А со структурами что?

	Тут может приходить в голову очевидное решение:
		А реализовать просто оба механизма и не страдать. Но не факт,
		что это просто. Потому что два таких механизма потребуют их
		согласовать, и, видимо, потребуют возможности вписывания в
		иерархию областей видимости той области, что приходит от другого
		процесса. Тут ещё возникает вопрос: а как вообще передавать эту
		область видимости между процессами?
	
	На самом деле, даже если передать, то может получится непонятка. Потому
	что, придётся их merge-ить, если вписывать в некоторую иерархию имён.
	Может это, кстати, и не так уж и страшно.

	Кстати, вполне можно заявить:
		А пошло оно всё лесом, просто постараемся сделать эффективный
		merge и получим нечто вроде Oz.

	Но это всё абстракции, которые не решают проблему с for. Как её решать?
	После обработки соответствующего дерева надо получить на уровне значения
	для for 4 значения со сформированными init, condition, iterator, body.
	Всё в разных областях вывода. Чтобы можно было сделать Rip-ы. Чтобы они,
	на самом деле, были ещё тёпленькими и активными процессами.

	Проблем на самом деле больше. Потому что:
		Вот рассмотрим мы структуру дерева for. И что мы видим? Кучу
		операторов, которые вообще ничего о for-то и не знают по
		большому счёту. И они не должны о нём ничего знать.

		Знать должны несколько операторов, определяющих структуру дерева
		for. И хотелось бы только их программировать особо.

		При этом, сколько шагов и промежуточных конструкций потребуется
		для завершения обработки for мы тоже не знаем. Мы можем знать
		только о локальных связях между процессами (реакторами), которые
		это всё обрабатывают.
	
	Теоретически, можно было бы сделать какой-нибудь REnv, в котором бы
	публиковалась ссылка на реактор, и через которую можно было бы засылать
	информацию в верхний процесс вывода. Только задница в том, что:
		Этот процесс ещё не будет сформирован. Вообще, априори не
		известно, когда он возникнет, потому что последний процесс
		формирования for - это применение его заголовка к телу.

		А длина тела и, соответственно, число промежуточных шагов не
		известны.

	Теоретически, проблему можно было бы решить, если бы все формы... Оу.
	Начиная со слова «если бы все формы ждали» уже не хочется рассматривать
	такое решение. Слишком много взаимосвязей получается.

	Ладно. Но, похоже, тут неплохо работает решение с иерархическими
	областями вывода без явной их передачи между процессами. То есть, каждый
	процесс может создать область, но механизм явной передачи тут не нужен.
	
	Рассмотрим одну из «;» в for. Допустим, первую. Когда для этой «;»
	придёт E, то слева и справа будут накоплены некоторые области. Возможно,
	там даже будут живые процессы вывода. Да и вообще, будут, конечно же.

	Мы можем взять эти L и R области (или области + процессы; в идеальном
	случае связь с процессом связь через области и осуществляется) и
	сказать, что сейчас мы в области E знаем их под именами init и
	condition.

	Когда мы увидим «E ;» для второй «;», то там будет опять L и R. Слева мы
	возьмём под новыми именами в текущей области для E L.init и
	L.condition. Справа возьмём increment. Потом, через FOut отправим налево
	некий выход, который активирует Done в левом процессе.

	Это ещё не закроет все области вывода в этом процессе, потому что их
	будет видеть обрабатываемая вторая «;». Но одна закроется, которая
	отвечает за связи с другими областями.

	Когда закроется процесс второй «;» закроется его связь с областями
	первой «;» и все ей области тоже будут закрыты. Кроме L.init и
	L.condition, которые будут переданы далее, на уровень выше.

	То есть, область вывода может жить, если не предпринимать особых усилий
	не более чем на двух уровнях.

21.	Ok. Обратно к ВК LiME

	Итак. Как примерно уже понятно, каждый реактор - это три области
	вывода.

	1.	Рабочая область 0. На которую есть ссылки у самого реактора и у
		реакторов, стоящих выше по дереву. Это:

			.R (0; ...)

	2.	Область, в которой накапливается граф и формы с входами и
		выходами на тот случай, если кто-то решит превратить эту область
		в новую форму (обработка структур и функций).

			.R (1; ...)
	
	3.	Область, через которую осуществляется связь с другими
		реакторами. Вообще, уместно её считать корнем областей для
		реактора и ссылки на первые две области прямо в ней и держать.
	
	И один процесс, который с ними работает.

	Ок. Вся фишечка должна быть зарыта в толковании ссылок .R в разных
	условиях.

	1.	Когда мы связываем реакторы через

			.R (("X"; "Y"; "Z"); .R (("x"; "a"; "b")))

		то мы должны работать в третьей области вывода, где речь идёт о
		связях.

	2.	Когда мы ссылаемся на реактор в .FOut, .FPut, то мы ссылается
		на нулевую область вывода в соответствующем реакторе

			.FPut (.R (("X"; "Y"; "Z")); ...);

	3.	Когда мы ссылаемся на результат выполнения процесса

	Так. Это не работает. Уточнения по новому кругу. Реактор - это:

	1.	0 и 1 области вывода. Они должны идти парой, как связь между
		процессами вывода. Имеет смысл сделать структуру 0, в которую
		вложена 1. Граф записывается в 1.
	
	2.	Описание связности между реакторами. Должно идти отдельно от
		пары 0-1. Связность при этом задаётся ссылками на эти самые 0-1
		пары. Процессы видят друг друга через свои каналы
		взаимодействия.
	
	3.	Процесс. Собственно, это таблица со ссылками на 0-1 пару и
		описание связности.
	
	Про структуру ссылок:

	1.	Когда связываются реакторы «.R (...; .R (...))», то это
		установка ссылки из области связности на 0-1 пару
		соответствующего реактора. Поиск реактора происходит по именам.
	
	Да чёрт подери. Чтобы сказать .R ("init"; .R("L"; "init"))

22.	Да ваш же init за сокет. Что ж такое-то? Но как говорил Морфей: Again!

	У нас есть дерево. Если нарисовать. То каждая вершина - процесс вывода.
	Каждое ребро - канал связи между процессами в виде пары областей вывода:
	0 и 1.

	Мы должны уметь передавать каналы связи между процессами, от одного к
	другому.

	Так как нам необходимо, чтобы процессы были связаны только через эти
	каналы, надо моделировать так, что через канал можно «спросить»: чувак
	с которым я общаюсь через L, есть ли у тебя связь по имени init, и если
	есть, дай мне её.

	Значит, структура должна быть такой:

	1.
		Области 0 и 1. Два поля в этой структуре.

	2.
		Таблица связей.

	Когда процессы связываются, то они связываются через эту структуру. У
	неё есть счётчик ссылок, всё такое. Но о таблице связей «знает» только
	сам процесс. Когда он говорит «Done», то эта связь обрывается. Счётчики
	ссылок на каналы, о которых он знает, уменьшаются, всё умирает.

	Поэтому первая «;» в for должна жить, пока не передаст свои ссылки
	вверх.

	Когда процесс сделает «Done», то можно закрыть 0 и таблицу связей.
	Дальнейшие попытки маршрутизироваться через этот узел работать не
	будут. Особенность требует осмысления. Но некогда.

	1.	Когда связываем два реактора:

			.R(("init"; "x"; "y"; "z"); .R(("L"; "init")));

		связь всегда локальная. Берётся первый аргумент в качестве
		ключа. Второе - это как поисковый запрос. Идём сначала по связи
		"L", смотрим, есть ли там "init". Если есть, то его возвращаем.
		Если канал закрыт или процесс завершился, то говорим: ошибка.

	2.	Когда делаем FOut или FPut поиск такой же. После завершения
		поиска берём первую область.

	3.	Когда делаем Rip, FEnv или FPut с реактором вместо формы, то
		поиск такой же, но берём область 1.
	
	Скорее всего, далеко искать неправильно. Искать надо в локальных
	привязках.

	Ok. Видимо, это рабочий вариант. Поехали

							     2014-03-18 12:40:52

План работ:

1.
	Вернуть makepath обратно.

2.
	Отказаться от external/!external меток для связи окружений. Тут нужны
	счётчики ссылок. И две процедуры: link, unlink

3.
	Dumpkeymap для отладки должен иначе работать. У него должна быть карта
	напечатанных keymap-ов, и он должен выводить те, которые ещё не
	распечатаны.

4.
	Написать makeareapath по аналогии с makepath но с учётом конструктивных
	особенностей. Для этого:

	4.1.
		Переделать структуру ссылок в newarea (и, соответственно в
		get-функциях).
	
	4.2.
		Аккуратно использовать link

5.
	Написать dumpareastack. Нужно ввести карту уже напечатанных окружений. А
	те, что не напечатны с этой картой печатать в dumpkeymap. Интерфейс
	dumpkeymap должен быть немного изменён.

6.
	Реализовать reval для оценки узлов .R

							     2014-03-18 15:13:59

link должна быть похожа на один шаг в makepath:

1.
	Если что-то нашлось, то target должна быть FREE.

2.
	Если не нашлось, то target не должна быть FREE. В принципе, можно и пару
	раз вызвать. Ничего страшного не будет.

	А там уже решить, что с этим делать.

Счётчик? Счётчик, видимо, надо держать внутри. Ну. Этот самый linkup. Для unlink
важно знать не isconnected, а linkcount

Ok. Принято. Поехали

							     2014-03-19 13:11:46

Так. Что мы делаем дальше? Делаем счётчики в link. Это как бы инициализация
будет для unlink потом. Ладно. Будем инициировать self и this, и они будут
держать последнюю ссылку. Ну, собственно, как «.» в Unix-овых fs.

Ладно. Замечательно. Но unlink должен быть хитрым. Сначала надо проверить, кто
умрёт. Надо составить список покойников, и почистить их freekeymap-ом.

Если у нас вдруг возникнет активный покойник, то это будет ошибкой и процесс
удаления не будет продолжен.

freekeymap должен убеждаться, что счётчик сброшен. Ок. И должен убеждаться в
ходе процесса, что все ссылки на MAP и AREA у него external-ы.

Ok. Поехали

							     2014-03-20 15:49:07

Что должно быть в dumpkeymap? Там должен какой-то анализ уже посещённых узлов. И
куда не надо лезть. Этот if где должен стоять? В том месте, где копится список.
Ну. Вроде, выглядит логично.

Должно быть только dumpkeymapcore, которое как параметр visited получает.

Так. У нас ещё есть всякие распечатки, где не известны ни U, ни escape. Ну и
ладно. escape-а не будет. Это отладочная печать. Там где U известно, можно
stdupstream использовать.

							     2014-03-21 22:18:35

Ок. unlink должен проходить в несколько стадий:

1.
	modelkill. Своя visited нужна. Это стадия моделирования очистки. Надо
	уменьшать не реальные счётчики, а модельные, в отображении.

	Ну. Супер.

2.
	Надо проверить, что если счётчик нулевой, то отображение не активно.

3.
	Выполнить реальный unlink. Нужна новая visited.

Ok. Принятно. Поехали.

							     2014-03-22 09:42:57

Вопрос только в том, а зачем нужно visited? По идее, мы проходим ниже только
тогда, когда счётчик до нуля дошёл. Он не может дойти несколько раз до этого
нуля. Если мы видим ссылку, которая ведёт на дошедшее до нуля значение, то это
assert и внутренний баг в коде.

Ок. И id нам особо знать тоже не надо для работы. bid нужен только при удалении,
чтобы ref почистить.

Ok. А вот что реально нужно, так это проверка на то, что у нас link. Ну ладно.
Поехали.

							     2014-03-22 20:55:11

Так. Опять что-то не так. В makeone st->current должна указывать на сущность
созданную последней, а не на какую-то её подструктуру. Поэтому nextpoint надо
вызвать в начале, а не в конце всей этой процедуры.

Ок. Вспоминая Морфея: AGAIN!

							     2014-03-24 08:42:11

Так ещё раз про Go. Основной цикл обработки - это два цикла.

1.
	Идём по активным областям вывода и копим новые области в списке после
	обработки форм, которые могут зажечь разные области через FPut/FOut

2.
	Для каждой активной области нужно прокручивать набор активных форм.

Проблема во втором пункте. Не хочется повторно вызывать Go. Ну оно смысла не
имеет, пока область снова не оказалась на вершине стека.

Ну. Видимо, логичнее сделать так.

	Крутим второй цикл, пока есть активные формы, или пока Go не
	встретили Go. Если Go встретили, то выходим на второй цикл с новой
	областью на стеке.

Можно, конечно, пробовать отследить, что вот, цель для Go уже задана и мы второй
раз не вызовем. Но это не особо корректно потому что для L/E Go надо вызывать
два раза.

Ок. Ладно. Принимаем логичный вариант. Какой цикл должен быть? Видимо такой:

	Крутим цикл по активным формам. envtogo запоминаем. Два раза Go не может
	быть в списке активных форм.

	Ладно. Значит прокрутили формы. Определили envtogo. Если оно NULL,
	переходим к следующей активной формы.

	Если не NULL, то идём дальше и расширяем список активных областей.

Ок. Принято. Что это означает для goeval? Ну. То и означает: что надо проверить
envtogo, потом установить, ну и bla-bla-bla по плану. Только надо уметь
проверять ещё расположенность контекста на вершине стека.

							     2014-03-24 17:28:58

Так. Небольшая заминка с процессом обработки. Основной вопрос: а что если один
контекст начался в одной области, а потом сделал Go в другую. И что? В каком его
обрабатывать?

А что делать с L и E?

По идее, надо бы помнить, где область живёт. Это можно прямо в ней и хранить.
Можно.

Тогда это затянется в dump-илку.

Ладно. Затянется. Для .E окружение должно игнорироваться. Потому что мы не можем
по текущему выражению определить: пора нам возвращаться или нет.

Значит, нужна ссылка на соответствующее окружение из области.

Хорошо. Что ещё? Ещё стек из областей и список активных.

Далее progress. Progress должна выходить как раз тогда, когда обнаруживается Go.
При этом, список активностей у неё всё равно есть. Так?

То есть, она выходит, и говорит: хочу следующий элемент. Если выходит и не
говорит, надо проверить файл на конец и стек вывода на длину в 1 элемент. И
отсутствие активности.

Иначе надо сообщать о достижении stuck-состояния. Ну. Или как-то так.

2.
	progress сам себе должен запоминать в какое он состояние пойдёт, после
	возврата управления вверх. Поэтому поле env - это envtogo.

	На первом шаге можно инициировать root-ом, что логично.

3.
	При создании области вывода, на неё надо навешивать синтаксическую
	метку, чтобы потом проверять согласованность E-конструкций.

4.
	Видимо, при создании области вывода на неё надо ещё навешать то
	окружение, в котором она будет работать.

	Тут специальных функций не надо. Это конструируется один раз и на долго.
	Связывать можно link-ом.

Это всё миленько, конечно же, только что делать с промежуточными областями,
которые хочется порождать?

В качестве маркера можно пустышку сунуть.

В качестве окружения текущее. Ключ имеет смысл копировать внутри newarea.
Вернуть ссылку можно на область с Ref.external. Ладно.

Поехали.

Так. К вопросу о progress. progress может и сама понимать, может ли она
продолжать дальше и всё такое прочее. Собственно, выход из неё это сигнал о том,
что она хочет новый токен. Токен нужно помещать на вершину стека. Ок. Поехали.

							     2014-03-26 14:54:43

Так. Как у нас цикл обработки областей должен работать?

Возможно, имеет смысл разделить ignite и progress явно. Ладно. Разделим. В
progress должна накапливаться информация об активных областях вывода. Так?

Область активная, если в неё пишется какая-то информация. Так? Точнее,
записалась. Как понять, что текущая область активная?

А она и так активная до посинения будет. Go же решено сделать отложенным. Так?
Она активная до исчерпания. Поэтому если обрабатываем текущую область,
специально её засовывать в множество активных не нужно.

Цикл, значит, примерно такой получается:

	(while (syntaxop = readsyntax f)	
		((core preactivity).ignite syntaxop)
		(activity = core.progress preactivity)
		(preactivity = activity))
	
	while(syntaxop = readsyntax(f))
	{
		(core, preactivity).ignite(syntaxop);
		activity = core.progress(preactivity);
		freekeymap(preactivity);
		preactivity = activity;
	}
	

							     2014-03-26 21:06:23

Так. Это хороший цикл.

							     2014-03-27 22:26:16

Ладно. Проблема с циклом такая. Когда происходит обработка списка ожидающих
своей очереди форм, то не учитывается: в один прекрасный момент может сработать
Done, и всё исчезнет.

При этом список форм, который есть в реакторе будет уничтожен. А в synthone над
этим списком издевается не по-детски.

Решения тут может быть 2.

1.
	Отложить Done до конца обработки списка. Но это как-то не особо логично.

2.
	Не издеваться над списком. Собрать неактивные формы отдельно, а потом
	принять решение о том, что делать со списком форм.

	Разбираться с формами, пока область активна. Ок. Это понятно и приемлемо

Так. Маленькая тонкость. Там со списком форм всё хорошо было. Потому что он
обнулялся перед тем, как начать процесс. Поэтому отматываем изменения обратно.

А иначе возникнет косяк с формами из FPut.

Но при этом со списком форм надо как-то аккуратнее. Надо манипулировать
маркерами external.

							     2014-03-29 23:03:44

Так. Очередная проблема, Хьюстон. Может ли у нас быть так, что область done, а
мы хотим из неё сотворить форму, а форму в реакторе 1 ссылаются на формы из
окружения?

Вполне может быть так. Варианты решения проблемы?

1.
	В первый реактор всегда затаскивать копии форм. Это решается
	дополнительным параметром в extractbody.

2.
	Во время Done не удалять ссылку на окружение для текущего контекста. А
	форму копировать при необходимости.

Удержание ссылки, вроде как, проще. Вмешательство в код extractbody потребуется
в любом случае, поэтому не критерий. Не так уж и проще.

Ещё одна проблема тут может быть: если забрасываем форму из одного контекста в
другой, то, вроде как, она должна тоже быть скопирована из окружения, потому что
то место, куда кидаем форму вообще может не иметь особой связи с исходной
областью вывода.

Надо копировать. Ок. Значит, первый вариант. areareform, значит, может
полагаться на то, что в R.1 хранятся копии форм и можно их без дополнительных
проверок использовать.

Ок. Поехали

Снова загвоздка:

	Когда мы в areareform делаем графу fork, то должны поменять ссылки и в
	FOut-ах. А наша любимая forkdag ничего не сообщает о том, чего она там
	нафоркала. И что делать?

	Эх. Не всё так просто, да?

							     2014-03-30 10:26:24

А дополнительным вагончиком сложности является то, что постоянно копировать
графы для Rip и FPut очень не выгодно. Они же будут увеличиваться, и сложность
будет минимум n^2, что очень хреново.

А чтобы подставлять содержимое .R всяко разно и произвольно в графы придётся
опять серьёзно перерабатывать систему управления памятью. Времени нет. Это надо
будет делать в следующей версии.

А пока задача - завести coremark.

Хорошо. Вообще представляется, что содержимое .R-ок нужно будет только в
определённых местах. И можно собирать их только один раз. Если потребуется
собирать много раз, то всегда есть окружения, в которые их можно сохранять в
виде форм.

Если понадобится куда-нибудь вставить нечто, то можно использовать такую
технику:

	.FEnv ("someName"; .R (("sourceDag")));
	...

	.FPut (.R (("replication")); (); .FEnv ("someName"));
	.LB ( .LB (.LB (.Rip (.R (("replication"))))));

	(dag LB (dag LB (Rip (R ("replication")))))

	@LB x : @LB y : .Rip : .R "replication"
	
	(.FPut (.R ("replication")) () (.FEnv ("someName")))
	(.LB (.LB (.LB (.Rip (.R ("replication"))))));

Ок. Это всё замечательно, только работать не будет, потому что нам же нужен
сигнал о том, что всё завершено, поэтому:

	(.FPut (.R ("replication")) () (.FEnv ("someName)))
	(.FPut 1 ("repdone") (.F (
		(.LB (.LB (.LB (.Rip (.R ("replication")))))))))

	.FPut + .R ("replication") + () + .FEnv ("someName");

	(FPut (R ("replication")) () (FEnv "someName"))
	(FPut 0 ("repdone") (F
		(LB (LB (LB (Rip (R ("replication))))))))

Ладно. Это всё не семантика. Тут на самом деле возникает такой вопрос: а как,
чёрт возьми, этот "repdone" заставить сгенерировать?

Ну. Это относительно просто в текущей семантике. Вообще это всё как-то
гиперсложно. Нужно отождествлять списки из одного элемента с одним элементом.

	(.R ("collector" "target") (.R "self"))
	(.R ("collector" "source") (.R ("some" "dag" "source")))

	(.FPut (.R "collector") () (.F
		(.Rip (.R "source"))
		(.FPut 1 (.F
			(.FOut (.R "target") ("repdone" 1))
			(.Done))))
		(.FOut (.R "target") ("coldone" 1))
		(.Done))
	
	// Теперь в collector будет граф с приписанной к нему формой, посылающей
	// done в target. Это можно теперь забрать в окружение по готовности:

	(.FPut 0 "coldone" (.F
		(.FEnv "someName" (.R "collector")))
	
	// А теперь можно использовать повторно

	(.FPut (.R ("replica" "target") (.R "self")) () .FEnv ("someName"))
	(.FPut 0 ("repdone") (.F
		(.LB (.LB (.LB (.Rip (.R "replica")))))))

"repdone", имена целей и прочее параметризуются. Так что, всё, вроде, Ok.

Ладно. Оставляем эту семантику. Нужно вместо join тогда иметь rip и уничтожать
область вывода.

"self"-ссылку добавить не сложно. Поэтому это не приоритетная задача. Надо
сначала разобраться с rip-ами

							     2014-03-30 15:30:36

Нет мы не можем принять решение о копировании формы из окружения в момент
ripareaforms, потому что окружение может быть закрыто уже по разным причинам.
Где-то про это уже было.

							     2014-04-01 22:37:05

Ладно. Что там с reform внутри intakeform? Оно, вроде, занято какой-то
совершенно никчёмной тривиальной операцией, которую можно вынести наружу из
intakeforms.

							     2014-04-02 21:39:48

Rip-ы должны обрабатываться уже после очистки графа от системного мусора. Потому
что чистить мусор в большом графе - это ещё то O(n^2) удовольствие.  Но у
каждого Rip-а есть параметр R, который во время очистки от мусора зависнет.
Поэтому, когда будет перебираться граф, R должны просто освобождаться.
areamarks будет, поэтому не важно, есть R или нет уже.  

Как-то напрягает только то, что придётся подшивать всё прямо в графы. Да ладно.
Указатели всё-равно не поменяются. Ладно. Надо говорить: Ок, принято и поехали.

							     2014-04-06 17:18:43

Так. Надо собраться. В Core как раз аккуратно нет никаких envmarks-ов. Там есть
symmarks и typemarks, то есть, тех штук, для которых узлы остаются в графе.
Поэтому у этих таблиц нет противоречий с повторным использованием узлов.

Ок. И, видимо, всякие S, T, TEnv, TDef можно тащить из графов. Ну. Ок.

Ладно. Поехали.
