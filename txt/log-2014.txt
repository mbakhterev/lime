							     2014-01-13 23:01:44

Адская проблема с цитатой цитат. И вообще сложный вопрос: должен ли генератор
графа программы уметь генерировать новые генераторы программ?

По идее, должен. Это наиболее простой способ разобраться со структурами и
union-ами всякими. Ок. Зафиксируем это. Нам нужна генерация генераторов.

Но как это сделать? Вероятно, имеет смысл размышлять так. Наши программы - это
просто строки. И генераторы - это тоже строки (собственно тут ничего особо
нового, lambda - это тоже строки, поэтому здесь мы с генерального пути не
сходим). Ок.

Но дальше возникает вопрос с подстановками. Если мы хотим генерировать
генераторы, то указания на подстановки не должны выполнятся. Их надо
экранировать.

В lambda это экранируется собственно lambda-ми... Хм. Ну, Ок. И что?

--

C lambda всё хорошо, потому что там последовательность подстановок явно задана
(в обратном порядке) последовательностью lambda-термов. Но если мы хотим нечто
параллельное и событийное, нам нужно отойти от этой упорядоченности.

--

Когда у нас есть L = (lam x (lam y (x y))), то мы последовательно подставляем
другие выражения. При чём явно и последовательно. Сначала вместо x, потому
вместо y.

И делаем мы это явно, записывая ((L a) b). Но это не события, а последовательное
применение.

Если мы хотим событий, то должны писать как-то так: (e1.(signature 1) ...
eN.(signature N) (a.(add e1 e2) (sub a eN))

--

Проблема вот в чём (возможно). Когда мы говорим о лямбда, то у нас есть просто
группоид с аппликацией L1 L2 -> L3. Из одного выражения применением к другому
получается третье. Замечательно. Но в этом месте и различие.

Когда мы говорим о RiDE, то у нас есть некоторый контекст и к нему мы применяем
правило (форму), и получаем новый контекст (или даже новые контексты; но для
простоты можно считать, что он один). И мы должны писать C1 f -> C2.

f, при этом, вносит кусочек своего тела в новый контекст. Хм. Можно сказать, что
это похоже на трассы (trace) из CSP и теории следов (trace). Ок. Замечательно.
Мы пока не далеко ушли от общепринятого.

А. Ну и вот тут, собственно, загвоздка. А как нам превратить контекст в форму?
Это как раз и нужно для формирования форм для обработки структур и функций. Так,
замечательно. Значит, вопрос сводится к более конкретному: как формировать формы
из контекстов.

--

По идее, нам должно помогать то, что и формы, и контексты - это деревья (точнее,
ориентированные графы без циклов, но dag-и не звучит).

В принципе, мы могли бы сделать нечто такое. Вот есть форма - это F-узел с
атрибутами, содержащими некоторое дерево. Допустим, можно сказать, что вот в
этом дереве может быть G-узел, который содержит то дерево, которое пойдёт на
дописывание в контекст. Мы можем добавить парочку узлов, типа GWr, GRd для
обмена с этим поддеревом информацией через специальную таблицу.

Но в итоге это не особо спасёт нас от рекурсии: а что если мы хотим в
результирующий граф как раз и дописать узлы GWr, GRd? И вложенные G до кучи?

И ещё одно contra против подхода: в lambda можно обойтись только lambda.
Z-комбинатор и всё такое прочее.

--

О! А если мы посмотрим так. С логической точки зрения. По идее, форма может
являться конъюнктом, то есть штукой, для которой нужно выполнение всех условий,
чтобы сработать.

Контекст при этом является у нас дизъюнктом (ну, чем-то вроде), который ожидает
срабатывания одного из условий.

Это не изоморфизм, а просто аналогия. В принципе, формы и контексты могут быть
равноправными в том смысле, что мы можем копировать и запоминать в окружениях не
только формы, но и накопленные контексты.

Теоретически, этого может хватить для реализации структур. Ок. Эту мысль надо
развернуть.

P.S. Да, я в курсе, что в lambda все компоненты, необходимые для логики
(константы и операции) выражаются лямбда-термами. Возможно, где-то тут зарыта
тонкость. Потому что lambda всё равно требует вычисления значений всех
переменных. А когда мы говорим о распределённых и параллельных вычислениях, то
для принятия решения об истинности ИЛИ нам необходимо дождаться первого
истинного значения.

--

Тут +1-ом проходит то, что такой контекст мы можем записать в виде формы: в
штуке будет просто много выдачей с разными ключами тех форм, которые составляют
контекст.

Гомоиконичность соблюдается. Генерация такого контекста эквивалентна генерации
такой формы. Ну +\- какие-то детали, но в целом, похоже на правду.

Дальше? А дальше нам нужен конкретный пример. Потому что, возникает вопрос: а
как нам результат эволюции одного контекста приписать к контексту другому.

--

Проблема всё-равно с подстановкой в нужное место. Ну, банальная ситуация: if(a <
b) { c = d; } Накопленный контекст для ветки "c = d" нужно вставить в структуру
блоков, которая соответствует if-у. Так?

Так. Для этого у нас есть Crop. Специально его экранировать не нужно, потому что
он и так внутри формы стоит. Формы в нашем случае это аналоги lambda. Несколько
витиеватые, но сойдут для версии 0.D.

Так. Вроде. Этот вариант должен работать. Тут нет необходимости шаманить с
Quote-ами и eXecute-ами. Вроде, всё понятно и можно сделать без них.

--

По идее, у метода +100500 достоинств.

Формы всегда замкнутые. Мы можем свободно перекидывать их между контекстами без
проверок. Их можно использовать в качестве значений для параметров других форм.
В FOut-ах, то есть.

По узлам всё упрощается существенно. Дополнительная логика, которая потребуется
- это Crop + R и всё. То есть, только areaeval без execeval с глючным смыслам.

Сами контексты (R-ы) можно тоже передавать в качестве параметров в формы.

Ну и тут мы ближе к lambda. Не нужно два варианта апликаций и экранов. Хватает
просто форм. От lambda мы отличаемся тем, что умеем явно манипулировать
распределёнными контекстами вывода.

Ок. Принимаем такой вариант. Будем пробовать.

PS: Eureka
