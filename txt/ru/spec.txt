СПЕЦИФИКАЦИЯ LiME. Версия 0.dev (в разработке).

									    ЦЕЛЬ

Сделать систему трансляции, которая давала бы программисту несколько
инструментов, которые, как показывает практика современного программирования,
востребованы и позволяют повысить производительность труда:

	- система типов с автоматическим выводом (возможно, в некоторой
	  ограниченной форме);

	- средства определения пользовательские конструкции для управления
	  потоком вычисления, создавать собственные реализации for/if/switch;

	- замыкания, как более гибкую в сравнении с ООП систему декомпозиции и
	  композиции кода (тут можно сослаться на опыт Go);

	- специализацию кода во время исполнения, что, как известно ('C:
	  http://pdos.csail.mit.edu/papers/tickc-poletto-phd.pdf) существенно
	  повышает эффективность программ;

	- императивную семантику, которая предоставляет программисту большую
	  гибкость в построении различных систем событий;

	- модель исполнения ориентированную на процессы, а не на потоки;
	  процессы (в том числе и программно-изолированные) удобнее и
	  эффективнее в задачах управления ресурсами по сравнению с нитями, и не
	  уступают последним в эффективности при выполнении многозадачных
	  вычислений;

	- средства статического анализа кода и верификации;

	- оптимизирующий компилятор, позволяющий разрабатывать
	  высокопроизводительные приложения для супер-компьютеров.

В той или иной степени некоторые из этих инструментов реализованы в различных
системах программирования, однако все они не собраны ни в одной. Поэтому
возникает идея разработать подобную систему трансляции.

Побочным эффектом при её реализации должна стать возможность достаточно простой
организации frontend-ов некоторых традиционных языков программирования (C99,
Fortran, etc) поверх системы LiME. Определение базовых типов и конструкций для
описания потока управления на уровне пользователя должны свести задачу
построения таких frontend-ов к созданию:

	- кода, переводящего исходный текст программы в исходный текст на LiME,
	  возможно, в несколько оптимизированной форме, сходной с той, что сам
	  LiME (LiME is Metaprogramming Engine, поэтому сам) генерирует на этапе
	  лексического анализа;

	- реализаций тех или иных операторов, если они ещё не реализованы, в
	  рамках семантического движка LiME.

Примерно так.

								  СТРУКТУРА LiME

Здесь описан текущий высокоуровневый взгляд на систему.

LiME состоит из нескольких компонент, каждая из которых внутри между своими
составными частями имеет обратные связи (глупые обозначения английскими буквами
нужны для удобства ссылок, если понадобятся).

	- LX: лексический анализатор с вполне классической структурой, с
	  небольшими отличиями (если не считать ключевые слова) от лексики Си;
	  лексический анализатор передаёт на синтаксическую стадию анализа поток
	  лексем вида («:» - условный разделить, главное, что речь о тройках):

	  	тип лексемы : значение : позиция в тексте;
	
	  под «типом лексемы» понимается:

	  	- идентификатор,
		- константа,
		- одна из групп операторов;
	  
	- SX: синтаксический анализатор простых операторных выражений, для
	  которого тоже достаточно простых алгоритмов; решётка приоритетов
	  операторов похожа на используемую в Go (в Си она слишком большая,
	  часто приходится вспоминать, но это нам не помешает);

	  неклассическая особенность: синтаксический анализатор может
	  «придумывать» некоторые операторы по фиксированной схеме;
	  синтаксический анализатор передаёт в семантический анализатор

	  список «команд» вида: 

		новый номер выражения = атом;

	  	новый номер выражения = унарный оператор : номер подвыражения;

		новый номер левого «вектора»
			= бинарный оператор
			: номер левого подвыражения

		новый номер выражения
			= номер левого «вектора»
			: номер правого подвыражения
		
	  «=» и «:» - это малозначимое форматирование; такой интерфейс не совсем
	  традиционный, но тут всё строго;

	  такие нетрадиционности необходимы, чтобы в LiME можно было
	  программировать, например, такие конструкции (в ней нет ключевых
	  слов и встроенных операторов):

	  	for(var (x.1; x.2) = range2d(0:N-1; 0:M-1))
		(
			sum += field(x.1; x.2)
		)

	  frontend-ы других языков программирования могут взаимодействовать со
	  следующей, основной частью всей системы через генерацию такого вида
	  «команд»;

	- SE: семантический «движок» - основная часть системы, которая на основе
	  команд, описывающих связи выражений с операторами строит промежуточное
	  представление программы, пригодное для генерации кода;
	
	  пока такое промежуточное представление предполагается делать в виде
	  кода из тетрад (в основном), то есть, элементов вида:

	  	код операции «метка» =
			«ссылка на аргумент 1», «ссылка на аргумент 2»

	  это текстовое представление, доступное программисту, поэтому
	  желательно, чтобы оно было таким; метки удобны для программиста,
	  а этот формат удобно разбирать; двоичное представление
	  последовательности таких выражений, конечно, триадное; пример:

	  	a = x + y | z
		
		addr	pa = a;		// идея разделения получения адреса
		addr	px = x;		// значения, его загрузки и собственно
		addr	py = y;		// вычисления взята из LCC; это
		addr	pz = z;		// позволяет упростить кодировку
		ld.u8	vx = px;	// операции (or, add работают только со
		ld.u8	vy = py;	// значениями; addr - с символами;
		ld.u8	vz = pz;	// ld - c адресами; можно проверять
	  	or.u8	t1 = y, z;	// корректность); опыт работы с LCC
		add.u8	t2 = x, t;	// позволяет сказать, что в одну
		st.u8	pa = t2;	// инструкцию всё это свернуть просто
	  
	  задача SE брать такие участки кода, которые в процессе трансляции он
	  же связывает с подвыражениями и, руководствуясь специальными
	  таблицами, используя информацию о типах подвыражений и операторе
	  выводить тип составного выражения и соответствующий ему участок кода;

	  в коде могут быть специальные директивы для самого SE, которые он
	  должен выполнять; например, директивы для введения новых переменных
	  или типов;

	  	.var	a = unsignedlonglong;
	  
	  выполнение этой директивы должно сделать запись о символе a с
	  соответствующим типом в специальных таблицах SE;

	  такое представление программы, в котором большинство конструкций
	  проинтерпретировано должно передаваться дальше; набор необходимых
	  директив нужно обсуждать;

Дальнейшие участки проработаны не так хорошо. Какой-то код сгенерировать
возможно пользуясь опытом, полученным от LCC, так как далеко отходить от
традиционной структуры промежуточного представления не планируется. Но как
сгенерировать более оптимальный код - это вопрос будущего.

	- CHK: где-то здесь должна быть система верификации, которая получает
	  достаточно информации от SE, чтобы выполнить определённые проверки
	  кода; хотя бы на выходы за границы; возможно, эта часть должна быть
	  тесно связана с семантикой, но на сегодняшний день представляется, что
	  информации о размерах типов может быть достаточно для решения проблемы
	  контроля выходов за границы памяти; это место тоже надо обсуждать;

	- OPT: оптимизатор, получающий от FE представление программы в
	  промежуточном виде, в котором нет управляющих директив для
	  семантического движка; например, информации о взаимосвязи типов;
	  предполагается, что оптимизатор не нуждается в информации о том,
	  например, что некая структура данных была выведена из выражения

	  	array(20) list hash(string) int.2 
	  
	  вопрос, одако в том, какие знания о программе необходимы для успешной
	  оптимизации; достаточно ли знать только представление в виде потока
	  данных, из которого можно вывести всё остальное?

	  представляется, что оптимизатору не требуется обратная связь с
	  фасадом;

	- CG: генератор кода для целевой машины; должен получать от FE некоторое
	  описание программы, и генерировать по нему ассемблерный код.

Представляется, что во время runtime-специализации кода его семантика не должна
меняться. То есть, например, в функции вычисления, допустим, факториала целые
числа не должны неожиданно превратится в вещественные.

Хотя, может быть, именно такое поведение и требуется программистам: много раз
приходилось слышать, что eval - это очень хорошо. Это тоже открытый вопрос на
данный момент.

Эти сомнения не влияют на особенности реализации C99 поверх LiME. Это всё более
продвинутые алгоритмы на будущее.

Итак. Теперь к каждой части подробнее. Нужно понимать, что изложенное ниже не
является окончательной версией спецификации. Просто в ходе научных (это следует
подчеркнуть, наука в данном случае - поиск нового) исследований, поэтому
некоторые вещи могут показаться странными на первый взгляд. Многое может быть
изменено в более привычную сторону, если возникнет такая необходимость.

Лексический анализатор (сканер).

1. Входной алфавит.

Конечно, сканер должен поддерживать строковые константы. Строковые константы
интерпретируются как цепочки байтов определённой длинны. Они могут быть
дополнены нулём во время семантического анализа для нужно компилятора Си99, но
на уровне сканера они представляются как массивы байтов определённой длинны.

Внутри строк могут встречаться любые символы (цепочки байтов).
Последовательности байтов могут задаваться и через привычные
escape-последовательности: «\t», «\r», «\n», и т.д. Кроме этого, предлагается
задавать цепочки байтов произвольной длины последовательностью «\x([0-0a-f]+)».
Например:

	uint(40) shasum = "\x(f444e5be3f26f57c4fcfa7d32a0379adf70c9473)"

Лексический анализатор поддерживает однострочные комментарии, начинающиеся
последовательностью «//». В комментарии может встречаться любая
последовательность байтов.

Вне строк легальными символами считаются лишь следующие из набора ASCII:

	- TAB - LF 	09 - 0A
	- « » - " 	20 - 22
	- % - &		25 - 26
	- ( - + 	28 - 2B
	- «-» - >	2D - 3E
	- A - Z		41 - 5A
	- ^		5E
	- a - z		61 - 7A
	- |		7C

Некоторых символов здесь нет, можно считать их зарезервированными для будущих
версий, если вдруг понадобятся.

Сканер выделяет в последовательности символов несколько типов лексем:

	- атомы-символы (примитивные идентификаторы): последовательности
	  латинских букв [a-zA-Z]+; атомы сравниваются с учётом регистра; хотя
	  гуру языков программирования аргументируют за нечувствительность к
	  регистру, практика показывает, что X и x лучше трактовать как разные
	  символы, особенно в вычислительных программах; традиционное _ и цифры
	  не включены в алфавит символов, потому что в LiME предусматриваются
	  другие способы давать сложные идентификаторы переменным; например, для
	  описания символов в C99 или во внешних библиотеках можно использовать
	  нечто вроде:

	  	id."classic_c_symbol_with_a_lot_of_underscores"
		id.cpp."SomeClass::overloadedMethod(int, ClassY, float)"

	- атомы-константы: строки, целые и вещественные числа в записи по
	  основаниям 10 и 16. Числа передаются лексическим анализатором на
	  другие уровни трансляции в формате длинных чисел без потери точности;

	- операторы различного приоритета; один приоритет - один тип лексемы:

		0: ;
		1: = *= /= %= >>= <<= &= += -= |= ^= ||= &&=
		2: ->
		3: || ^^
		4: &&
		5: == != < <= > >=
		6: + - | ^
		7: * / % << >> &
		8: «:»
		9: . 
	
	- унарный оператор !

	- скобки: ()

Кажется, ничто не забыто. Теперь о некоторых тонкостях.

1. Немного нетрадиционно обрабатываются вещественные константы. Из допустимых
последовательностей, их представляющих, исключены «.[0-9]+» и «[0-9].». Это
некоторый компромисс, благодаря которому при простом лексическом анализаторе и
немного (совсем немного) нетривиальном синтаксическом анализаторе, программист
получает возможность создавать такие структуры:

	val x = sin(pi/2);
	val y = cos(pi/6);
	val R matrix = (
		0	-12.4	18.9	11;
		11	-12.5	6	10;
		(x+y)	exp(x)	y	0.1
	);

Математики просили обеспечить возможность записывать матрицы с как можно меньшим
количеством знаков пунктуации. Если бы была возможность записывать константу .1
то, здесь:

	y	.1

с учётом наличия оператора «.» возникла бы достаточная неоднозначность: либо это
записаны y и .1, либо дерево (. y 1). Возможность объявлять идентификаторы вида
x.1, и возможность работать с группой идентификаторов с одинаковым именем так же
была запрошена математиками.

2. Никак особо не выделен способ записи целых чисел в виде констант. Здесь
представляется, что достаточно уметь размещать в таблицы констант строки. В
принципе, 'a' и "a" могут ничем не отличаться. Если "a" встречается в контексте,
где производится операция с целым числом, то в константе "a" содержится
достаточно информации, чтобы верно интерпретировать это значение. LiME содержит
всё необходимое, чтобы определять этот контекст.

Кажется, о лексическом анализаторе сказать нечего.

FRONTEND. Синтаксический анализатор (парсер).

В каждый момент времени парсер LiME является синтаксическим анализатором
операторной грамматики

	http://en.wikipedia.org/wiki/Operator-precedence_grammar

работающий по стандартному алгоритму разбора со стеком выражения, связанного
бинарными операторами. Это очень простой и эффективный алгоритм, однако, в
оригинальный его вариант не позволяет строить достаточно выразительные
конструкции. Поэтому в LiME применяется его модификация:

	- в некоторых случаях парсер вставляет в поток лексем вспомогательные
	  лексемы, трактующиеся как бинарные операторы: s-apply и p-apply;

	- после обработки левого (по ходу чтения исходного текста программы
	  слева направо) поддерева выражения и передачи его семантическому
	  анализатору, в результате анализа могут быть выработаны настройки в
	  виде:

	  	- изменения приоритетов некоторых операторов;
		- «отключения бинарности» некоторых операторов;
		- ...;

	  которые будут действовать в лексическом анализаторе во время обработки
	  непосредственного правого поддерева.

Эти ухищрения нужны в основном для того, чтобы без лишней пунктуации описывать
сложные типы данных и конструкции управления потоком управления. Примеры:


	- список двумерных массивов из ассоциативных массивов для пар
	  строка : запись о человеке
	  
	  var L list array(20;20) array(string) record(age uint; name string)

	  в Си++ это был бы ужас из угловых скобок;

	- запуск команды через оболочку «естественным» способом:
	  
	  val p = unixpipe();
	  val proc = ffmpeg -f v4l2 -i "/dev/video0" -af null -vf grayscale > p;
	  var sum int = 0;
	  p.bytes.foreach(x byte) (sum += x < 20 && x < 40);
	  proc.wait();
	  print "число не-таких-уж-ярких-пикселей %d".fmt(sum);

	- сложные управляющие конструкции:

	  x = switch(
	  	y == a -> b;
		y == z -> (val t = sin(z)/exp(y); pin = t*t + 1);
		false -> 3.1415926)

	- возможно, это поможет писать и SQL запросы без дополнительной
	  пунктуации (LINQ пример востребованности такой техники).

Теперь подробнее о каждой из дополнительных техник в парсере.

1. Неявные лексемы s-apply и p-apply.

Парсер «замечает» их в потоке операторов по особым правилам.

p-apply (parentheses) вводится:
	- после атома перед «(»;
	- после «)» перед «(»;

s-apply (space):
	- между двумя атомами;
	- после атома перед унарным оператором;
	- после «)» перед атомом.

Благодаря этому выражения вида

	var x array(20) unsigned long int

не требуют специальных синтаксических конструкций для разбора и легко
превращаются в синтаксические деревья «операторного» вида (фактически, в нечто
подобное S-выражениям).

	(s-apply
		(s-apply var x)
		(s-apply
			(p-apply array (20))
			(s-apply (s-apply unsigned long) int)))

Аналогично, конструкции вида:

	for(x = 0; x < N; x += 1) (dosomething());

Не требуют специального синтаксиса и превращаются в операторные деревья:

	(p-apply (p-apply for (...)) (dosomething()))

То есть, здесь снова не требуется сложного синтаксиса для задания этих
конструкций. Кроме того, используя термины этих операторов программист может
самостоятельно определить конструкцию for, if, switch.

Эти операторы имеют по-умолчанию высокий приоритет: p-apply попадает в одну
группу с точкой (наивысший приоритет), s-apply в имеет приоритет на 1 ниже.


