СПЕЦИФИКАЦИЯ LiME. Версия 0.dev (в разработке).

ЦЕЛЬ.

Сделать систему трансляции, которая давала бы программисту несколько
инструментов, которые, как показывает практика современного программирования,
востребованы и позволяют повысить производительность труда:

	- система типов с автоматическим выводом (возможно, в некоторой
	  ограниченной форме);

	- средства определения пользовательские конструкции для управления
	  потоком вычисления, создавать собственные реализации for/if/switch;

	- замыкания, как более гибкую в сравнении с ООП систему декомпозиции и
	  композиции кода;

	- специализацию кода во время исполнения, что, как известно ('C:
	  http://pdos.csail.mit.edu/papers/tickc-poletto-phd.pdf) существенно
	  повышает эффективность программ;

	- императивную семантику, которая предоставляет программисту большую
	  гибкость в построении различных систем событий;

	- модель исполнения ориентированную на процессы, а не на потоки;
	  процессы (в том числе и программно-изолированные) удобнее и
	  эффективнее в задачах управления ресурсами по сравнению с нитями, и не
	  уступают последним в эффективности при выполнении многозадачных
	  вычислений;

	- средства статического анализа кода и верификации;

	- оптимизирующий компилятор, позволяющий разрабатывать
	  высокопроизводительные приложения для супер-компьютеров.

В той или иной степени некоторые из этих инструментов реализованы в различных
системах программирования, однако все они не собраны ни в одной. Поэтому
возникает идея разработать подобную систему трансляции.

Побочным эффектом при её реализации должна стать возможность достаточно простой
организации frontend-ов некоторых традиционных языков программирования (C99,
Fortran, etc) поверх системы LiME. Определение базовых типов и конструкций для
описания потока управления на уровне пользователя должны свести задачу
построения таких frontend-ов к созданию:

	- кода, переводящего исходный текст программы в исходный текст на LiME,
	  возможно, в несколько оптимизированной форме, сходной с той, что сам
	  LiME (LiME is Metaprogramming Engine, поэтому сам) генерирует на этапе
	  лексического анализа;

	- реализаций тех или иных операторов, если они ещё не реализованы, в
	  рамках семантического движка LiME.

Примерно так.

СТРУКТУРА LiME.

Здесь описан текущий высокоуровневый взгляд на систему.

LiME состоит из двух компонент, каждая из которых внутри между своими
составными частями имеет обратные связи.

	- LX: лексический анализатор с вполне классической структурой, с
	  небольшими отличиями (если не считать ключевые слова) от лексики Си;

	- FE: входной фасад, который содержит синтаксический анализатор и
	  семантический «движок»; в LiME синтаксический анализ примитивный,
	  основанный на операторной грамматике; однако порядок приоритетов
	  операторов может выбираться динамически, на основе разбора предыдущей
	  части исходного текста, поэтому синтаксический анализатор
	  рассматривается как часть семантического «движка» (SE);

	  это нужно для того, чтобы программист в LiME мог пользоваться
	  конструкциями вида:

	  	for(var (x.1; x.2) = range2d(0:N-1; 0:M-1))
		(
			sum += field(x.1; x.2)
		)

	  в этом примере x.1 и x.2 - составные идентификаторы, полученные в виде
	  деревьев: («.» x 1) -- лексемы вида «.[0-9]+» не предусмотрены;

	- CHK: где-то здесь должна быть система верификации, которая получает
	  достаточно информации от SE, чтобы выполнить определённые проверки
	  кода; хотя бы на выходы за границы; возможно, эта часть должна быть
	  тесно связана с семантикой, но на сегодняшний день представляется, что
	  информации о размерах типов может быть достаточно для решения проблемы
	  контроля выходов за границы памяти; это место тоже надо обсуждать;

	- OPT: оптимизатор, получающий от FE представление программы в
	  промежуточном виде, в котором нет управляющих директив для
	  семантического движка; например, информации о взаимосвязи типов;
	  предполагается, что оптимизатор не нуждается в информации о том,
	  например, что некая структура данных была выведена из выражения

	  	array(20) list hash(string) int.2 
	  
	  вопрос, одако в том, какие знания о программе необходимы для успешной
	  оптимизации; достаточно ли знать только представление в виде потока
	  данных, из которого можно вывести всё остальное?

	  представляется, что оптимизатору не требуется обратная связь с
	  фасадом;

	- CG: генератор кода для целевой машины; должен получать от FE некоторое
	  описание программы, и генерировать по нему ассемблерный код.

Представляется, что во время runtime-специализации кода его семантика не должна
меняться. То есть, например, в функции вычисления, допустим, факториала целые
числа не должны неожиданно превратится в вещественные.

Хотя, может быть, именно такое поведение и требуется программистам: много раз
приходилось слышать, что eval - это очень хорошо. Это тоже открытый вопрос на
данный момент.

Эти сомнения не влияют на особенности реализации C99 поверх LiME. Это всё более
продвинутые алгоритмы на будущее.

Итак. Теперь к каждой части подробнее. Нужно понимать, что изложенное ниже не
является окончательной версией спецификации. Просто в ходе научных (это следует
подчеркнуть, наука в данном случае - поиск нового) исследований, поэтому
некоторые вещи могут показаться странными на первый взгляд. Многое может быть
изменено в более привычную сторону, если возникнет такая необходимость.

Лексический анализатор (сканер).

1. Входной алфавит.

Конечно, сканер должен поддерживать строковые константы. Строковые константы
интерпретируются как цепочки байтов определённой длинны. Они могут быть
дополнены нулём во время семантического анализа для нужно компилятора Си99, но
на уровне сканера они представляются как массивы байтов определённой длинны.

Внутри строк могут встречаться любые символы (цепочки байтов).
Последовательности байтов могут задаваться и через привычные
escape-последовательности: «\t», «\r», «\n», и т.д. Кроме этого, предлагается
задавать цепочки байтов произвольной длины последовательностью «\x([0-0a-f]+)».
Например:

	uint(40) shasum = "\x(f444e5be3f26f57c4fcfa7d32a0379adf70c9473)"

Лексический анализатор поддерживает однострочные комментарии, начинающиеся
последовательностью «//». В комментарии может встречаться любая
последовательность байтов.

Вне строк легальными символами считаются лишь следующие из набора ASCII:

	- TAB - LF 	09 - 0A
	- « » - " 	20 - 22
	- % - &		25 - 26
	- ( - + 	28 - 2B
	- «-» - >	2D - 3E
	- A - Z		41 - 5A
	- ^		5E
	- a - z		61 - 7A
	- |		7C

Некоторых символов здесь нет, можно считать их зарезервированными для будущих
версий, если вдруг понадобятся.

Сканер выделяет в последовательности символов несколько типов лексем:

	- атомы-символы (примитивные идентификаторы): последовательности
	  латинских букв [a-zA-Z]+; атомы сравниваются с учётом регистра; хотя
	  гуру языков программирования аргументируют за нечувствительность к
	  регистру, практика показывает, что X и x лучше трактовать как разные
	  символы, особенно в вычислительных программах; традиционное _ и цифры
	  не включены в алфавит символов, потому что в LiME предусматриваются
	  другие способы давать сложные идентификаторы переменным; например, для
	  описания символов в C99 или во внешних библиотеках можно использовать
	  нечто вроде:

	  	id."classic_c_symbol_with_a_lot_of_underscores"
		id.cpp."SomeClass::overloadedMethod(int, ClassY, float)"

	- атомы-константы: строки, целые и вещественные числа в записи по
	  основаниям 10 и 16. Числа передаются лексическим анализатором на
	  другие уровни трансляции в формате длинных чисел без потери точности;

	- операторы различного приоритета; один приоритет - один тип лексемы:

		0: ;
		1: = *= /= %= >>= <<= &= += -= |= ^= ||= &&=
		2: ->
		3: || ^^
		4: &&
		5: == != < <= > >=
		6: + - | ^
		7: * / % << >> &
		8: «:»
		9: . 
	
	- унарный оператор !

	- скобки: ()

Кажется, ничто не забыто. Теперь о некоторых тонкостях.

1. Немного нетрадиционно обрабатываются вещественные константы. Из допустимых
последовательностей, их представляющих, исключены «.[0-9]+» и «[0-9].». Это
некоторый компромисс, благодаря которому при простом лексическом анализаторе и
немного (совсем немного) нетривиальном синтаксическом анализаторе, программист
получает возможность создавать такие структуры:

	val x = sin(pi/2);
	val y = cos(pi/6);
	val R matrix = (
		0	-12.4	18.9	11;
		11	-12.5	6	10;
		(x+y)	exp(x)	y	0.1
	);

Математики просили обеспечить возможность записывать матрицы с как можно меньшим
количеством знаков пунктуации. Если бы была возможность записывать константу .1
то, здесь:

	y	.1

с учётом наличия оператора «.» возникла бы достаточная неоднозначность: либо это
записаны y и .1, либо дерево (. y 1). Возможность объявлять идентификаторы вида
x.1, и возможность работать с группой идентификаторов с одинаковым именем так же
была запрошена математиками.

2. Никак особо не выделен способ записи целых чисел в виде констант. Здесь
представляется, что достаточно уметь размещать в таблицы констант строки. В
принципе, 'a' и "a" могут ничем не отличаться. Если "a" встречается в контексте,
где производится операция с целым числом, то в константе "a" содержится
достаточно информации, чтобы верно интерпретировать это значение. LiME содержит
всё необходимое, чтобы определять этот контекст.

Кажется, о лексическом анализаторе сказать нечего.

FRONTEND. Синтаксический анализатор (парсер).

В каждый момент времени парсер LiME является синтаксическим анализатором
операторной грамматики

	http://en.wikipedia.org/wiki/Operator-precedence_grammar

работающий по стандартному алгоритму разбора со стеком выражения, связанного
бинарными операторами. Это очень простой и эффективный алгоритм, однако, в
оригинальный его вариант не позволяет строить достаточно выразительные
конструкции. Поэтому в LiME применяется его модификация:

	- в некоторых случаях парсер вставляет в поток лексем вспомогательные
	  лексемы, трактующиеся как бинарные операторы: s-apply и p-apply;

	- после обработки левого (по ходу чтения исходного текста программы
	  слева направо) поддерева выражения и передачи его семантическому
	  анализатору, в результате анализа могут быть выработаны настройки в
	  виде:

	  	- изменения приоритетов некоторых операторов;
		- «отключения бинарности» некоторых операторов;
		- ...;

	  которые будут действовать в лексическом анализаторе во время обработки
	  непосредственного правого поддерева.

Эти ухищрения нужны в основном для того, чтобы без лишней пунктуации описывать
сложные типы данных и конструкции управления потоком управления. Примеры:


	- список двумерных массивов из ассоциативных массивов для пар
	  строка : запись о человеке
	  
	  var L list array(20;20) array(string) record(age uint; name string)

	  в Си++ это был бы ужас из угловых скобок;

	- запуск команды через оболочку «естественным» способом:
	  
	  val p = unixpipe();
	  val proc = ffmpeg -f v4l2 -i "/dev/video0" -af null -vf grayscale > p;
	  var sum int = 0;
	  p.bytes.foreach(x byte) (sum += x < 20 && x < 40);
	  proc.wait();
	  print "число не-таких-уж-ярких-пикселей %d".fmt(sum);

	- сложные управляющие конструкции:

	  x = switch(
	  	y == a -> b;
		y == z -> (val t = sin(z)/exp(y); pin = t*t + 1);
		false -> 3.1415926)

	- возможно, это поможет писать и SQL запросы без дополнительной
	  пунктуации (LINQ пример востребованности такой техники).

Теперь подробнее о каждой из дополнительных техник в парсере.

1. Неявные лексемы s-apply и p-apply.

Парсер «замечает» их в потоке операторов по особым правилам.

p-apply (parentheses) вводится:
	- после атома перед «(»;
	- после «)» перед «(»;

s-apply (space):
	- между двумя атомами;
	- после атома перед унарным оператором;
	- после «)» перед атомом.

Благодаря этому выражения вида

	var x array(20) unsigned long int

не требуют специальных синтаксических конструкций для разбора и легко
превращаются в синтаксические деревья «операторного» вида (фактически, в нечто
подобное S-выражениям).

	(s-apply
		(s-apply var x)
		(s-apply
			(p-apply array (20))
			(s-apply (s-apply unsigned long) int)))

Аналогично, конструкции вида:

	for(x = 0; x < N; x += 1) (dosomething());

Не требуют специального синтаксиса и превращаются в операторные деревья:

	(p-apply (p-apply for (...)) (dosomething()))

То есть, здесь снова не требуется сложного синтаксиса для задания этих
конструкций. Кроме того, используя термины этих операторов программист может
самостоятельно определить конструкцию for, if, switch.

Эти операторы имеют по-умолчанию высокий приоритет: p-apply попадает в одну
группу с точкой (наивысший приоритет), s-apply в имеет приоритет на 1 ниже.


