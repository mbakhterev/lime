СПЕЦИФИКАЦИЯ LiME. Версия 0.dev (в разработке).

ЦЕЛЬ.

Сделать систему трансляции, которая давала бы программисту несколько
инструментов, которые, как показывает практика современного программирования,
востребованы и позволяют повысить производительность труда:

	- система типов с автоматическим выводом (возможно, в некоторой
	  ограниченной форме);

	- средства определения пользовательские конструкции для управления
	  потоком вычисления, создавать собственные реализации for/if/switch;

	- замыкания, как более гибкую в сравнении с ООП систему декомпозиции и
	  композиции кода;

	- специализацию кода во время исполнения, что, как известно (проект `C),
	  существенно повышает эффективность программ во время исполнения;

	- императивную семантику, которая предоставляет программисту большую
	  гибкость в построении различных систем событий;

	- модель исполнения ориентированную на процессы, а не на потоки;
	  процессы (в том числе и программно-изолированные) удобнее и
	  эффективнее в задачах управления ресурсами по сравнению с нитями, и не
	  уступают последним в эффективности при выполнении многозадачных
	  вычислений;

	- средства статического анализа кода и верификации;

	- оптимизирующий компилятор, позволяющий разрабатывать
	  высокопроизводительные приложения для супер-компьютеров.

В той или иной степени некоторые из этих инструментов реализованы в различных
системах программирования, однако все они не собраны ни в одной. Поэтому
возникает идея разработать подобную систему трансляции.

Побочным эффектом при её реализации должна стать возможность достаточно простой
организации frontend-ов некоторых традиционных языков программирования (C99,
Fortran, etc) поверх системы LiME. Определение базовых типов и конструкций для
описания потока управления на уровне пользователя должны свести задачу
построения таких frontend-ов к созданию:

	- кода, переводящего исходный текст программы в исходный текст на LiME,
	  возможно, в несколько оптимизированной форме, сходной с той, что сам
	  LiME (LiME is Metaprogramming Engine, поэтому сам) генерирует на этапе
	  лексического анализа;

	- реализаций тех или иных операторов, если они ещё не реализованы, в
	  рамках семантического движка LiME.

Примерно так.

СТРУКТУРА LiME.

Здесь описан текущий высокоуровневый взгляд на систему.

LiME состоит из двух компонент, каждая из которых внутри между своими
составными частями имеет обратные связи.

	- FE: входной фасад, который содержит лексическй анализатор и
	  семантический «движок»; в LiME синтаксический анализ примитивный,
	  основанный на операторной грамматике; однако порядок приоритетов
	  операторов может выбираться динамически, на основе разбора предыдущей
	  части исходного текста, поэтому синтаксический анализатор
	  рассматривается как часть семантического «движка» (SE);

	  лексический анализатор так же связан с SE: в зависимости от набранного
	  контекста может изменяться обработка некоторых лексем; на данный
	  момент это «.» в вещественных константах, которая может
	  интерпретироваться как лексема «.» даже если она встречается в таких,
	  например, последовательностях символов: 1.2, .3;

	  нужно для того, чтобы программист в LiME мог пользоваться
	  конструкциями вида:

	  	for(var (x.1; x.2) = range2d(0:N-1; 0:M-1))
		(
			sum += field(x.1; x.2)
		)

	- CHK: где-то здесь должна быть система верификации, которая получает
	  достаточно информации от SE, чтобы выполнить определённые проверки
	  кода; хотя бы на выходы за границы; возможно, эта часть должна быть
	  тесно связана с семантикой, но на сегодняшний день представляется, что
	  информации о размерах типов может быть достаточно для решения проблемы
	  контроля выходов за границы памяти; это место тоже надо обсуждать;

	- OPT: оптимизатор, получающий от FE представление программы в
	  промежуточном виде, в котором нет управляющих директив для
	  семантического движка; например, информации о взаимосвязи типов;
	  предполагается, что оптимизатор не нуждается в информации о том,
	  например, что некая структура данных была выведена из выражения

	  	array(20) list hash(string) int.2 
	  
	  вопрос, одако в том, какие знания о программе необходимы для успешной
	  оптимизации; достаточно ли знать только представление в виде потока
	  данных, из которого можно вывести всё остальное?

	  представляется, что оптимизатору не требуется обратная связь с
	  фасадом;

	- CG: генератор кода для целевой машины; должен получать от FE некоторое
	  описание программы, и генерировать по нему ассемблерный код.

Представляется, что во время runtime-специализации кода его семантика не должна
меняться. То есть, например, в функции вычисления, допустим, факториала целые
числа не должны неожиданно превратится в вещественные.

Хотя, может быть, именно такое поведение и требуется программистам: много раз
приходилось слышать, что eval - это очень хорошо. Это тоже открытый вопрос на
данный момент.

Эти сомнения не влияют на особенности реализации C99 поверх LiME. Это всё более
продвинутые алгоритмы на будущее.

Итак. Теперь к каждой части подробнее. Нужно понимать, что изложенное ниже не
является окончательной версией спецификации. Просто в ходе научных (это следует
подчеркнуть, наука в данном случае - поиск нового) исследований, поэтому
некоторые вещи могут показаться странными на первый взгляд. Многое может быть
изменено в более привычную сторону, если возникнет такая необходимость.

fRONTEND. Лексический анализатор (сканер).

1. Входной алфавит.

Конечно, сканер должен поддерживать строковые константы. Строковые константы
интерпретируются как цепочки байтов определённой длинны. Они могут быть
дополнены нулём во время семантического анализа для нужно компилятора Си99, но
на уровне сканера они представляются как массивы байтов определённой длинны.

Внутри строк могут встречаться любые символы (цепочки байтов).

Лексический анализатор поддерживает однострочные комментарии, начинающиеся
последовательностью «//». В комментарии может встречаться любая
последовательность байтов.

Вне строк легальными символами считаются лишь следующие из набора ASCII:

	- TAB - LF 	09 - 0A
	- « » - " 	20 - 22
	- % - &		25 - 26
	- ( - + 	28 - 2B
	- «-» - >	2D - 3E
	- A - Z		41 - 5A
	- ^		5E
	- a - z		61 - 7A
	- |		7C

Некоторых символов здесь нет, можно считать их зарезервированными для будущих
версий, если вдруг понадобятся.

Сканер выделяет в последовательности символов несколько типов лексем:

	- атомы-символы (примитивные идентификаторы): последовательности
	  латинских букв [a-zA-Z]+; атомы сравниваются с учётом регистра; хотя
	  гуру языков программирования аргументируют за нечувствительность к
	  регистру, практика показывает, что X и x лучше трактовать как разные
	  символы, особенно в вычислительных программах; традиционное _ и цифры
	  не включены в алфавит символов, потому что в LiME предусматриваются
	  другие способы давать сложные идентификаторы переменным; например, для
	  описания символов в C99 или во внешних библиотеках можно использовать
	  нечто вроде:

	  	id."classic_c_symbol_with_a_lot_of_underscores"
		id.cpp."SomeClass::overloadedMethod(int, ClassY, float)"

	- атомы-константы: строки, целые и вещественные числа в записи по
	  основаниям 10 и 16. Числа передаются лексическим анализатором на
	  другие уровни трансляции в формате длинных чисел без потери точности;

	- операторы различного приоритета; один приоритет - один тип лексемы:

		0: ;
		1: = *= /= %= >>= <<= &= += -= |= ^= ||= &&=
		2: ->
		3: || ^^
		4: &&
		5: == != < <= > >=
		6: + - | ^
		7: * / % << >> &
		8: s-apply :
		9: . p-apply
	
	- унарный оператор !

	- скобки: ()

Кажется, ничто не забыто. Теперь о некоторых тонкостях.

1. Сканер выбирает по одной лексеме. Каждая лексема передаётся в синтаксический
анализатор и семантический движок. Семантический движок может поменять принцип
выбора следующей лексемы. Пока это касается только «.», которая в зависимости от
контекста может по-разному трактоваться в выражениях вида:

	.[0-9]+

Они могут быть разобраны как две лексемы: разделитель «.», константа «[0-9]+»;
или же как одна: константа «.[0-9]+».

2. Лексемы s-apply и p-apply - это неявные операторы, которые сканер вставляет в
поток лексем по специальным правилам: p-apply (parentheses) вставляется:

	- после атома перед «(»;
	- после «)» перед «(»;

s-apply (space) вставляется:

	- между двумя атомами;
	- после атома перед унарным оператором;
	- после «)» перед атомом.

Благодаря этому можно писать такие выражения:

	var x array(20) unsigned long int

которые будут приведены к простой деревянной операторной форме.

3. Никак особо не выделен способ записи целых чисел в виде констант. Здесь
представляется, что достаточно уметь размещать в таблицы констант строки. В
принципе, 'a' и "a" могут ничем не отличаться. Если "a" встречается в контексте,
где производится операция с целым числом, то в константе "a" содержится
достаточно информации, чтобы верно интерпретировать это значение. LiME содержит
всё необходимое, чтобы определять этот контекст.

Кажется, о лексическом анализаторе сказать нечего.
