							     2015-02-06 13:27:55

Так. У нас есть проблемы с выдачей сообщений об ошибках. Необходимо:

1.
	Запоминать положения определения узла в виде файл:строка.

2.
	Выводить эту информацию при сообщениях о внутренних ошибках.

3.
	Необходимы конструкции для отладочной печати и для прерывания по ошибка.	Видимо:

		.Err
		.Dbg

4.
	Неплохо было бы иметь конструкцию, которая помечает текущую область
	вывода как требующую отладки. Чтобы вываливалась трасса того, что там
	происходит. Видимо:

		.Loud (.R ((...)));
	
	Маркер должен быть внутренний.

1, 2, 3 сделать необходимо. Потому что сейчас легко запутаться в информации.

По пункту 1.

Нужно передавать в loaddag имя файла, которое бы превращалось в некоторый токен,
и там бы уже приписывалось к каждому узлу. По памяти не особо эффективно. Можно
было бы приписывать только графам. При обработке можно бы было переключать эти
узлы. Придётся написать слишком много if-ов.

Проще и быстрее (с точки зрения достижения результата) тащить имя исходного
файла для кажого узла.

	loaddag(f, fname, U, map);

fname идёт в U, полученный атом запоминается в какой-нибудь структуре.

	newnode должно принимать больше аргументов.

	enum для доступа к полям должен быть расширен.

	NODERR нужен такой макрос, который по узлу добывает необходимую
	информацию.

По пункту 2.

Просто распечатка аргументов по полной программе. Можно пока так сделать, не
забоятясь о красоте. Стандартным методом через dumplist.

По пункту 3.

Тот же самый вывод сойдёт на первых порах, через dumplist. Однако, нужно
предусмотреть, чтобы всё вываливалось, как при обработке ERR, но при этом, чтобы
не выдавался хвост... Хотя, можно и с хвостом пока в отладочном режиме. Смотреть
на ошибки придётся так:

	mc-knl ... 2>&1 | less

По пункту 4.
	
	Пока не актуально

							     2015-02-16 02:49:30

Мда уж. Проблема в том, что когда мы говорим .Go (.E (("parent"))) в корневом
окружении, там нет никакого "parent". И тогда .E будет создавать эту область
видимости. В этой области видимости будет свой "parent", который будет снабжён
своим "parent". И этот "parent" будет указывать на корневое окружение.

В общем, полный бардак.

Когда нужно будет что-то найти, начав в корневом окружении, в направлении
"parent", мы попадём в вечный цикл и вынос стека.

