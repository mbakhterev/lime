								      2013.02.15

Об атомах. Нужно, чтобы структура для их храниения обеспечивала следующее:

	- атом - это последовательность байтов определённой длинны;

	- чтобы при операциях с памятью не приходилось постоянно пересчитывать
	  strlen или какой-нибудь аналог;

	- хотелось бы, чтобы цепочка байтов, задающая атом начиналась с
	  выровненного адреса, чтобы можно было быстро делать atomcmp;

	- чтобы, возможно, в будущем атомы можно было хранить в списках блоков
	  данных (это для работы в системах без виртуальной памяти);

	- нужно, чтобы размер можно было задавать значениями разной длинны,
	  потому что большинство атомов будут короткими (короче, допустим, 128
	  символов), и для кодирования их длинны не имеет смысла использовать
	  много байтов; будет много атомов длиной даже короче 4 символов;

	- чтение длины должно работать и по неровным адресам, даже на тех
	  машинах, у которых ограничения на чтения/записи только по адресам
	  ровным (natural alignment в виду имеется).

Решением может быть такая структура (точнее, последовательность байтов, ибо
структура не выйдет из-за разного размера значения равного длине атома).

	- байты атома;

	- байт, описывающий его оттенок (hint: десятичный, шестнадцатиричный,
	  идентификатор, строка и т.д., если вдруго понадобится); на этот байт и
	  буде указывать указатель на атом;

	- размер занимающей цепочкой байтов атома в кодировке UTF-8.

Атомы редко будут записываться (фактически, только при загрузке), поэтому:

typedef const unsigned char * Atom;

Таблицу атомов можно представлять просто массивом указателей на них, то есть:

	Atom *

Но для поиска по этой таблице, нужен её индекс. Отсортированный с поиском за
логарифм. Здесь эффективно использовать кучу: если уж таблица и будет удаляться,
то целиком, а место под массив ссылок можно резервировать realloc-ом с
удвоением размера. Это хорошо амортизирует копирования.

Ссылки на атомы при этом в куче будут отличаться от ссылок в таблице, потому что
выданный атому номер в таблице должен сохраняться. Поэтому, действовать можно
двумя способами:

1.	В куче хранить номера атомов, и тогда будет косвенный доступ к ним,
	через чтение: table[index[i]]. Но это немного сэкономит нам память и
	структуру атома.

2.	Можно в атом добавить ещё одно utf-8 закодированное число: его позиция в
	таблице.

Пойдём вторым путём. Потому что поиск будет, скорее всего, требовать больше, чем
6 доступов в память. 6 - это log2(64) и, одновременно, максимальная длинна utf-8
кода. Структура атома:

	- байты;
	- оттенок (сюда указывает указатель на атом);
	- длина в кодировке utf-8;
	- номер атома в кодировке utf-8.

Для реализации этого всего нужны функции:

	- unsigned utf8rd(const char *);
	- unsigned utf8len(const char *);
	- void utf8wr(char *, unsigned);

	- void * expogrow(void *, unsigned);

	- Atom atomload(FILE *);

								      2013.02.16

Следует переименовать utf8 в rune, потому что в plan9 (источнике utf8) такая
терминология, да и выглядит красивее. Логику у функций тоже надо поменять,
чтобы интерфейс был проще:

	- unsigned char * runewr(const unsigned char * p, unsigned n); // с
	  возвратом позиции следующей руны;

	- unsigned char * runerd(const unsigned char * p, unsigned * n); // с
	  возвратом позиции следующей руны;

	- unsigned runerun(const unsigned char * p); // сколько руне
	  продолжаться;

	- unsigned runelen(unsigned v); // сколько байтов необходимо для
	  кодирования руны со значением v.

К вопросу о количестве ведущих нулей:

	0000007f	- 25
	000007ff	- 21
	0000ffff	- 16

Во-первых, не равномерно. И, во вторых, там же разные могут быть символы.
Всё-равно придётся через if делать. Поэтому...

								      2013.02.21

Так. Далее. Нужен интерфейс для таблицы с атомами. Проблема в том, что не
получится сделать атом простыми строками без введения дополнительного уровня
косвенности или смещённости данных. Уровень косвенности неприятен
дополнительными издержками памяти на указатель. В 64-битовой системе - это 8
байтов, которых вполне может хватить на 5-ти символьную строку. Эффективно
выстроить эти структуры в массив (который должен быть из указателей) тоже не
особо выйдет, потому что нужно ещё хранить как-то оттенок и номер. И с
выравниванием это будет трата дополнительных ценный байтов.

Ок. То есть, атомы остаются такими же по структуре. Это не простые C-строки.
Поэтому интерфейс для таблицы, скорее всего, разумно сделать таким:

	- unsigned rdatom(AtomTable *const t, FILE *const f); // загрузить из
	  файла отформатированный атом, то есть такую цепочку байтов:
	  hint.size."byte sequence"; возвращает номер атома;

	- unsigned rdstring(AtomTable *const t, FILE *const f); // загрузить в
	  виде атома цепочку байтов [a-zA-Z0-9] произвольной длинны; возвращает
	  номер атома;

	- resetatomtable(AtomTable *const t); // сбросить таблицу атомов и
	  подготовить её к продолжению работы;

otomtable(AtomTable *const t); // обнулить таблицу атомов,

        - zeroatomtable(AtomTable *const t); // обнулить таблицу атомов,
	
	        - zeroatomtable(AtomTable *const t); // обнулить таблицу атомов,
		- zeroatomtable(AtomTable *const t); // обнулить таблицу атомов,
	  подготовка к первому использованию.

Если понадобится инициализировать таблицу определёнными значениями, можно будет
сделать так:

	char * str = "add del plus minus multiply xyz";
	FILE * f = fmemopen(str, strlen(str), "r");
	unsigned codes[6];
	AtomTable t;

	zeroatomtable(&t);
	resetatomtable(&t);

	codes[rdstring(&t, f)] = ADD;
	codes[rdstring(&t, f)] = DEL;
	...


								      2013.02.23

Проблема с координатами для сообщений об ошибке. Вероятно, имеет смысл их
сделать внешними. То есть, чтобы они устанавливались в глобальных переменных
перед вызовом чтения атома. В принципе, такое возможно. Потому что сейчас
возможны такие варианты чтения:

	- в потоке синтаксических (или лексических) выражений;
	- в потоке узлов в k-выражениях:
		- либо прямо из файла;
		- либо из другого атома.

Во всех этих случаях учёт строк может сбиться из-за того, что атом содержит
переводы строк. В принципе, можно потребовать, чтобы они были экранированы. Всё
это может постепенно превратится в тихий ужас.

								      2013.02.24

Итак. Некоторая определённость с логикой атомов и составных текстов в "" для
LiME. Итак. Начнём с того, что составные тексты lex будет разбирать на слова,
это нужно для более сложных применений LiME (обмен математическими текстами или
моделями и т.д.). Слова - это атомы специальной окраски (hint). Скорее всего они
будут побиты на некоторые классы, в простейшем случае на: (1) alphanum-ы; (2)
цепочки разделителей: «.>=!<&&?» всякое такое (надо внимательней изучить
unicode); (3) цепочки пробельных символов. Возможно всё это будет
соответствовать:

	isalnum
	ispunct
	isspace

Так. То есть, из "x y z = 20 : 40" мы получаем цепочку атомов в формате:
hint.size."bytes".

Для legacy-языков ничего не меняется, они просто свои ""-строки передают в виде
одного слова с hint-ом generic.

Поэтому, атомы можно загружать процедурой rdatom. А при описании k-выражений
использовать "op.T x = y : z" нотацию, загрузив предварительно в какую-нибудь
таблицу значащие атомы: link, type и прочие. lex разберёт это на слова и
передаст дальше, где можно будет всё разобрать точнее.

Так. Если в "-контексте встретятся слова «"», то можно считать промежуточный
набор слов заключённым в кавычки. Это отлавливается. Эти атомы могут быть
зарегистрированы как-нибудь особо. Детали надо уточнить, но тут логика не
нарушается, даже если делать всё в точности подобно обработке «"» на уровне
выше. Алгоритм должен быть аккуратным, но логика сходится.

С прочими видами атомов система дружит. «rdtoken» тоже будет полезна как раз в
lex, и в генераторе кода, пока он не стал работать с биткодом.

