								      2013.02.15

Об атомах. Нужно, чтобы структура для их храниения обеспечивала следующее:

	- атом - это последовательность байтов определённой длинны;

	- чтобы при операциях с памятью не приходилось постоянно пересчитывать
	  strlen или какой-нибудь аналог;

	- хотелось бы, чтобы цепочка байтов, задающая атом начиналась с
	  выровненного адреса, чтобы можно было быстро делать atomcmp;

	- чтобы, возможно, в будущем атомы можно было хранить в списках блоков
	  данных (это для работы в системах без виртуальной памяти);

	- нужно, чтобы размер можно было задавать значениями разной длинны,
	  потому что большинство атомов будут короткими (короче, допустим, 128
	  символов), и для кодирования их длинны не имеет смысла использовать
	  много байтов; будет много атомов длиной даже короче 4 символов;

	- чтение длины должно работать и по неровным адресам, даже на тех
	  машинах, у которых ограничения на чтения/записи только по адресам
	  ровным (natural alignment в виду имеется).

Решением может быть такая структура (точнее, последовательность байтов, ибо
структура не выйдет из-за разного размера значения равного длине атома).

	- байты атома;

	- байт, описывающий его оттенок (hint: десятичный, шестнадцатиричный,
	  идентификатор, строка и т.д., если вдруго понадобится); на этот байт и
	  буде указывать указатель на атом;

	- размер занимающей цепочкой байтов атома в кодировке UTF-8.

Атомы редко будут записываться (фактически, только при загрузке), поэтому:

typedef const unsigned char * Atom;

Таблицу атомов можно представлять просто массивом указателей на них, то есть:

	Atom *

Но для поиска по этой таблице, нужен её индекс. Отсортированный с поиском за
логарифм. Здесь эффективно использовать кучу: если уж таблица и будет удаляться,
то целиком, а место под массив ссылок можно резервировать realloc-ом с
удвоением размера. Это хорошо амортизирует копирования.

Ссылки на атомы при этом в куче будут отличаться от ссылок в таблице, потому что
выданный атому номер в таблице должен сохраняться. Поэтому, действовать можно
двумя способами:

1.	В куче хранить номера атомов, и тогда будет косвенный доступ к ним,
	через чтение: table[index[i]]. Но это немного сэкономит нам память и
	структуру атома.

2.	Можно в атом добавить ещё одно utf-8 закодированное число: его позиция в
	таблице.

Пойдём вторым путём. Потому что поиск будет, скорее всего, требовать больше, чем
6 доступов в память. 6 - это log2(64) и, одновременно, максимальная длинна utf-8
кода. Структура атома:

	- байты;
	- оттенок (сюда указывает указатель на атом);
	- длина в кодировке utf-8;
	- номер атома в кодировке utf-8.

Для реализации этого всего нужны функции:

	- unsigned utf8rd(const char *);
	- unsigned utf8len(const char *);
	- void utf8wr(char *, unsigned);

	- void * expogrow(void *, unsigned);

	- Atom atomload(FILE *);

								      2013.02.16

Следует переименовать utf8 в rune, потому что в plan9 (источнике utf8) такая
терминология, да и выглядит красивее. Логику у функций тоже надо поменять,
чтобы интерфейс был проще:

	- unsigned char * runewr(const unsigned char * p, unsigned n); // с
	  возвратом позиции следующей руны;

	- unsigned char * runerd(const unsigned char * p, unsigned * n); // с
	  возвратом позиции следующей руны;

	- unsigned runerun(const unsigned char * p); // сколько руне
	  продолжаться;

	- unsigned runelen(unsigned v); // сколько байтов необходимо для
	  кодирования руны со значением v.

К вопросу о количестве ведущих нулей:

	0000007f	- 25
	000007ff	- 21
	0000ffff	- 16

Во-первых, не равномерно. И, во вторых, там же разные могут быть символы.
Всё-равно придётся через if делать. Поэтому...
